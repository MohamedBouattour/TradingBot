"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// node_modules/technicalindicators/dist/index.js
var require_dist = __commonJS({
  "node_modules/technicalindicators/dist/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var Item = class {
      constructor(data, prev, next) {
        this.next = next;
        if (next)
          next.prev = this;
        this.prev = prev;
        if (prev)
          prev.next = this;
        this.data = data;
      }
    };
    var LinkedList = class {
      constructor() {
        this._length = 0;
      }
      get head() {
        return this._head && this._head.data;
      }
      get tail() {
        return this._tail && this._tail.data;
      }
      get current() {
        return this._current && this._current.data;
      }
      get length() {
        return this._length;
      }
      push(data) {
        this._tail = new Item(data, this._tail);
        if (this._length === 0) {
          this._head = this._tail;
          this._current = this._head;
          this._next = this._head;
        }
        this._length++;
      }
      pop() {
        var tail = this._tail;
        if (this._length === 0) {
          return;
        }
        this._length--;
        if (this._length === 0) {
          this._head = this._tail = this._current = this._next = void 0;
          return tail.data;
        }
        this._tail = tail.prev;
        this._tail.next = void 0;
        if (this._current === tail) {
          this._current = this._tail;
          this._next = void 0;
        }
        return tail.data;
      }
      shift() {
        var head = this._head;
        if (this._length === 0) {
          return;
        }
        this._length--;
        if (this._length === 0) {
          this._head = this._tail = this._current = this._next = void 0;
          return head.data;
        }
        this._head = this._head.next;
        if (this._current === head) {
          this._current = this._head;
          this._next = this._current.next;
        }
        return head.data;
      }
      unshift(data) {
        this._head = new Item(data, void 0, this._head);
        if (this._length === 0) {
          this._tail = this._head;
          this._next = this._head;
        }
        this._length++;
      }
      unshiftCurrent() {
        var current = this._current;
        if (current === this._head || this._length < 2) {
          return current && current.data;
        }
        if (current === this._tail) {
          this._tail = current.prev;
          this._tail.next = void 0;
          this._current = this._tail;
        } else {
          current.next.prev = current.prev;
          current.prev.next = current.next;
          this._current = current.prev;
        }
        this._next = this._current.next;
        current.next = this._head;
        current.prev = void 0;
        this._head.prev = current;
        this._head = current;
        return current.data;
      }
      removeCurrent() {
        var current = this._current;
        if (this._length === 0) {
          return;
        }
        this._length--;
        if (this._length === 0) {
          this._head = this._tail = this._current = this._next = void 0;
          return current.data;
        }
        if (current === this._tail) {
          this._tail = current.prev;
          this._tail.next = void 0;
          this._current = this._tail;
        } else if (current === this._head) {
          this._head = current.next;
          this._head.prev = void 0;
          this._current = this._head;
        } else {
          current.next.prev = current.prev;
          current.prev.next = current.next;
          this._current = current.prev;
        }
        this._next = this._current.next;
        return current.data;
      }
      resetCursor() {
        this._current = this._next = this._head;
        return this;
      }
      next() {
        var next = this._next;
        if (next !== void 0) {
          this._next = next.next;
          this._current = next;
          return next.data;
        }
      }
    };
    var FixedSizeLinkedList = class extends LinkedList {
      constructor(size, maintainHigh, maintainLow, maintainSum) {
        super();
        this.size = size;
        this.maintainHigh = maintainHigh;
        this.maintainLow = maintainLow;
        this.maintainSum = maintainSum;
        this.totalPushed = 0;
        this.periodHigh = 0;
        this.periodLow = Infinity;
        this.periodSum = 0;
        if (!size || typeof size !== "number") {
          throw "Size required and should be a number.";
        }
        this._push = this.push;
        this.push = function(data) {
          this.add(data);
          this.totalPushed++;
        };
      }
      add(data) {
        if (this.length === this.size) {
          this.lastShift = this.shift();
          this._push(data);
          if (this.maintainHigh) {
            if (this.lastShift == this.periodHigh)
              this.calculatePeriodHigh();
          }
          if (this.maintainLow) {
            if (this.lastShift == this.periodLow)
              this.calculatePeriodLow();
          }
          if (this.maintainSum) {
            this.periodSum = this.periodSum - this.lastShift;
          }
        } else {
          this._push(data);
        }
        if (this.maintainHigh) {
          if (this.periodHigh <= data)
            this.periodHigh = data;
        }
        if (this.maintainLow) {
          if (this.periodLow >= data)
            this.periodLow = data;
        }
        if (this.maintainSum) {
          this.periodSum = this.periodSum + data;
        }
      }
      *iterator() {
        this.resetCursor();
        while (this.next()) {
          yield this.current;
        }
      }
      calculatePeriodHigh() {
        this.resetCursor();
        if (this.next())
          this.periodHigh = this.current;
        while (this.next()) {
          if (this.periodHigh <= this.current) {
            this.periodHigh = this.current;
          }
        }
      }
      calculatePeriodLow() {
        this.resetCursor();
        if (this.next())
          this.periodLow = this.current;
        while (this.next()) {
          if (this.periodLow >= this.current) {
            this.periodLow = this.current;
          }
        }
      }
    };
    var CandleData = class {
    };
    var CandleList = class {
      constructor() {
        this.open = [];
        this.high = [];
        this.low = [];
        this.close = [];
        this.volume = [];
        this.timestamp = [];
      }
    };
    var config2 = {};
    function setConfig(key, value) {
      config2[key] = value;
    }
    function getConfig(key) {
      return config2[key];
    }
    function format(v) {
      let precision = getConfig("precision");
      if (precision) {
        return parseFloat(v.toPrecision(precision));
      }
      return v;
    }
    var IndicatorInput = class {
    };
    var Indicator = class {
      constructor(input) {
        this.format = input.format || format;
      }
      static reverseInputs(input) {
        if (input.reversedInput) {
          input.values ? input.values.reverse() : void 0;
          input.open ? input.open.reverse() : void 0;
          input.high ? input.high.reverse() : void 0;
          input.low ? input.low.reverse() : void 0;
          input.close ? input.close.reverse() : void 0;
          input.volume ? input.volume.reverse() : void 0;
          input.timestamp ? input.timestamp.reverse() : void 0;
        }
      }
      getResult() {
        return this.result;
      }
    };
    var SMA = class extends Indicator {
      constructor(input) {
        super(input);
        this.period = input.period;
        this.price = input.values;
        var genFn = function* (period) {
          var list = new LinkedList();
          var sum2 = 0;
          var counter = 1;
          var current = yield;
          var result;
          list.push(0);
          while (true) {
            if (counter < period) {
              counter++;
              list.push(current);
              sum2 = sum2 + current;
            } else {
              sum2 = sum2 - list.shift() + current;
              result = sum2 / period;
              list.push(current);
            }
            current = yield result;
          }
        };
        this.generator = genFn(this.period);
        this.generator.next();
        this.result = [];
        this.price.forEach((tick) => {
          var result = this.generator.next(tick);
          if (result.value !== void 0) {
            this.result.push(this.format(result.value));
          }
        });
      }
      nextValue(price) {
        var result = this.generator.next(price).value;
        if (result != void 0)
          return this.format(result);
      }
    };
    SMA.calculate = sma;
    function sma(input) {
      Indicator.reverseInputs(input);
      var result = new SMA(input).result;
      if (input.reversedInput) {
        result.reverse();
      }
      Indicator.reverseInputs(input);
      return result;
    }
    var EMA = class extends Indicator {
      constructor(input) {
        super(input);
        var period = input.period;
        var priceArray = input.values;
        var exponent = 2 / (period + 1);
        var sma$$1;
        this.result = [];
        sma$$1 = new SMA({ period, values: [] });
        var genFn = function* () {
          var tick = yield;
          var prevEma;
          while (true) {
            if (prevEma !== void 0 && tick !== void 0) {
              prevEma = (tick - prevEma) * exponent + prevEma;
              tick = yield prevEma;
            } else {
              tick = yield;
              prevEma = sma$$1.nextValue(tick);
              if (prevEma)
                tick = yield prevEma;
            }
          }
        };
        this.generator = genFn();
        this.generator.next();
        this.generator.next();
        priceArray.forEach((tick) => {
          var result = this.generator.next(tick);
          if (result.value != void 0) {
            this.result.push(this.format(result.value));
          }
        });
      }
      nextValue(price) {
        var result = this.generator.next(price).value;
        if (result != void 0)
          return this.format(result);
      }
    };
    EMA.calculate = ema;
    function ema(input) {
      Indicator.reverseInputs(input);
      var result = new EMA(input).result;
      if (input.reversedInput) {
        result.reverse();
      }
      Indicator.reverseInputs(input);
      return result;
    }
    var WMA = class extends Indicator {
      constructor(input) {
        super(input);
        var period = input.period;
        var priceArray = input.values;
        this.result = [];
        this.generator = function* () {
          let data = new LinkedList();
          let denominator = period * (period + 1) / 2;
          while (true) {
            if (data.length < period) {
              data.push(yield);
            } else {
              data.resetCursor();
              let result = 0;
              for (let i2 = 1; i2 <= period; i2++) {
                result = result + data.next() * i2 / denominator;
              }
              var next = yield result;
              data.shift();
              data.push(next);
            }
          }
        }();
        this.generator.next();
        priceArray.forEach((tick, index) => {
          var result = this.generator.next(tick);
          if (result.value != void 0) {
            this.result.push(this.format(result.value));
          }
        });
      }
      //STEP 5. REMOVE GET RESULT FUNCTION
      nextValue(price) {
        var result = this.generator.next(price).value;
        if (result != void 0)
          return this.format(result);
      }
    };
    WMA.calculate = wma;
    function wma(input) {
      Indicator.reverseInputs(input);
      var result = new WMA(input).result;
      if (input.reversedInput) {
        result.reverse();
      }
      Indicator.reverseInputs(input);
      return result;
    }
    var WEMA = class extends Indicator {
      constructor(input) {
        super(input);
        var period = input.period;
        var priceArray = input.values;
        var exponent = 1 / period;
        var sma$$1;
        this.result = [];
        sma$$1 = new SMA({ period, values: [] });
        var genFn = function* () {
          var tick = yield;
          var prevEma;
          while (true) {
            if (prevEma !== void 0 && tick !== void 0) {
              prevEma = (tick - prevEma) * exponent + prevEma;
              tick = yield prevEma;
            } else {
              tick = yield;
              prevEma = sma$$1.nextValue(tick);
              if (prevEma !== void 0)
                tick = yield prevEma;
            }
          }
        };
        this.generator = genFn();
        this.generator.next();
        this.generator.next();
        priceArray.forEach((tick) => {
          var result = this.generator.next(tick);
          if (result.value != void 0) {
            this.result.push(this.format(result.value));
          }
        });
      }
      nextValue(price) {
        var result = this.generator.next(price).value;
        if (result != void 0)
          return this.format(result);
      }
    };
    WEMA.calculate = wema;
    function wema(input) {
      Indicator.reverseInputs(input);
      var result = new WEMA(input).result;
      if (input.reversedInput) {
        result.reverse();
      }
      Indicator.reverseInputs(input);
      return result;
    }
    var MACD = class extends Indicator {
      constructor(input) {
        super(input);
        var oscillatorMAtype = input.SimpleMAOscillator ? SMA : EMA;
        var signalMAtype = input.SimpleMASignal ? SMA : EMA;
        var fastMAProducer = new oscillatorMAtype({ period: input.fastPeriod, values: [], format: (v) => {
          return v;
        } });
        var slowMAProducer = new oscillatorMAtype({ period: input.slowPeriod, values: [], format: (v) => {
          return v;
        } });
        var signalMAProducer = new signalMAtype({ period: input.signalPeriod, values: [], format: (v) => {
          return v;
        } });
        var format2 = this.format;
        this.result = [];
        this.generator = function* () {
          var index = 0;
          var tick;
          var MACD2, signal, histogram, fast, slow;
          while (true) {
            if (index < input.slowPeriod) {
              tick = yield;
              fast = fastMAProducer.nextValue(tick);
              slow = slowMAProducer.nextValue(tick);
              index++;
              continue;
            }
            if (fast && slow) {
              MACD2 = fast - slow;
              signal = signalMAProducer.nextValue(MACD2);
            }
            histogram = MACD2 - signal;
            tick = yield {
              //fast : fast,
              //slow : slow,
              MACD: format2(MACD2),
              signal: signal ? format2(signal) : void 0,
              histogram: isNaN(histogram) ? void 0 : format2(histogram)
            };
            fast = fastMAProducer.nextValue(tick);
            slow = slowMAProducer.nextValue(tick);
          }
        }();
        this.generator.next();
        input.values.forEach((tick) => {
          var result = this.generator.next(tick);
          if (result.value != void 0) {
            this.result.push(result.value);
          }
        });
      }
      nextValue(price) {
        var result = this.generator.next(price).value;
        return result;
      }
    };
    MACD.calculate = macd;
    function macd(input) {
      Indicator.reverseInputs(input);
      var result = new MACD(input).result;
      if (input.reversedInput) {
        result.reverse();
      }
      Indicator.reverseInputs(input);
      return result;
    }
    var AverageGain = class extends Indicator {
      constructor(input) {
        super(input);
        let values = input.values;
        let period = input.period;
        let format2 = this.format;
        this.generator = function* (period2) {
          var currentValue = yield;
          var counter = 1;
          var gainSum = 0;
          var avgGain;
          var gain;
          var lastValue = currentValue;
          currentValue = yield;
          while (true) {
            gain = currentValue - lastValue;
            gain = gain > 0 ? gain : 0;
            if (gain > 0) {
              gainSum = gainSum + gain;
            }
            if (counter < period2) {
              counter++;
            } else if (avgGain === void 0) {
              avgGain = gainSum / period2;
            } else {
              avgGain = (avgGain * (period2 - 1) + gain) / period2;
            }
            lastValue = currentValue;
            avgGain = avgGain !== void 0 ? format2(avgGain) : void 0;
            currentValue = yield avgGain;
          }
        }(period);
        this.generator.next();
        this.result = [];
        values.forEach((tick) => {
          var result = this.generator.next(tick);
          if (result.value !== void 0) {
            this.result.push(result.value);
          }
        });
      }
      nextValue(price) {
        return this.generator.next(price).value;
      }
    };
    AverageGain.calculate = averagegain;
    function averagegain(input) {
      Indicator.reverseInputs(input);
      var result = new AverageGain(input).result;
      if (input.reversedInput) {
        result.reverse();
      }
      Indicator.reverseInputs(input);
      return result;
    }
    var AverageLoss = class extends Indicator {
      constructor(input) {
        super(input);
        let values = input.values;
        let period = input.period;
        let format2 = this.format;
        this.generator = function* (period2) {
          var currentValue = yield;
          var counter = 1;
          var lossSum = 0;
          var avgLoss;
          var loss;
          var lastValue = currentValue;
          currentValue = yield;
          while (true) {
            loss = lastValue - currentValue;
            loss = loss > 0 ? loss : 0;
            if (loss > 0) {
              lossSum = lossSum + loss;
            }
            if (counter < period2) {
              counter++;
            } else if (avgLoss === void 0) {
              avgLoss = lossSum / period2;
            } else {
              avgLoss = (avgLoss * (period2 - 1) + loss) / period2;
            }
            lastValue = currentValue;
            avgLoss = avgLoss !== void 0 ? format2(avgLoss) : void 0;
            currentValue = yield avgLoss;
          }
        }(period);
        this.generator.next();
        this.result = [];
        values.forEach((tick) => {
          var result = this.generator.next(tick);
          if (result.value !== void 0) {
            this.result.push(result.value);
          }
        });
      }
      nextValue(price) {
        return this.generator.next(price).value;
      }
    };
    AverageLoss.calculate = averageloss;
    function averageloss(input) {
      Indicator.reverseInputs(input);
      var result = new AverageLoss(input).result;
      if (input.reversedInput) {
        result.reverse();
      }
      Indicator.reverseInputs(input);
      return result;
    }
    var RSI = class extends Indicator {
      constructor(input) {
        super(input);
        var period = input.period;
        var values = input.values;
        var GainProvider = new AverageGain({ period, values: [] });
        var LossProvider = new AverageLoss({ period, values: [] });
        let count = 1;
        this.generator = function* (period2) {
          var current = yield;
          var lastAvgGain, lastAvgLoss, RS, currentRSI;
          while (true) {
            lastAvgGain = GainProvider.nextValue(current);
            lastAvgLoss = LossProvider.nextValue(current);
            if (lastAvgGain !== void 0 && lastAvgLoss !== void 0) {
              if (lastAvgLoss === 0) {
                currentRSI = 100;
              } else if (lastAvgGain === 0) {
                currentRSI = 0;
              } else {
                RS = lastAvgGain / lastAvgLoss;
                RS = isNaN(RS) ? 0 : RS;
                currentRSI = parseFloat((100 - 100 / (1 + RS)).toFixed(2));
              }
            }
            count++;
            current = yield currentRSI;
          }
        }(period);
        this.generator.next();
        this.result = [];
        values.forEach((tick) => {
          var result = this.generator.next(tick);
          if (result.value !== void 0) {
            this.result.push(result.value);
          }
        });
      }
      nextValue(price) {
        return this.generator.next(price).value;
      }
    };
    RSI.calculate = rsi;
    function rsi(input) {
      Indicator.reverseInputs(input);
      var result = new RSI(input).result;
      if (input.reversedInput) {
        result.reverse();
      }
      Indicator.reverseInputs(input);
      return result;
    }
    var SD = class extends Indicator {
      constructor(input) {
        super(input);
        var period = input.period;
        var priceArray = input.values;
        var sma$$1 = new SMA({ period, values: [], format: (v) => {
          return v;
        } });
        this.result = [];
        this.generator = function* () {
          var tick;
          var mean;
          var currentSet = new FixedSizeLinkedList(period);
          tick = yield;
          var sd2;
          while (true) {
            currentSet.push(tick);
            mean = sma$$1.nextValue(tick);
            if (mean) {
              let sum2 = 0;
              for (let x2 of currentSet.iterator()) {
                sum2 = sum2 + Math.pow(x2 - mean, 2);
              }
              sd2 = Math.sqrt(sum2 / period);
            }
            tick = yield sd2;
          }
        }();
        this.generator.next();
        priceArray.forEach((tick) => {
          var result = this.generator.next(tick);
          if (result.value != void 0) {
            this.result.push(this.format(result.value));
          }
        });
      }
      nextValue(price) {
        var nextResult = this.generator.next(price);
        if (nextResult.value != void 0)
          return this.format(nextResult.value);
      }
    };
    SD.calculate = sd;
    function sd(input) {
      Indicator.reverseInputs(input);
      var result = new SD(input).result;
      if (input.reversedInput) {
        result.reverse();
      }
      Indicator.reverseInputs(input);
      return result;
    }
    var BollingerBands = class extends Indicator {
      constructor(input) {
        super(input);
        var period = input.period;
        var priceArray = input.values;
        var stdDev = input.stdDev;
        var format2 = this.format;
        var sma$$1, sd$$1;
        this.result = [];
        sma$$1 = new SMA({ period, values: [], format: (v) => {
          return v;
        } });
        sd$$1 = new SD({ period, values: [], format: (v) => {
          return v;
        } });
        this.generator = function* () {
          var result;
          var tick;
          var calcSMA;
          var calcsd;
          tick = yield;
          while (true) {
            calcSMA = sma$$1.nextValue(tick);
            calcsd = sd$$1.nextValue(tick);
            if (calcSMA) {
              let middle = format2(calcSMA);
              let upper = format2(calcSMA + calcsd * stdDev);
              let lower2 = format2(calcSMA - calcsd * stdDev);
              let pb = format2((tick - lower2) / (upper - lower2));
              result = {
                middle,
                upper,
                lower: lower2,
                pb
              };
            }
            tick = yield result;
          }
        }();
        this.generator.next();
        priceArray.forEach((tick) => {
          var result = this.generator.next(tick);
          if (result.value != void 0) {
            this.result.push(result.value);
          }
        });
      }
      nextValue(price) {
        return this.generator.next(price).value;
      }
    };
    BollingerBands.calculate = bollingerbands;
    function bollingerbands(input) {
      Indicator.reverseInputs(input);
      var result = new BollingerBands(input).result;
      if (input.reversedInput) {
        result.reverse();
      }
      Indicator.reverseInputs(input);
      return result;
    }
    var WilderSmoothing = class extends Indicator {
      constructor(input) {
        super(input);
        this.period = input.period;
        this.price = input.values;
        var genFn = function* (period) {
          var list = new LinkedList();
          var sum2 = 0;
          var counter = 1;
          var current = yield;
          var result = 0;
          while (true) {
            if (counter < period) {
              counter++;
              sum2 = sum2 + current;
              result = void 0;
            } else if (counter == period) {
              counter++;
              sum2 = sum2 + current;
              result = sum2;
            } else {
              result = result - result / period + current;
            }
            current = yield result;
          }
        };
        this.generator = genFn(this.period);
        this.generator.next();
        this.result = [];
        this.price.forEach((tick) => {
          var result = this.generator.next(tick);
          if (result.value != void 0) {
            this.result.push(this.format(result.value));
          }
        });
      }
      nextValue(price) {
        var result = this.generator.next(price).value;
        if (result != void 0)
          return this.format(result);
      }
    };
    WilderSmoothing.calculate = wildersmoothing;
    function wildersmoothing(input) {
      Indicator.reverseInputs(input);
      var result = new WilderSmoothing(input).result;
      if (input.reversedInput) {
        result.reverse();
      }
      Indicator.reverseInputs(input);
      return result;
    }
    var MDM = class _MDM extends Indicator {
      constructor(input) {
        super(input);
        var lows = input.low;
        var highs = input.high;
        var format2 = this.format;
        if (lows.length != highs.length) {
          throw "Inputs(low,high) not of equal size";
        }
        this.result = [];
        this.generator = function* () {
          var minusDm;
          var current = yield;
          var last;
          while (true) {
            if (last) {
              let upMove = current.high - last.high;
              let downMove = last.low - current.low;
              minusDm = format2(downMove > upMove && downMove > 0 ? downMove : 0);
            }
            last = current;
            current = yield minusDm;
          }
        }();
        this.generator.next();
        lows.forEach((tick, index) => {
          var result = this.generator.next({
            high: highs[index],
            low: lows[index]
          });
          if (result.value !== void 0)
            this.result.push(result.value);
        });
      }
      static calculate(input) {
        Indicator.reverseInputs(input);
        var result = new _MDM(input).result;
        if (input.reversedInput) {
          result.reverse();
        }
        Indicator.reverseInputs(input);
        return result;
      }
      nextValue(price) {
        return this.generator.next(price).value;
      }
    };
    var PDM = class _PDM extends Indicator {
      constructor(input) {
        super(input);
        var lows = input.low;
        var highs = input.high;
        var format2 = this.format;
        if (lows.length != highs.length) {
          throw "Inputs(low,high) not of equal size";
        }
        this.result = [];
        this.generator = function* () {
          var plusDm;
          var current = yield;
          var last;
          while (true) {
            if (last) {
              let upMove = current.high - last.high;
              let downMove = last.low - current.low;
              plusDm = format2(upMove > downMove && upMove > 0 ? upMove : 0);
            }
            last = current;
            current = yield plusDm;
          }
        }();
        this.generator.next();
        lows.forEach((tick, index) => {
          var result = this.generator.next({
            high: highs[index],
            low: lows[index]
          });
          if (result.value !== void 0)
            this.result.push(result.value);
        });
      }
      static calculate(input) {
        Indicator.reverseInputs(input);
        var result = new _PDM(input).result;
        if (input.reversedInput) {
          result.reverse();
        }
        Indicator.reverseInputs(input);
        return result;
      }
      nextValue(price) {
        return this.generator.next(price).value;
      }
    };
    var TrueRange = class extends Indicator {
      constructor(input) {
        super(input);
        var lows = input.low;
        var highs = input.high;
        var closes = input.close;
        var format2 = this.format;
        if (lows.length != highs.length) {
          throw "Inputs(low,high) not of equal size";
        }
        this.result = [];
        this.generator = function* () {
          var current = yield;
          var previousClose, result;
          while (true) {
            if (previousClose === void 0) {
              previousClose = current.close;
              current = yield result;
            }
            result = Math.max(current.high - current.low, isNaN(Math.abs(current.high - previousClose)) ? 0 : Math.abs(current.high - previousClose), isNaN(Math.abs(current.low - previousClose)) ? 0 : Math.abs(current.low - previousClose));
            previousClose = current.close;
            if (result != void 0) {
              result = format2(result);
            }
            current = yield result;
          }
        }();
        this.generator.next();
        lows.forEach((tick, index) => {
          var result = this.generator.next({
            high: highs[index],
            low: lows[index],
            close: closes[index]
          });
          if (result.value != void 0) {
            this.result.push(result.value);
          }
        });
      }
      nextValue(price) {
        return this.generator.next(price).value;
      }
    };
    TrueRange.calculate = truerange;
    function truerange(input) {
      Indicator.reverseInputs(input);
      var result = new TrueRange(input).result;
      if (input.reversedInput) {
        result.reverse();
      }
      Indicator.reverseInputs(input);
      return result;
    }
    var ADXOutput = class extends IndicatorInput {
    };
    var ADX = class extends Indicator {
      constructor(input) {
        super(input);
        var lows = input.low;
        var highs = input.high;
        var closes = input.close;
        var period = input.period;
        var format2 = this.format;
        var plusDM = new PDM({
          high: [],
          low: []
        });
        var minusDM = new MDM({
          high: [],
          low: []
        });
        var emaPDM = new WilderSmoothing({ period, values: [], format: (v) => {
          return v;
        } });
        var emaMDM = new WilderSmoothing({ period, values: [], format: (v) => {
          return v;
        } });
        var emaTR = new WilderSmoothing({ period, values: [], format: (v) => {
          return v;
        } });
        var emaDX = new WEMA({ period, values: [], format: (v) => {
          return v;
        } });
        var tr = new TrueRange({
          low: [],
          high: [],
          close: []
        });
        if (!(lows.length === highs.length && highs.length === closes.length)) {
          throw "Inputs(low,high, close) not of equal size";
        }
        this.result = [];
        ADXOutput;
        this.generator = function* () {
          var tick = yield;
          var index = 0;
          var lastATR, lastAPDM, lastAMDM, lastPDI, lastMDI, lastDX, smoothedDX;
          lastATR = 0;
          lastAPDM = 0;
          lastAMDM = 0;
          while (true) {
            let calcTr = tr.nextValue(tick);
            let calcPDM = plusDM.nextValue(tick);
            let calcMDM = minusDM.nextValue(tick);
            if (calcTr === void 0) {
              tick = yield;
              continue;
            }
            let lastATR2 = emaTR.nextValue(calcTr);
            let lastAPDM2 = emaPDM.nextValue(calcPDM);
            let lastAMDM2 = emaMDM.nextValue(calcMDM);
            if (lastATR2 != void 0 && lastAPDM2 != void 0 && lastAMDM2 != void 0) {
              lastPDI = lastAPDM2 * 100 / lastATR2;
              lastMDI = lastAMDM2 * 100 / lastATR2;
              let diDiff = Math.abs(lastPDI - lastMDI);
              let diSum = lastPDI + lastMDI;
              lastDX = diDiff / diSum * 100;
              smoothedDX = emaDX.nextValue(lastDX);
            }
            tick = yield { adx: smoothedDX, pdi: lastPDI, mdi: lastMDI };
          }
        }();
        this.generator.next();
        lows.forEach((tick, index) => {
          var result = this.generator.next({
            high: highs[index],
            low: lows[index],
            close: closes[index]
          });
          if (result.value != void 0 && result.value.adx != void 0) {
            this.result.push({ adx: format2(result.value.adx), pdi: format2(result.value.pdi), mdi: format2(result.value.mdi) });
          }
        });
      }
      nextValue(price) {
        let result = this.generator.next(price).value;
        if (result != void 0 && result.adx != void 0) {
          return { adx: this.format(result.adx), pdi: this.format(result.pdi), mdi: this.format(result.mdi) };
        }
      }
    };
    ADX.calculate = adx;
    function adx(input) {
      Indicator.reverseInputs(input);
      var result = new ADX(input).result;
      if (input.reversedInput) {
        result.reverse();
      }
      Indicator.reverseInputs(input);
      return result;
    }
    var ATR = class extends Indicator {
      constructor(input) {
        super(input);
        var lows = input.low;
        var highs = input.high;
        var closes = input.close;
        var period = input.period;
        var format2 = this.format;
        if (!(lows.length === highs.length && highs.length === closes.length)) {
          throw "Inputs(low,high, close) not of equal size";
        }
        var trueRange = new TrueRange({
          low: [],
          high: [],
          close: []
        });
        var wema$$1 = new WEMA({ period, values: [], format: (v) => {
          return v;
        } });
        this.result = [];
        this.generator = function* () {
          var tick = yield;
          var avgTrueRange, trange;
          while (true) {
            trange = trueRange.nextValue({
              low: tick.low,
              high: tick.high,
              close: tick.close
            });
            if (trange === void 0) {
              avgTrueRange = void 0;
            } else {
              avgTrueRange = wema$$1.nextValue(trange);
            }
            tick = yield avgTrueRange;
          }
        }();
        this.generator.next();
        lows.forEach((tick, index) => {
          var result = this.generator.next({
            high: highs[index],
            low: lows[index],
            close: closes[index]
          });
          if (result.value !== void 0) {
            this.result.push(format2(result.value));
          }
        });
      }
      nextValue(price) {
        return this.generator.next(price).value;
      }
    };
    ATR.calculate = atr;
    function atr(input) {
      Indicator.reverseInputs(input);
      var result = new ATR(input).result;
      if (input.reversedInput) {
        result.reverse();
      }
      Indicator.reverseInputs(input);
      return result;
    }
    var ROC = class extends Indicator {
      constructor(input) {
        super(input);
        var period = input.period;
        var priceArray = input.values;
        this.result = [];
        this.generator = function* () {
          let index = 1;
          var pastPeriods = new FixedSizeLinkedList(period);
          var tick = yield;
          var roc2;
          while (true) {
            pastPeriods.push(tick);
            if (index < period) {
              index++;
            } else {
              roc2 = (tick - pastPeriods.lastShift) / pastPeriods.lastShift * 100;
            }
            tick = yield roc2;
          }
        }();
        this.generator.next();
        priceArray.forEach((tick) => {
          var result = this.generator.next(tick);
          if (result.value != void 0 && !isNaN(result.value)) {
            this.result.push(this.format(result.value));
          }
        });
      }
      nextValue(price) {
        var nextResult = this.generator.next(price);
        if (nextResult.value != void 0 && !isNaN(nextResult.value)) {
          return this.format(nextResult.value);
        }
      }
    };
    ROC.calculate = roc;
    function roc(input) {
      Indicator.reverseInputs(input);
      var result = new ROC(input).result;
      if (input.reversedInput) {
        result.reverse();
      }
      Indicator.reverseInputs(input);
      return result;
    }
    var KST = class extends Indicator {
      constructor(input) {
        super(input);
        let priceArray = input.values;
        let rocPer1 = input.ROCPer1;
        let rocPer2 = input.ROCPer2;
        let rocPer3 = input.ROCPer3;
        let rocPer4 = input.ROCPer4;
        let smaPer1 = input.SMAROCPer1;
        let smaPer2 = input.SMAROCPer2;
        let smaPer3 = input.SMAROCPer3;
        let smaPer4 = input.SMAROCPer4;
        let signalPeriod = input.signalPeriod;
        let roc1 = new ROC({ period: rocPer1, values: [] });
        let roc2 = new ROC({ period: rocPer2, values: [] });
        let roc3 = new ROC({ period: rocPer3, values: [] });
        let roc4 = new ROC({ period: rocPer4, values: [] });
        let sma1 = new SMA({ period: smaPer1, values: [], format: (v) => {
          return v;
        } });
        let sma2 = new SMA({ period: smaPer2, values: [], format: (v) => {
          return v;
        } });
        let sma3 = new SMA({ period: smaPer3, values: [], format: (v) => {
          return v;
        } });
        let sma4 = new SMA({ period: smaPer4, values: [], format: (v) => {
          return v;
        } });
        let signalSMA = new SMA({ period: signalPeriod, values: [], format: (v) => {
          return v;
        } });
        var format2 = this.format;
        this.result = [];
        let firstResult = Math.max(rocPer1 + smaPer1, rocPer2 + smaPer2, rocPer3 + smaPer3, rocPer4 + smaPer4);
        this.generator = function* () {
          let index = 1;
          let tick = yield;
          let kst2;
          let RCMA1, RCMA2, RCMA3, RCMA4, signal, result;
          while (true) {
            let roc1Result = roc1.nextValue(tick);
            let roc2Result = roc2.nextValue(tick);
            let roc3Result = roc3.nextValue(tick);
            let roc4Result = roc4.nextValue(tick);
            RCMA1 = roc1Result !== void 0 ? sma1.nextValue(roc1Result) : void 0;
            RCMA2 = roc2Result !== void 0 ? sma2.nextValue(roc2Result) : void 0;
            RCMA3 = roc3Result !== void 0 ? sma3.nextValue(roc3Result) : void 0;
            RCMA4 = roc4Result !== void 0 ? sma4.nextValue(roc4Result) : void 0;
            if (index < firstResult) {
              index++;
            } else {
              kst2 = RCMA1 * 1 + RCMA2 * 2 + RCMA3 * 3 + RCMA4 * 4;
            }
            signal = kst2 !== void 0 ? signalSMA.nextValue(kst2) : void 0;
            result = kst2 !== void 0 ? {
              kst: format2(kst2),
              signal: signal ? format2(signal) : void 0
            } : void 0;
            tick = yield result;
          }
        }();
        this.generator.next();
        priceArray.forEach((tick) => {
          let result = this.generator.next(tick);
          if (result.value != void 0) {
            this.result.push(result.value);
          }
        });
      }
      nextValue(price) {
        let nextResult = this.generator.next(price);
        if (nextResult.value != void 0)
          return nextResult.value;
      }
    };
    KST.calculate = kst;
    function kst(input) {
      Indicator.reverseInputs(input);
      var result = new KST(input).result;
      if (input.reversedInput) {
        result.reverse();
      }
      Indicator.reverseInputs(input);
      return result;
    }
    var PSAR = class extends Indicator {
      constructor(input) {
        super(input);
        let highs = input.high || [];
        let lows = input.low || [];
        var genFn = function* (step, max) {
          let curr, extreme, sar, furthest;
          let up = true;
          let accel = step;
          let prev = yield;
          while (true) {
            if (curr) {
              sar = sar + accel * (extreme - sar);
              if (up) {
                sar = Math.min(sar, furthest.low, prev.low);
                if (curr.high > extreme) {
                  extreme = curr.high;
                  accel = Math.min(accel + step, max);
                }
              } else {
                sar = Math.max(sar, furthest.high, prev.high);
                if (curr.low < extreme) {
                  extreme = curr.low;
                  accel = Math.min(accel + step, max);
                }
              }
              if (up && curr.low < sar || !up && curr.high > sar) {
                accel = step;
                sar = extreme;
                up = !up;
                extreme = !up ? curr.low : curr.high;
              }
            } else {
              sar = prev.low;
              extreme = prev.high;
            }
            furthest = prev;
            if (curr)
              prev = curr;
            curr = yield sar;
          }
        };
        this.result = [];
        this.generator = genFn(input.step, input.max);
        this.generator.next();
        lows.forEach((tick, index) => {
          var result = this.generator.next({
            high: highs[index],
            low: lows[index]
          });
          if (result.value !== void 0) {
            this.result.push(result.value);
          }
        });
      }
      nextValue(input) {
        let nextResult = this.generator.next(input);
        if (nextResult.value !== void 0)
          return nextResult.value;
      }
    };
    PSAR.calculate = psar;
    function psar(input) {
      Indicator.reverseInputs(input);
      var result = new PSAR(input).result;
      if (input.reversedInput) {
        result.reverse();
      }
      Indicator.reverseInputs(input);
      return result;
    }
    var Stochastic = class extends Indicator {
      constructor(input) {
        super(input);
        let lows = input.low;
        let highs = input.high;
        let closes = input.close;
        let period = input.period;
        let signalPeriod = input.signalPeriod;
        let format2 = this.format;
        if (!(lows.length === highs.length && highs.length === closes.length)) {
          throw "Inputs(low,high, close) not of equal size";
        }
        this.result = [];
        this.generator = function* () {
          let index = 1;
          let pastHighPeriods = new FixedSizeLinkedList(period, true, false);
          let pastLowPeriods = new FixedSizeLinkedList(period, false, true);
          let dSma = new SMA({
            period: signalPeriod,
            values: [],
            format: (v) => {
              return v;
            }
          });
          let k, d;
          var tick = yield;
          while (true) {
            pastHighPeriods.push(tick.high);
            pastLowPeriods.push(tick.low);
            if (index < period) {
              index++;
              tick = yield;
              continue;
            }
            let periodLow = pastLowPeriods.periodLow;
            k = (tick.close - periodLow) / (pastHighPeriods.periodHigh - periodLow) * 100;
            k = isNaN(k) ? 0 : k;
            d = dSma.nextValue(k);
            tick = yield {
              k: format2(k),
              d: d !== void 0 ? format2(d) : void 0
            };
          }
        }();
        this.generator.next();
        lows.forEach((tick, index) => {
          var result = this.generator.next({
            high: highs[index],
            low: lows[index],
            close: closes[index]
          });
          if (result.value !== void 0) {
            this.result.push(result.value);
          }
        });
      }
      nextValue(input) {
        let nextResult = this.generator.next(input);
        if (nextResult.value !== void 0)
          return nextResult.value;
      }
    };
    Stochastic.calculate = stochastic;
    function stochastic(input) {
      Indicator.reverseInputs(input);
      var result = new Stochastic(input).result;
      if (input.reversedInput) {
        result.reverse();
      }
      Indicator.reverseInputs(input);
      return result;
    }
    var WilliamsR = class extends Indicator {
      constructor(input) {
        super(input);
        let lows = input.low;
        let highs = input.high;
        let closes = input.close;
        let period = input.period;
        let format2 = this.format;
        if (!(lows.length === highs.length && highs.length === closes.length)) {
          throw "Inputs(low,high, close) not of equal size";
        }
        this.result = [];
        this.generator = function* () {
          let index = 1;
          let pastHighPeriods = new FixedSizeLinkedList(period, true, false);
          let pastLowPeriods = new FixedSizeLinkedList(period, false, true);
          let periodLow;
          let periodHigh;
          var tick = yield;
          let williamsR;
          while (true) {
            pastHighPeriods.push(tick.high);
            pastLowPeriods.push(tick.low);
            if (index < period) {
              index++;
              tick = yield;
              continue;
            }
            periodLow = pastLowPeriods.periodLow;
            periodHigh = pastHighPeriods.periodHigh;
            williamsR = format2((periodHigh - tick.close) / (periodHigh - periodLow) * -100);
            tick = yield williamsR;
          }
        }();
        this.generator.next();
        lows.forEach((low, index) => {
          var result = this.generator.next({
            high: highs[index],
            low: lows[index],
            close: closes[index]
          });
          if (result.value !== void 0) {
            this.result.push(result.value);
          }
        });
      }
      nextValue(price) {
        var nextResult = this.generator.next(price);
        if (nextResult.value != void 0)
          return this.format(nextResult.value);
      }
    };
    WilliamsR.calculate = williamsr;
    function williamsr(input) {
      Indicator.reverseInputs(input);
      var result = new WilliamsR(input).result;
      if (input.reversedInput) {
        result.reverse();
      }
      Indicator.reverseInputs(input);
      return result;
    }
    var ADL = class extends Indicator {
      constructor(input) {
        super(input);
        var highs = input.high;
        var lows = input.low;
        var closes = input.close;
        var volumes = input.volume;
        if (!(lows.length === highs.length && highs.length === closes.length && highs.length === volumes.length)) {
          throw "Inputs(low,high, close, volumes) not of equal size";
        }
        this.result = [];
        this.generator = function* () {
          var result = 0;
          var tick;
          tick = yield;
          while (true) {
            let moneyFlowMultiplier = (tick.close - tick.low - (tick.high - tick.close)) / (tick.high - tick.low);
            moneyFlowMultiplier = isNaN(moneyFlowMultiplier) ? 1 : moneyFlowMultiplier;
            let moneyFlowVolume = moneyFlowMultiplier * tick.volume;
            result = result + moneyFlowVolume;
            tick = yield Math.round(result);
          }
        }();
        this.generator.next();
        highs.forEach((tickHigh, index) => {
          var tickInput = {
            high: tickHigh,
            low: lows[index],
            close: closes[index],
            volume: volumes[index]
          };
          var result = this.generator.next(tickInput);
          if (result.value != void 0) {
            this.result.push(result.value);
          }
        });
      }
      nextValue(price) {
        return this.generator.next(price).value;
      }
    };
    ADL.calculate = adl;
    function adl(input) {
      Indicator.reverseInputs(input);
      var result = new ADL(input).result;
      if (input.reversedInput) {
        result.reverse();
      }
      Indicator.reverseInputs(input);
      return result;
    }
    var OBV = class extends Indicator {
      constructor(input) {
        super(input);
        var closes = input.close;
        var volumes = input.volume;
        this.result = [];
        this.generator = function* () {
          var result = 0;
          var tick;
          var lastClose;
          tick = yield;
          if (tick.close && typeof tick.close === "number") {
            lastClose = tick.close;
            tick = yield;
          }
          while (true) {
            if (lastClose < tick.close) {
              result = result + tick.volume;
            } else if (tick.close < lastClose) {
              result = result - tick.volume;
            }
            lastClose = tick.close;
            tick = yield result;
          }
        }();
        this.generator.next();
        closes.forEach((close, index) => {
          let tickInput = {
            close: closes[index],
            volume: volumes[index]
          };
          let result = this.generator.next(tickInput);
          if (result.value != void 0) {
            this.result.push(result.value);
          }
        });
      }
      nextValue(price) {
        return this.generator.next(price).value;
      }
    };
    OBV.calculate = obv;
    function obv(input) {
      Indicator.reverseInputs(input);
      var result = new OBV(input).result;
      if (input.reversedInput) {
        result.reverse();
      }
      Indicator.reverseInputs(input);
      return result;
    }
    var TRIX = class extends Indicator {
      constructor(input) {
        super(input);
        let priceArray = input.values;
        let period = input.period;
        let format2 = this.format;
        let ema$$1 = new EMA({ period, values: [], format: (v) => {
          return v;
        } });
        let emaOfema = new EMA({ period, values: [], format: (v) => {
          return v;
        } });
        let emaOfemaOfema = new EMA({ period, values: [], format: (v) => {
          return v;
        } });
        let trixROC = new ROC({ period: 1, values: [], format: (v) => {
          return v;
        } });
        this.result = [];
        this.generator = function* () {
          let tick = yield;
          while (true) {
            let initialema = ema$$1.nextValue(tick);
            let smoothedResult = initialema ? emaOfema.nextValue(initialema) : void 0;
            let doubleSmoothedResult = smoothedResult ? emaOfemaOfema.nextValue(smoothedResult) : void 0;
            let result = doubleSmoothedResult ? trixROC.nextValue(doubleSmoothedResult) : void 0;
            tick = yield result ? format2(result) : void 0;
          }
        }();
        this.generator.next();
        priceArray.forEach((tick) => {
          let result = this.generator.next(tick);
          if (result.value !== void 0) {
            this.result.push(result.value);
          }
        });
      }
      nextValue(price) {
        let nextResult = this.generator.next(price);
        if (nextResult.value !== void 0)
          return nextResult.value;
      }
    };
    TRIX.calculate = trix;
    function trix(input) {
      Indicator.reverseInputs(input);
      var result = new TRIX(input).result;
      if (input.reversedInput) {
        result.reverse();
      }
      Indicator.reverseInputs(input);
      return result;
    }
    var ForceIndex = class extends Indicator {
      constructor(input) {
        super(input);
        var closes = input.close;
        var volumes = input.volume;
        var period = input.period || 1;
        if (!(volumes.length === closes.length)) {
          throw "Inputs(volume, close) not of equal size";
        }
        let emaForceIndex = new EMA({ values: [], period });
        this.result = [];
        this.generator = function* () {
          var previousTick = yield;
          var tick = yield;
          let forceIndex;
          while (true) {
            forceIndex = (tick.close - previousTick.close) * tick.volume;
            previousTick = tick;
            tick = yield emaForceIndex.nextValue(forceIndex);
          }
        }();
        this.generator.next();
        volumes.forEach((tick, index) => {
          var result = this.generator.next({
            close: closes[index],
            volume: volumes[index]
          });
          if (result.value != void 0) {
            this.result.push(result.value);
          }
        });
      }
      nextValue(price) {
        let result = this.generator.next(price).value;
        if (result != void 0) {
          return result;
        }
      }
    };
    ForceIndex.calculate = forceindex;
    function forceindex(input) {
      Indicator.reverseInputs(input);
      var result = new ForceIndex(input).result;
      if (input.reversedInput) {
        result.reverse();
      }
      Indicator.reverseInputs(input);
      return result;
    }
    var CCI = class extends Indicator {
      constructor(input) {
        super(input);
        var lows = input.low;
        var highs = input.high;
        var closes = input.close;
        var period = input.period;
        var format2 = this.format;
        let constant = 0.015;
        var currentTpSet = new FixedSizeLinkedList(period);
        var tpSMACalculator = new SMA({ period, values: [], format: (v) => {
          return v;
        } });
        if (!(lows.length === highs.length && highs.length === closes.length)) {
          throw "Inputs(low,high, close) not of equal size";
        }
        this.result = [];
        this.generator = function* () {
          var tick = yield;
          while (true) {
            let tp = (tick.high + tick.low + tick.close) / 3;
            currentTpSet.push(tp);
            let smaTp = tpSMACalculator.nextValue(tp);
            let meanDeviation = null;
            let cci2;
            let sum2 = 0;
            if (smaTp != void 0) {
              for (let x2 of currentTpSet.iterator()) {
                sum2 = sum2 + Math.abs(x2 - smaTp);
              }
              meanDeviation = sum2 / period;
              cci2 = (tp - smaTp) / (constant * meanDeviation);
            }
            tick = yield cci2;
          }
        }();
        this.generator.next();
        lows.forEach((tick, index) => {
          var result = this.generator.next({
            high: highs[index],
            low: lows[index],
            close: closes[index]
          });
          if (result.value != void 0) {
            this.result.push(result.value);
          }
        });
      }
      nextValue(price) {
        let result = this.generator.next(price).value;
        if (result != void 0) {
          return result;
        }
      }
    };
    CCI.calculate = cci;
    function cci(input) {
      Indicator.reverseInputs(input);
      var result = new CCI(input).result;
      if (input.reversedInput) {
        result.reverse();
      }
      Indicator.reverseInputs(input);
      return result;
    }
    var AwesomeOscillator = class extends Indicator {
      constructor(input) {
        super(input);
        var highs = input.high;
        var lows = input.low;
        var fastPeriod = input.fastPeriod;
        var slowPeriod = input.slowPeriod;
        var slowSMA = new SMA({ values: [], period: slowPeriod });
        var fastSMA = new SMA({ values: [], period: fastPeriod });
        this.result = [];
        this.generator = function* () {
          var result;
          var tick;
          var medianPrice;
          var slowSmaValue;
          var fastSmaValue;
          tick = yield;
          while (true) {
            medianPrice = (tick.high + tick.low) / 2;
            slowSmaValue = slowSMA.nextValue(medianPrice);
            fastSmaValue = fastSMA.nextValue(medianPrice);
            if (slowSmaValue !== void 0 && fastSmaValue !== void 0) {
              result = fastSmaValue - slowSmaValue;
            }
            tick = yield result;
          }
        }();
        this.generator.next();
        highs.forEach((tickHigh, index) => {
          var tickInput = {
            high: tickHigh,
            low: lows[index]
          };
          var result = this.generator.next(tickInput);
          if (result.value != void 0) {
            this.result.push(this.format(result.value));
          }
        });
      }
      nextValue(price) {
        var result = this.generator.next(price);
        if (result.value != void 0) {
          return this.format(result.value);
        }
      }
    };
    AwesomeOscillator.calculate = awesomeoscillator;
    function awesomeoscillator(input) {
      Indicator.reverseInputs(input);
      var result = new AwesomeOscillator(input).result;
      if (input.reversedInput) {
        result.reverse();
      }
      Indicator.reverseInputs(input);
      return result;
    }
    var VWAP = class extends Indicator {
      constructor(input) {
        super(input);
        var lows = input.low;
        var highs = input.high;
        var closes = input.close;
        var volumes = input.volume;
        var format2 = this.format;
        if (!(lows.length === highs.length && highs.length === closes.length)) {
          throw "Inputs(low,high, close) not of equal size";
        }
        this.result = [];
        this.generator = function* () {
          var tick = yield;
          let cumulativeTotal = 0;
          let cumulativeVolume = 0;
          while (true) {
            let typicalPrice = (tick.high + tick.low + tick.close) / 3;
            let total = tick.volume * typicalPrice;
            cumulativeTotal = cumulativeTotal + total;
            cumulativeVolume = cumulativeVolume + tick.volume;
            tick = yield cumulativeTotal / cumulativeVolume;
          }
        }();
        this.generator.next();
        lows.forEach((tick, index) => {
          var result = this.generator.next({
            high: highs[index],
            low: lows[index],
            close: closes[index],
            volume: volumes[index]
          });
          if (result.value != void 0) {
            this.result.push(result.value);
          }
        });
      }
      nextValue(price) {
        let result = this.generator.next(price).value;
        if (result != void 0) {
          return result;
        }
      }
    };
    VWAP.calculate = vwap;
    function vwap(input) {
      Indicator.reverseInputs(input);
      var result = new VWAP(input).result;
      if (input.reversedInput) {
        result.reverse();
      }
      Indicator.reverseInputs(input);
      return result;
    }
    function priceFallsBetweenBarRange(low, high, low1, high1) {
      return low <= low1 && high >= low1 || low1 <= low && high1 >= low;
    }
    var VolumeProfile = class extends Indicator {
      constructor(input) {
        super(input);
        var highs = input.high;
        var lows = input.low;
        var closes = input.close;
        var opens = input.open;
        var volumes = input.volume;
        var bars = input.noOfBars;
        if (!(lows.length === highs.length && highs.length === closes.length && highs.length === volumes.length)) {
          throw "Inputs(low,high, close, volumes) not of equal size";
        }
        this.result = [];
        var max = Math.max(...highs, ...lows, ...closes, ...opens);
        var min = Math.min(...highs, ...lows, ...closes, ...opens);
        var barRange = (max - min) / bars;
        var lastEnd = min;
        for (let i2 = 0; i2 < bars; i2++) {
          let rangeStart = lastEnd;
          let rangeEnd = rangeStart + barRange;
          lastEnd = rangeEnd;
          let bullishVolume = 0;
          let bearishVolume = 0;
          let totalVolume = 0;
          for (let priceBar = 0; priceBar < highs.length; priceBar++) {
            let priceBarStart = lows[priceBar];
            let priceBarEnd = highs[priceBar];
            let priceBarOpen = opens[priceBar];
            let priceBarClose = closes[priceBar];
            let priceBarVolume = volumes[priceBar];
            if (priceFallsBetweenBarRange(rangeStart, rangeEnd, priceBarStart, priceBarEnd)) {
              totalVolume = totalVolume + priceBarVolume;
              if (priceBarOpen > priceBarClose) {
                bearishVolume = bearishVolume + priceBarVolume;
              } else {
                bullishVolume = bullishVolume + priceBarVolume;
              }
            }
          }
          this.result.push({
            rangeStart,
            rangeEnd,
            bullishVolume,
            bearishVolume,
            totalVolume
          });
        }
      }
      nextValue(price) {
        throw "Next value not supported for volume profile";
      }
    };
    VolumeProfile.calculate = volumeprofile;
    function volumeprofile(input) {
      Indicator.reverseInputs(input);
      var result = new VolumeProfile(input).result;
      if (input.reversedInput) {
        result.reverse();
      }
      Indicator.reverseInputs(input);
      return result;
    }
    var TypicalPrice = class extends Indicator {
      constructor(input) {
        super(input);
        this.result = [];
        this.generator = function* () {
          let priceInput = yield;
          while (true) {
            priceInput = yield (priceInput.high + priceInput.low + priceInput.close) / 3;
          }
        }();
        this.generator.next();
        input.low.forEach((tick, index) => {
          var result = this.generator.next({
            high: input.high[index],
            low: input.low[index],
            close: input.close[index]
          });
          this.result.push(result.value);
        });
      }
      nextValue(price) {
        var result = this.generator.next(price).value;
        return result;
      }
    };
    TypicalPrice.calculate = typicalprice;
    function typicalprice(input) {
      Indicator.reverseInputs(input);
      var result = new TypicalPrice(input).result;
      if (input.reversedInput) {
        result.reverse();
      }
      Indicator.reverseInputs(input);
      return result;
    }
    var MFI = class extends Indicator {
      constructor(input) {
        super(input);
        var highs = input.high;
        var lows = input.low;
        var closes = input.close;
        var volumes = input.volume;
        var period = input.period;
        var typicalPrice = new TypicalPrice({ low: [], high: [], close: [] });
        var positiveFlow = new FixedSizeLinkedList(period, false, false, true);
        var negativeFlow = new FixedSizeLinkedList(period, false, false, true);
        if (!(lows.length === highs.length && highs.length === closes.length && highs.length === volumes.length)) {
          throw "Inputs(low,high, close, volumes) not of equal size";
        }
        this.result = [];
        this.generator = function* () {
          var result;
          var tick;
          var lastClose;
          var positiveFlowForPeriod;
          var rawMoneyFlow = 0;
          var moneyFlowRatio;
          var negativeFlowForPeriod;
          let typicalPriceValue = null;
          let prevousTypicalPrice = null;
          tick = yield;
          lastClose = tick.close;
          tick = yield;
          while (true) {
            var { high, low, close, volume } = tick;
            var positionMoney = 0;
            var negativeMoney = 0;
            typicalPriceValue = typicalPrice.nextValue({ high, low, close });
            rawMoneyFlow = typicalPriceValue * volume;
            if (typicalPriceValue != null && prevousTypicalPrice != null) {
              typicalPriceValue > prevousTypicalPrice ? positionMoney = rawMoneyFlow : negativeMoney = rawMoneyFlow;
              positiveFlow.push(positionMoney);
              negativeFlow.push(negativeMoney);
              positiveFlowForPeriod = positiveFlow.periodSum;
              negativeFlowForPeriod = negativeFlow.periodSum;
              if (positiveFlow.totalPushed >= period && positiveFlow.totalPushed >= period) {
                moneyFlowRatio = positiveFlowForPeriod / negativeFlowForPeriod;
                result = 100 - 100 / (1 + moneyFlowRatio);
              }
            }
            prevousTypicalPrice = typicalPriceValue;
            tick = yield result;
          }
        }();
        this.generator.next();
        highs.forEach((tickHigh, index) => {
          var tickInput = {
            high: tickHigh,
            low: lows[index],
            close: closes[index],
            volume: volumes[index]
          };
          var result = this.generator.next(tickInput);
          if (result.value != void 0) {
            this.result.push(parseFloat(result.value.toFixed(2)));
          }
        });
      }
      nextValue(price) {
        var result = this.generator.next(price);
        if (result.value != void 0) {
          return parseFloat(result.value.toFixed(2));
        }
      }
    };
    MFI.calculate = mfi;
    function mfi(input) {
      Indicator.reverseInputs(input);
      var result = new MFI(input).result;
      if (input.reversedInput) {
        result.reverse();
      }
      Indicator.reverseInputs(input);
      return result;
    }
    var StochasticRSI = class extends Indicator {
      constructor(input) {
        super(input);
        let closes = input.values;
        let rsiPeriod = input.rsiPeriod;
        let stochasticPeriod = input.stochasticPeriod;
        let kPeriod = input.kPeriod;
        let dPeriod = input.dPeriod;
        let format2 = this.format;
        this.result = [];
        this.generator = function* () {
          let index = 1;
          let rsi$$1 = new RSI({ period: rsiPeriod, values: [] });
          let stochastic$$1 = new Stochastic({ period: stochasticPeriod, high: [], low: [], close: [], signalPeriod: kPeriod });
          let dSma = new SMA({
            period: dPeriod,
            values: [],
            format: (v) => {
              return v;
            }
          });
          let lastRSI, stochasticRSI, d, result;
          var tick = yield;
          while (true) {
            lastRSI = rsi$$1.nextValue(tick);
            if (lastRSI !== void 0) {
              var stochasticInput = { high: lastRSI, low: lastRSI, close: lastRSI };
              stochasticRSI = stochastic$$1.nextValue(stochasticInput);
              if (stochasticRSI !== void 0 && stochasticRSI.d !== void 0) {
                d = dSma.nextValue(stochasticRSI.d);
                if (d !== void 0)
                  result = {
                    stochRSI: stochasticRSI.k,
                    k: stochasticRSI.d,
                    d
                  };
              }
            }
            tick = yield result;
          }
        }();
        this.generator.next();
        closes.forEach((tick, index) => {
          var result = this.generator.next(tick);
          if (result.value !== void 0) {
            this.result.push(result.value);
          }
        });
      }
      nextValue(input) {
        let nextResult = this.generator.next(input);
        if (nextResult.value !== void 0)
          return nextResult.value;
      }
    };
    StochasticRSI.calculate = stochasticrsi;
    function stochasticrsi(input) {
      Indicator.reverseInputs(input);
      var result = new StochasticRSI(input).result;
      if (input.reversedInput) {
        result.reverse();
      }
      Indicator.reverseInputs(input);
      return result;
    }
    var Highest = class extends Indicator {
      constructor(input) {
        super(input);
        var values = input.values;
        var period = input.period;
        this.result = [];
        var periodList = new FixedSizeLinkedList(period, true, false, false);
        this.generator = function* () {
          var result;
          var tick;
          var high;
          tick = yield;
          while (true) {
            periodList.push(tick);
            if (periodList.totalPushed >= period) {
              high = periodList.periodHigh;
            }
            tick = yield high;
          }
        }();
        this.generator.next();
        values.forEach((value, index) => {
          var result = this.generator.next(value);
          if (result.value != void 0) {
            this.result.push(result.value);
          }
        });
      }
      nextValue(price) {
        var result = this.generator.next(price);
        if (result.value != void 0) {
          return result.value;
        }
      }
    };
    Highest.calculate = highest;
    function highest(input) {
      Indicator.reverseInputs(input);
      var result = new Highest(input).result;
      if (input.reversedInput) {
        result.reverse();
      }
      Indicator.reverseInputs(input);
      return result;
    }
    var Lowest = class extends Indicator {
      constructor(input) {
        super(input);
        var values = input.values;
        var period = input.period;
        this.result = [];
        var periodList = new FixedSizeLinkedList(period, false, true, false);
        this.generator = function* () {
          var result;
          var tick;
          var high;
          tick = yield;
          while (true) {
            periodList.push(tick);
            if (periodList.totalPushed >= period) {
              high = periodList.periodLow;
            }
            tick = yield high;
          }
        }();
        this.generator.next();
        values.forEach((value, index) => {
          var result = this.generator.next(value);
          if (result.value != void 0) {
            this.result.push(result.value);
          }
        });
      }
      nextValue(price) {
        var result = this.generator.next(price);
        if (result.value != void 0) {
          return result.value;
        }
      }
    };
    Lowest.calculate = lowest;
    function lowest(input) {
      Indicator.reverseInputs(input);
      var result = new Lowest(input).result;
      if (input.reversedInput) {
        result.reverse();
      }
      Indicator.reverseInputs(input);
      return result;
    }
    var Sum = class extends Indicator {
      constructor(input) {
        super(input);
        var values = input.values;
        var period = input.period;
        this.result = [];
        var periodList = new FixedSizeLinkedList(period, false, false, true);
        this.generator = function* () {
          var result;
          var tick;
          var high;
          tick = yield;
          while (true) {
            periodList.push(tick);
            if (periodList.totalPushed >= period) {
              high = periodList.periodSum;
            }
            tick = yield high;
          }
        }();
        this.generator.next();
        values.forEach((value, index) => {
          var result = this.generator.next(value);
          if (result.value != void 0) {
            this.result.push(result.value);
          }
        });
      }
      nextValue(price) {
        var result = this.generator.next(price);
        if (result.value != void 0) {
          return result.value;
        }
      }
    };
    Sum.calculate = sum;
    function sum(input) {
      Indicator.reverseInputs(input);
      var result = new Sum(input).result;
      if (input.reversedInput) {
        result.reverse();
      }
      Indicator.reverseInputs(input);
      return result;
    }
    var Renko = class extends Indicator {
      constructor(input) {
        super(input);
        var format2 = this.format;
        let useATR = input.useATR;
        let brickSize = input.brickSize || 0;
        if (useATR) {
          let atrResult = atr(Object.assign({}, input));
          brickSize = atrResult[atrResult.length - 1];
        }
        this.result = new CandleList();
        if (brickSize === 0) {
          console.error("Not enough data to calculate brickSize for renko when using ATR");
          return;
        }
        let lastOpen = 0;
        let lastHigh = 0;
        let lastLow = Infinity;
        let lastClose = 0;
        let lastVolume = 0;
        let lastTimestamp = 0;
        this.generator = function* () {
          let candleData = yield;
          while (true) {
            if (lastOpen === 0) {
              lastOpen = candleData.close;
              lastHigh = candleData.high;
              lastLow = candleData.low;
              lastClose = candleData.close;
              lastVolume = candleData.volume;
              lastTimestamp = candleData.timestamp;
              candleData = yield;
              continue;
            }
            let absoluteMovementFromClose = Math.abs(candleData.close - lastClose);
            let absoluteMovementFromOpen = Math.abs(candleData.close - lastOpen);
            if (absoluteMovementFromClose >= brickSize && absoluteMovementFromOpen >= brickSize) {
              let reference = absoluteMovementFromClose > absoluteMovementFromOpen ? lastOpen : lastClose;
              let calculated = {
                open: reference,
                high: lastHigh > candleData.high ? lastHigh : candleData.high,
                low: lastLow < candleData.Low ? lastLow : candleData.low,
                close: reference > candleData.close ? reference - brickSize : reference + brickSize,
                volume: lastVolume + candleData.volume,
                timestamp: candleData.timestamp
              };
              lastOpen = calculated.open;
              lastHigh = calculated.close;
              lastLow = calculated.close;
              lastClose = calculated.close;
              lastVolume = 0;
              candleData = yield calculated;
            } else {
              lastHigh = lastHigh > candleData.high ? lastHigh : candleData.high;
              lastLow = lastLow < candleData.Low ? lastLow : candleData.low;
              lastVolume = lastVolume + candleData.volume;
              lastTimestamp = candleData.timestamp;
              candleData = yield;
            }
          }
        }();
        this.generator.next();
        input.low.forEach((tick, index) => {
          var result = this.generator.next({
            open: input.open[index],
            high: input.high[index],
            low: input.low[index],
            close: input.close[index],
            volume: input.volume[index],
            timestamp: input.timestamp[index]
          });
          if (result.value) {
            this.result.open.push(result.value.open);
            this.result.high.push(result.value.high);
            this.result.low.push(result.value.low);
            this.result.close.push(result.value.close);
            this.result.volume.push(result.value.volume);
            this.result.timestamp.push(result.value.timestamp);
          }
        });
      }
      nextValue(price) {
        console.error("Cannot calculate next value on Renko, Every value has to be recomputed for every change, use calcualte method");
        return null;
      }
    };
    Renko.calculate = renko;
    function renko(input) {
      Indicator.reverseInputs(input);
      var result = new Renko(input).result;
      if (input.reversedInput) {
        result.open.reverse();
        result.high.reverse();
        result.low.reverse();
        result.close.reverse();
        result.volume.reverse();
        result.timestamp.reverse();
      }
      Indicator.reverseInputs(input);
      return result;
    }
    var HeikinAshi = class extends Indicator {
      constructor(input) {
        super(input);
        var format2 = this.format;
        this.result = new CandleList();
        let lastOpen = null;
        let lastHigh = 0;
        let lastLow = Infinity;
        let lastClose = 0;
        let lastVolume = 0;
        let lastTimestamp = 0;
        this.generator = function* () {
          let candleData = yield;
          let calculated = null;
          while (true) {
            if (lastOpen === null) {
              lastOpen = (candleData.close + candleData.open) / 2;
              lastHigh = candleData.high;
              lastLow = candleData.low;
              lastClose = (candleData.close + candleData.open + candleData.high + candleData.low) / 4;
              lastVolume = candleData.volume || 0;
              lastTimestamp = candleData.timestamp || 0;
              calculated = {
                open: lastOpen,
                high: lastHigh,
                low: lastLow,
                close: lastClose,
                volume: candleData.volume || 0,
                timestamp: candleData.timestamp || 0
              };
            } else {
              let newClose = (candleData.close + candleData.open + candleData.high + candleData.low) / 4;
              let newOpen = (lastOpen + lastClose) / 2;
              let newHigh = Math.max(newOpen, newClose, candleData.high);
              let newLow = Math.min(candleData.low, newOpen, newClose);
              calculated = {
                close: newClose,
                open: newOpen,
                high: newHigh,
                low: newLow,
                volume: candleData.volume || 0,
                timestamp: candleData.timestamp || 0
              };
              lastClose = newClose;
              lastOpen = newOpen;
              lastHigh = newHigh;
              lastLow = newLow;
            }
            candleData = yield calculated;
          }
        }();
        this.generator.next();
        input.low.forEach((tick, index) => {
          var result = this.generator.next({
            open: input.open[index],
            high: input.high[index],
            low: input.low[index],
            close: input.close[index],
            volume: input.volume ? input.volume[index] : input.volume,
            timestamp: input.timestamp ? input.timestamp[index] : input.timestamp
          });
          if (result.value) {
            this.result.open.push(result.value.open);
            this.result.high.push(result.value.high);
            this.result.low.push(result.value.low);
            this.result.close.push(result.value.close);
            this.result.volume.push(result.value.volume);
            this.result.timestamp.push(result.value.timestamp);
          }
        });
      }
      nextValue(price) {
        var result = this.generator.next(price).value;
        return result;
      }
    };
    HeikinAshi.calculate = heikinashi;
    function heikinashi(input) {
      Indicator.reverseInputs(input);
      var result = new HeikinAshi(input).result;
      if (input.reversedInput) {
        result.open.reverse();
        result.high.reverse();
        result.low.reverse();
        result.close.reverse();
        result.volume.reverse();
        result.timestamp.reverse();
      }
      Indicator.reverseInputs(input);
      return result;
    }
    var CandlestickFinder = class {
      constructor() {
      }
      approximateEqual(a, b) {
        let left = parseFloat(Math.abs(a - b).toPrecision(4)) * 1;
        let right = parseFloat((a * 1e-3).toPrecision(4)) * 1;
        return left <= right;
      }
      logic(data) {
        throw "this has to be implemented";
      }
      getAllPatternIndex(data) {
        if (data.close.length < this.requiredCount) {
          console.warn("Data count less than data required for the strategy ", this.name);
          return [];
        }
        if (data.reversedInput) {
          data.open.reverse();
          data.high.reverse();
          data.low.reverse();
          data.close.reverse();
        }
        let strategyFn = this.logic;
        return this._generateDataForCandleStick(data).map((current, index) => {
          return strategyFn.call(this, current) ? index : void 0;
        }).filter((hasIndex) => {
          return hasIndex;
        });
      }
      hasPattern(data) {
        if (data.close.length < this.requiredCount) {
          console.warn("Data count less than data required for the strategy ", this.name);
          return false;
        }
        if (data.reversedInput) {
          data.open.reverse();
          data.high.reverse();
          data.low.reverse();
          data.close.reverse();
        }
        let strategyFn = this.logic;
        return strategyFn.call(this, this._getLastDataForCandleStick(data));
      }
      _getLastDataForCandleStick(data) {
        let requiredCount = this.requiredCount;
        if (data.close.length === requiredCount) {
          return data;
        } else {
          let returnVal = {
            open: [],
            high: [],
            low: [],
            close: []
          };
          let i2 = 0;
          let index = data.close.length - requiredCount;
          while (i2 < requiredCount) {
            returnVal.open.push(data.open[index + i2]);
            returnVal.high.push(data.high[index + i2]);
            returnVal.low.push(data.low[index + i2]);
            returnVal.close.push(data.close[index + i2]);
            i2++;
          }
          return returnVal;
        }
      }
      _generateDataForCandleStick(data) {
        let requiredCount = this.requiredCount;
        let generatedData = data.close.map(function(currentData, index) {
          let i2 = 0;
          let returnVal = {
            open: [],
            high: [],
            low: [],
            close: []
          };
          while (i2 < requiredCount) {
            returnVal.open.push(data.open[index + i2]);
            returnVal.high.push(data.high[index + i2]);
            returnVal.low.push(data.low[index + i2]);
            returnVal.close.push(data.close[index + i2]);
            i2++;
          }
          return returnVal;
        }).filter((val, index) => {
          return index <= data.close.length - requiredCount;
        });
        return generatedData;
      }
    };
    var MorningStar = class extends CandlestickFinder {
      constructor() {
        super();
        this.name = "MorningStar";
        this.requiredCount = 3;
      }
      logic(data) {
        let firstdaysOpen = data.open[0];
        let firstdaysClose = data.close[0];
        let firstdaysHigh = data.high[0];
        let firstdaysLow = data.low[0];
        let seconddaysOpen = data.open[1];
        let seconddaysClose = data.close[1];
        let seconddaysHigh = data.high[1];
        let seconddaysLow = data.low[1];
        let thirddaysOpen = data.open[2];
        let thirddaysClose = data.close[2];
        let thirddaysHigh = data.high[2];
        let thirddaysLow = data.low[2];
        let firstdaysMidpoint = (firstdaysOpen + firstdaysClose) / 2;
        let isFirstBearish = firstdaysClose < firstdaysOpen;
        let isSmallBodyExists = firstdaysLow > seconddaysLow && firstdaysLow > seconddaysHigh;
        let isThirdBullish = thirddaysOpen < thirddaysClose;
        let gapExists = seconddaysHigh < firstdaysLow && seconddaysLow < firstdaysLow && thirddaysOpen > seconddaysHigh && seconddaysClose < thirddaysOpen;
        let doesCloseAboveFirstMidpoint = thirddaysClose > firstdaysMidpoint;
        return isFirstBearish && isSmallBodyExists && gapExists && isThirdBullish && doesCloseAboveFirstMidpoint;
      }
    };
    function morningstar(data) {
      return new MorningStar().hasPattern(data);
    }
    var BullishEngulfingPattern = class extends CandlestickFinder {
      constructor() {
        super();
        this.name = "BullishEngulfingPattern";
        this.requiredCount = 2;
      }
      logic(data) {
        let firstdaysOpen = data.open[0];
        let firstdaysClose = data.close[0];
        let firstdaysHigh = data.high[0];
        let firstdaysLow = data.low[0];
        let seconddaysOpen = data.open[1];
        let seconddaysClose = data.close[1];
        let seconddaysHigh = data.high[1];
        let seconddaysLow = data.low[1];
        let isBullishEngulfing = firstdaysClose < firstdaysOpen && firstdaysOpen > seconddaysOpen && firstdaysClose > seconddaysOpen && firstdaysOpen < seconddaysClose;
        return isBullishEngulfing;
      }
    };
    function bullishengulfingpattern(data) {
      return new BullishEngulfingPattern().hasPattern(data);
    }
    var BullishHarami = class extends CandlestickFinder {
      constructor() {
        super();
        this.requiredCount = 2;
        this.name = "BullishHarami";
      }
      logic(data) {
        let firstdaysOpen = data.open[0];
        let firstdaysClose = data.close[0];
        let firstdaysHigh = data.high[0];
        let firstdaysLow = data.low[0];
        let seconddaysOpen = data.open[1];
        let seconddaysClose = data.close[1];
        let seconddaysHigh = data.high[1];
        let seconddaysLow = data.low[1];
        let isBullishHaramiPattern = firstdaysOpen > seconddaysOpen && firstdaysClose < seconddaysOpen && firstdaysClose < seconddaysClose && firstdaysOpen > seconddaysLow && firstdaysHigh > seconddaysHigh;
        return isBullishHaramiPattern;
      }
    };
    function bullishharami(data) {
      return new BullishHarami().hasPattern(data);
    }
    var BullishHaramiCross = class extends CandlestickFinder {
      constructor() {
        super();
        this.requiredCount = 2;
        this.name = "BullishHaramiCross";
      }
      logic(data) {
        let firstdaysOpen = data.open[0];
        let firstdaysClose = data.close[0];
        let firstdaysHigh = data.high[0];
        let firstdaysLow = data.low[0];
        let seconddaysOpen = data.open[1];
        let seconddaysClose = data.close[1];
        let seconddaysHigh = data.high[1];
        let seconddaysLow = data.low[1];
        let isBullishHaramiCrossPattern = firstdaysOpen > seconddaysOpen && firstdaysClose < seconddaysOpen && firstdaysClose < seconddaysClose && firstdaysOpen > seconddaysLow && firstdaysHigh > seconddaysHigh;
        let isSecondDayDoji = this.approximateEqual(seconddaysOpen, seconddaysClose);
        return isBullishHaramiCrossPattern && isSecondDayDoji;
      }
    };
    function bullishharamicross(data) {
      return new BullishHaramiCross().hasPattern(data);
    }
    var Doji = class extends CandlestickFinder {
      constructor() {
        super();
        this.name = "Doji";
        this.requiredCount = 1;
      }
      logic(data) {
        let daysOpen = data.open[0];
        let daysClose = data.close[0];
        let daysHigh = data.high[0];
        let daysLow = data.low[0];
        let isOpenEqualsClose = this.approximateEqual(daysOpen, daysClose);
        let isHighEqualsOpen = isOpenEqualsClose && this.approximateEqual(daysOpen, daysHigh);
        let isLowEqualsClose = isOpenEqualsClose && this.approximateEqual(daysClose, daysLow);
        return isOpenEqualsClose && isHighEqualsOpen == isLowEqualsClose;
      }
    };
    function doji(data) {
      return new Doji().hasPattern(data);
    }
    var MorningDojiStar = class extends CandlestickFinder {
      constructor() {
        super();
        this.name = "MorningDojiStar";
        this.requiredCount = 3;
      }
      logic(data) {
        let firstdaysOpen = data.open[0];
        let firstdaysClose = data.close[0];
        let firstdaysHigh = data.high[0];
        let firstdaysLow = data.low[0];
        let seconddaysOpen = data.open[1];
        let seconddaysClose = data.close[1];
        let seconddaysHigh = data.high[1];
        let seconddaysLow = data.low[1];
        let thirddaysOpen = data.open[2];
        let thirddaysClose = data.close[2];
        let thirddaysHigh = data.high[2];
        let thirddaysLow = data.low[2];
        let firstdaysMidpoint = (firstdaysOpen + firstdaysClose) / 2;
        let isFirstBearish = firstdaysClose < firstdaysOpen;
        let dojiExists = new Doji().hasPattern({
          "open": [seconddaysOpen],
          "close": [seconddaysClose],
          "high": [seconddaysHigh],
          "low": [seconddaysLow]
        });
        let isThirdBullish = thirddaysOpen < thirddaysClose;
        let gapExists = seconddaysHigh < firstdaysLow && seconddaysLow < firstdaysLow && thirddaysOpen > seconddaysHigh && seconddaysClose < thirddaysOpen;
        let doesCloseAboveFirstMidpoint = thirddaysClose > firstdaysMidpoint;
        return isFirstBearish && dojiExists && isThirdBullish && gapExists && doesCloseAboveFirstMidpoint;
      }
    };
    function morningdojistar(data) {
      return new MorningDojiStar().hasPattern(data);
    }
    var DownsideTasukiGap = class extends CandlestickFinder {
      constructor() {
        super();
        this.requiredCount = 3;
        this.name = "DownsideTasukiGap";
      }
      logic(data) {
        let firstdaysOpen = data.open[0];
        let firstdaysClose = data.close[0];
        let firstdaysHigh = data.high[0];
        let firstdaysLow = data.low[0];
        let seconddaysOpen = data.open[1];
        let seconddaysClose = data.close[1];
        let seconddaysHigh = data.high[1];
        let seconddaysLow = data.low[1];
        let thirddaysOpen = data.open[2];
        let thirddaysClose = data.close[2];
        let thirddaysHigh = data.high[2];
        let thirddaysLow = data.low[2];
        let isFirstBearish = firstdaysClose < firstdaysOpen;
        let isSecondBearish = seconddaysClose < seconddaysOpen;
        let isThirdBullish = thirddaysClose > thirddaysOpen;
        let isFirstGapExists = seconddaysHigh < firstdaysLow;
        let isDownsideTasukiGap = seconddaysOpen > thirddaysOpen && seconddaysClose < thirddaysOpen && thirddaysClose > seconddaysOpen && thirddaysClose < firstdaysClose;
        return isFirstBearish && isSecondBearish && isThirdBullish && isFirstGapExists && isDownsideTasukiGap;
      }
    };
    function downsidetasukigap(data) {
      return new DownsideTasukiGap().hasPattern(data);
    }
    var BullishMarubozu = class extends CandlestickFinder {
      constructor() {
        super();
        this.name = "BullishMarubozu";
        this.requiredCount = 1;
      }
      logic(data) {
        let daysOpen = data.open[0];
        let daysClose = data.close[0];
        let daysHigh = data.high[0];
        let daysLow = data.low[0];
        let isBullishMarbozu = this.approximateEqual(daysClose, daysHigh) && this.approximateEqual(daysLow, daysOpen) && daysOpen < daysClose && daysOpen < daysHigh;
        return isBullishMarbozu;
      }
    };
    function bullishmarubozu(data) {
      return new BullishMarubozu().hasPattern(data);
    }
    var PiercingLine = class extends CandlestickFinder {
      constructor() {
        super();
        this.requiredCount = 2;
        this.name = "PiercingLine";
      }
      logic(data) {
        let firstdaysOpen = data.open[0];
        let firstdaysClose = data.close[0];
        let firstdaysHigh = data.high[0];
        let firstdaysLow = data.low[0];
        let seconddaysOpen = data.open[1];
        let seconddaysClose = data.close[1];
        let seconddaysHigh = data.high[1];
        let seconddaysLow = data.low[1];
        let firstdaysMidpoint = (firstdaysOpen + firstdaysClose) / 2;
        let isDowntrend = seconddaysLow < firstdaysLow;
        let isFirstBearish = firstdaysClose < firstdaysOpen;
        let isSecondBullish = seconddaysClose > seconddaysOpen;
        let isPiercingLinePattern = firstdaysLow > seconddaysOpen && seconddaysClose > firstdaysMidpoint;
        return isDowntrend && isFirstBearish && isPiercingLinePattern && isSecondBullish;
      }
    };
    function piercingline(data) {
      return new PiercingLine().hasPattern(data);
    }
    var ThreeWhiteSoldiers = class extends CandlestickFinder {
      constructor() {
        super();
        this.name = "ThreeWhiteSoldiers";
        this.requiredCount = 3;
      }
      logic(data) {
        let firstdaysOpen = data.open[0];
        let firstdaysClose = data.close[0];
        let firstdaysHigh = data.high[0];
        let firstdaysLow = data.low[0];
        let seconddaysOpen = data.open[1];
        let seconddaysClose = data.close[1];
        let seconddaysHigh = data.high[1];
        let seconddaysLow = data.low[1];
        let thirddaysOpen = data.open[2];
        let thirddaysClose = data.close[2];
        let thirddaysHigh = data.high[2];
        let thirddaysLow = data.low[2];
        let isUpTrend = seconddaysHigh > firstdaysHigh && thirddaysHigh > seconddaysHigh;
        let isAllBullish = firstdaysOpen < firstdaysClose && seconddaysOpen < seconddaysClose && thirddaysOpen < thirddaysClose;
        let doesOpenWithinPreviousBody = firstdaysClose > seconddaysOpen && seconddaysOpen < firstdaysHigh && seconddaysHigh > thirddaysOpen && thirddaysOpen < seconddaysClose;
        return isUpTrend && isAllBullish && doesOpenWithinPreviousBody;
      }
    };
    function threewhitesoldiers(data) {
      return new ThreeWhiteSoldiers().hasPattern(data);
    }
    var BullishHammerStick = class extends CandlestickFinder {
      constructor() {
        super();
        this.name = "BullishHammerStick";
        this.requiredCount = 1;
      }
      logic(data) {
        let daysOpen = data.open[0];
        let daysClose = data.close[0];
        let daysHigh = data.high[0];
        let daysLow = data.low[0];
        let isBullishHammer = daysClose > daysOpen;
        isBullishHammer = isBullishHammer && this.approximateEqual(daysClose, daysHigh);
        isBullishHammer = isBullishHammer && daysClose - daysOpen <= 2 * (daysOpen - daysLow);
        return isBullishHammer;
      }
    };
    function bullishhammerstick(data) {
      return new BullishHammerStick().hasPattern(data);
    }
    var BullishInvertedHammerStick = class extends CandlestickFinder {
      constructor() {
        super();
        this.name = "BullishInvertedHammerStick";
        this.requiredCount = 1;
      }
      logic(data) {
        let daysOpen = data.open[0];
        let daysClose = data.close[0];
        let daysHigh = data.high[0];
        let daysLow = data.low[0];
        let isBullishInvertedHammer = daysClose > daysOpen;
        isBullishInvertedHammer = isBullishInvertedHammer && this.approximateEqual(daysOpen, daysLow);
        isBullishInvertedHammer = isBullishInvertedHammer && daysClose - daysOpen <= 2 * (daysHigh - daysClose);
        return isBullishInvertedHammer;
      }
    };
    function bullishinvertedhammerstick(data) {
      return new BullishInvertedHammerStick().hasPattern(data);
    }
    var BearishHammerStick = class extends CandlestickFinder {
      constructor() {
        super();
        this.name = "BearishHammerStick";
        this.requiredCount = 1;
      }
      logic(data) {
        let daysOpen = data.open[0];
        let daysClose = data.close[0];
        let daysHigh = data.high[0];
        let daysLow = data.low[0];
        let isBearishHammer = daysOpen > daysClose;
        isBearishHammer = isBearishHammer && this.approximateEqual(daysOpen, daysHigh);
        isBearishHammer = isBearishHammer && daysOpen - daysClose <= 2 * (daysClose - daysLow);
        return isBearishHammer;
      }
    };
    function bearishhammerstick(data) {
      return new BearishHammerStick().hasPattern(data);
    }
    var BearishInvertedHammerStick = class extends CandlestickFinder {
      constructor() {
        super();
        this.name = "BearishInvertedHammerStick";
        this.requiredCount = 1;
      }
      logic(data) {
        let daysOpen = data.open[0];
        let daysClose = data.close[0];
        let daysHigh = data.high[0];
        let daysLow = data.low[0];
        let isBearishInvertedHammer = daysOpen > daysClose;
        isBearishInvertedHammer = isBearishInvertedHammer && this.approximateEqual(daysClose, daysLow);
        isBearishInvertedHammer = isBearishInvertedHammer && daysOpen - daysClose <= 2 * (daysHigh - daysOpen);
        return isBearishInvertedHammer;
      }
    };
    function bearishinvertedhammerstick(data) {
      return new BearishInvertedHammerStick().hasPattern(data);
    }
    var HammerPattern = class extends CandlestickFinder {
      constructor() {
        super();
        this.name = "HammerPattern";
        this.requiredCount = 5;
      }
      logic(data) {
        let isPattern = this.downwardTrend(data);
        isPattern = isPattern && this.includesHammer(data);
        isPattern = isPattern && this.hasConfirmation(data);
        return isPattern;
      }
      downwardTrend(data, confirm = true) {
        let end = confirm ? 3 : 4;
        let gains = averagegain({ values: data.close.slice(0, end), period: end - 1 });
        let losses = averageloss({ values: data.close.slice(0, end), period: end - 1 });
        return losses > gains;
      }
      includesHammer(data, confirm = true) {
        let start = confirm ? 3 : 4;
        let end = confirm ? 4 : void 0;
        let possibleHammerData = {
          open: data.open.slice(start, end),
          close: data.close.slice(start, end),
          low: data.low.slice(start, end),
          high: data.high.slice(start, end)
        };
        let isPattern = bearishhammerstick(possibleHammerData);
        isPattern = isPattern || bearishinvertedhammerstick(possibleHammerData);
        isPattern = isPattern || bullishhammerstick(possibleHammerData);
        isPattern = isPattern || bullishinvertedhammerstick(possibleHammerData);
        return isPattern;
      }
      hasConfirmation(data) {
        let possibleHammer = {
          open: data.open[3],
          close: data.close[3],
          low: data.low[3],
          high: data.high[3]
        };
        let possibleConfirmation = {
          open: data.open[4],
          close: data.close[4],
          low: data.low[4],
          high: data.high[4]
        };
        let isPattern = possibleConfirmation.open < possibleConfirmation.close;
        return isPattern && possibleHammer.close < possibleConfirmation.close;
      }
    };
    function hammerpattern(data) {
      return new HammerPattern().hasPattern(data);
    }
    var HammerPatternUnconfirmed = class extends HammerPattern {
      constructor() {
        super();
        this.name = "HammerPatternUnconfirmed";
      }
      logic(data) {
        let isPattern = this.downwardTrend(data, false);
        isPattern = isPattern && this.includesHammer(data, false);
        return isPattern;
      }
    };
    function hammerpatternunconfirmed(data) {
      return new HammerPatternUnconfirmed().hasPattern(data);
    }
    var TweezerBottom = class extends CandlestickFinder {
      constructor() {
        super();
        this.name = "TweezerBottom";
        this.requiredCount = 5;
      }
      logic(data) {
        return this.downwardTrend(data) && data.low[3] == data.low[4];
      }
      downwardTrend(data) {
        let gains = averagegain({ values: data.close.slice(0, 3), period: 2 });
        let losses = averageloss({ values: data.close.slice(0, 3), period: 2 });
        return losses > gains;
      }
    };
    function tweezerbottom(data) {
      return new TweezerBottom().hasPattern(data);
    }
    var bullishPatterns = [
      new BullishEngulfingPattern(),
      new DownsideTasukiGap(),
      new BullishHarami(),
      new BullishHaramiCross(),
      new MorningDojiStar(),
      new MorningStar(),
      new BullishMarubozu(),
      new PiercingLine(),
      new ThreeWhiteSoldiers(),
      new BullishHammerStick(),
      new BullishInvertedHammerStick(),
      new HammerPattern(),
      new HammerPatternUnconfirmed(),
      new TweezerBottom()
    ];
    var BullishPatterns = class extends CandlestickFinder {
      constructor() {
        super();
        this.name = "Bullish Candlesticks";
      }
      hasPattern(data) {
        return bullishPatterns.reduce(function(state, pattern) {
          let result = pattern.hasPattern(data);
          return state || result;
        }, false);
      }
    };
    function bullish(data) {
      return new BullishPatterns().hasPattern(data);
    }
    var BearishEngulfingPattern = class extends CandlestickFinder {
      constructor() {
        super();
        this.name = "BearishEngulfingPattern";
        this.requiredCount = 2;
      }
      logic(data) {
        let firstdaysOpen = data.open[0];
        let firstdaysClose = data.close[0];
        let firstdaysHigh = data.high[0];
        let firstdaysLow = data.low[0];
        let seconddaysOpen = data.open[1];
        let seconddaysClose = data.close[1];
        let seconddaysHigh = data.high[1];
        let seconddaysLow = data.low[1];
        let isBearishEngulfing = firstdaysClose > firstdaysOpen && firstdaysOpen < seconddaysOpen && firstdaysClose < seconddaysOpen && firstdaysOpen > seconddaysClose;
        return isBearishEngulfing;
      }
    };
    function bearishengulfingpattern(data) {
      return new BearishEngulfingPattern().hasPattern(data);
    }
    var BearishHarami = class extends CandlestickFinder {
      constructor() {
        super();
        this.requiredCount = 2;
        this.name = "BearishHarami";
      }
      logic(data) {
        let firstdaysOpen = data.open[0];
        let firstdaysClose = data.close[0];
        let firstdaysHigh = data.high[0];
        let firstdaysLow = data.low[0];
        let seconddaysOpen = data.open[1];
        let seconddaysClose = data.close[1];
        let seconddaysHigh = data.high[1];
        let seconddaysLow = data.low[1];
        let isBearishHaramiPattern = firstdaysOpen < seconddaysOpen && firstdaysClose > seconddaysOpen && firstdaysClose > seconddaysClose && firstdaysOpen < seconddaysLow && firstdaysHigh > seconddaysHigh;
        return isBearishHaramiPattern;
      }
    };
    function bearishharami(data) {
      return new BearishHarami().hasPattern(data);
    }
    var BearishHaramiCross = class extends CandlestickFinder {
      constructor() {
        super();
        this.requiredCount = 2;
        this.name = "BearishHaramiCross";
      }
      logic(data) {
        let firstdaysOpen = data.open[0];
        let firstdaysClose = data.close[0];
        let firstdaysHigh = data.high[0];
        let firstdaysLow = data.low[0];
        let seconddaysOpen = data.open[1];
        let seconddaysClose = data.close[1];
        let seconddaysHigh = data.high[1];
        let seconddaysLow = data.low[1];
        let isBearishHaramiCrossPattern = firstdaysOpen < seconddaysOpen && firstdaysClose > seconddaysOpen && firstdaysClose > seconddaysClose && firstdaysOpen < seconddaysLow && firstdaysHigh > seconddaysHigh;
        let isSecondDayDoji = this.approximateEqual(seconddaysOpen, seconddaysClose);
        return isBearishHaramiCrossPattern && isSecondDayDoji;
      }
    };
    function bearishharamicross(data) {
      return new BearishHaramiCross().hasPattern(data);
    }
    var EveningDojiStar = class extends CandlestickFinder {
      constructor() {
        super();
        this.name = "EveningDojiStar";
        this.requiredCount = 3;
      }
      logic(data) {
        let firstdaysOpen = data.open[0];
        let firstdaysClose = data.close[0];
        let firstdaysHigh = data.high[0];
        let firstdaysLow = data.low[0];
        let seconddaysOpen = data.open[1];
        let seconddaysClose = data.close[1];
        let seconddaysHigh = data.high[1];
        let seconddaysLow = data.low[1];
        let thirddaysOpen = data.open[2];
        let thirddaysClose = data.close[2];
        let thirddaysHigh = data.high[2];
        let thirddaysLow = data.low[2];
        let firstdaysMidpoint = (firstdaysOpen + firstdaysClose) / 2;
        let isFirstBullish = firstdaysClose > firstdaysOpen;
        let dojiExists = new Doji().hasPattern({
          "open": [seconddaysOpen],
          "close": [seconddaysClose],
          "high": [seconddaysHigh],
          "low": [seconddaysLow]
        });
        let isThirdBearish = thirddaysOpen > thirddaysClose;
        let gapExists = seconddaysHigh > firstdaysHigh && seconddaysLow > firstdaysHigh && thirddaysOpen < seconddaysLow && seconddaysClose > thirddaysOpen;
        let doesCloseBelowFirstMidpoint = thirddaysClose < firstdaysMidpoint;
        return isFirstBullish && dojiExists && gapExists && isThirdBearish && doesCloseBelowFirstMidpoint;
      }
    };
    function eveningdojistar(data) {
      return new EveningDojiStar().hasPattern(data);
    }
    var EveningStar = class extends CandlestickFinder {
      constructor() {
        super();
        this.name = "EveningStar";
        this.requiredCount = 3;
      }
      logic(data) {
        let firstdaysOpen = data.open[0];
        let firstdaysClose = data.close[0];
        let firstdaysHigh = data.high[0];
        let firstdaysLow = data.low[0];
        let seconddaysOpen = data.open[1];
        let seconddaysClose = data.close[1];
        let seconddaysHigh = data.high[1];
        let seconddaysLow = data.low[1];
        let thirddaysOpen = data.open[2];
        let thirddaysClose = data.close[2];
        let thirddaysHigh = data.high[2];
        let thirddaysLow = data.low[2];
        let firstdaysMidpoint = (firstdaysOpen + firstdaysClose) / 2;
        let isFirstBullish = firstdaysClose > firstdaysOpen;
        let isSmallBodyExists = firstdaysHigh < seconddaysLow && firstdaysHigh < seconddaysHigh;
        let isThirdBearish = thirddaysOpen > thirddaysClose;
        let gapExists = seconddaysHigh > firstdaysHigh && seconddaysLow > firstdaysHigh && thirddaysOpen < seconddaysLow && seconddaysClose > thirddaysOpen;
        let doesCloseBelowFirstMidpoint = thirddaysClose < firstdaysMidpoint;
        return isFirstBullish && isSmallBodyExists && gapExists && isThirdBearish && doesCloseBelowFirstMidpoint;
      }
    };
    function eveningstar(data) {
      return new EveningStar().hasPattern(data);
    }
    var BearishMarubozu = class extends CandlestickFinder {
      constructor() {
        super();
        this.name = "BearishMarubozu";
        this.requiredCount = 1;
      }
      logic(data) {
        let daysOpen = data.open[0];
        let daysClose = data.close[0];
        let daysHigh = data.high[0];
        let daysLow = data.low[0];
        let isBearishMarbozu = this.approximateEqual(daysOpen, daysHigh) && this.approximateEqual(daysLow, daysClose) && daysOpen > daysClose && daysOpen > daysLow;
        return isBearishMarbozu;
      }
    };
    function bearishmarubozu(data) {
      return new BearishMarubozu().hasPattern(data);
    }
    var ThreeBlackCrows = class extends CandlestickFinder {
      constructor() {
        super();
        this.name = "ThreeBlackCrows";
        this.requiredCount = 3;
      }
      logic(data) {
        let firstdaysOpen = data.open[0];
        let firstdaysClose = data.close[0];
        let firstdaysHigh = data.high[0];
        let firstdaysLow = data.low[0];
        let seconddaysOpen = data.open[1];
        let seconddaysClose = data.close[1];
        let seconddaysHigh = data.high[1];
        let seconddaysLow = data.low[1];
        let thirddaysOpen = data.open[2];
        let thirddaysClose = data.close[2];
        let thirddaysHigh = data.high[2];
        let thirddaysLow = data.low[2];
        let isDownTrend = firstdaysLow > seconddaysLow && seconddaysLow > thirddaysLow;
        let isAllBearish = firstdaysOpen > firstdaysClose && seconddaysOpen > seconddaysClose && thirddaysOpen > thirddaysClose;
        let doesOpenWithinPreviousBody = firstdaysOpen > seconddaysOpen && seconddaysOpen > firstdaysClose && seconddaysOpen > thirddaysOpen && thirddaysOpen > seconddaysClose;
        return isDownTrend && isAllBearish && doesOpenWithinPreviousBody;
      }
    };
    function threeblackcrows(data) {
      return new ThreeBlackCrows().hasPattern(data);
    }
    var HangingMan = class extends CandlestickFinder {
      constructor() {
        super();
        this.name = "HangingMan";
        this.requiredCount = 5;
      }
      logic(data) {
        let isPattern = this.upwardTrend(data);
        isPattern = isPattern && this.includesHammer(data);
        isPattern = isPattern && this.hasConfirmation(data);
        return isPattern;
      }
      upwardTrend(data, confirm = true) {
        let end = confirm ? 3 : 4;
        let gains = averagegain({ values: data.close.slice(0, end), period: end - 1 });
        let losses = averageloss({ values: data.close.slice(0, end), period: end - 1 });
        return gains > losses;
      }
      includesHammer(data, confirm = true) {
        let start = confirm ? 3 : 4;
        let end = confirm ? 4 : void 0;
        let possibleHammerData = {
          open: data.open.slice(start, end),
          close: data.close.slice(start, end),
          low: data.low.slice(start, end),
          high: data.high.slice(start, end)
        };
        let isPattern = bearishhammerstick(possibleHammerData);
        isPattern = isPattern || bullishhammerstick(possibleHammerData);
        return isPattern;
      }
      hasConfirmation(data) {
        let possibleHammer = {
          open: data.open[3],
          close: data.close[3],
          low: data.low[3],
          high: data.high[3]
        };
        let possibleConfirmation = {
          open: data.open[4],
          close: data.close[4],
          low: data.low[4],
          high: data.high[4]
        };
        let isPattern = possibleConfirmation.open > possibleConfirmation.close;
        return isPattern && possibleHammer.close > possibleConfirmation.close;
      }
    };
    function hangingman(data) {
      return new HangingMan().hasPattern(data);
    }
    var HangingManUnconfirmed = class extends HangingMan {
      constructor() {
        super();
        this.name = "HangingManUnconfirmed";
      }
      logic(data) {
        let isPattern = this.upwardTrend(data, false);
        isPattern = isPattern && this.includesHammer(data, false);
        return isPattern;
      }
    };
    function hangingmanunconfirmed(data) {
      return new HangingManUnconfirmed().hasPattern(data);
    }
    var ShootingStar = class extends CandlestickFinder {
      constructor() {
        super();
        this.name = "ShootingStar";
        this.requiredCount = 5;
      }
      logic(data) {
        let isPattern = this.upwardTrend(data);
        isPattern = isPattern && this.includesHammer(data);
        isPattern = isPattern && this.hasConfirmation(data);
        return isPattern;
      }
      upwardTrend(data, confirm = true) {
        let end = confirm ? 3 : 4;
        let gains = averagegain({ values: data.close.slice(0, end), period: end - 1 });
        let losses = averageloss({ values: data.close.slice(0, end), period: end - 1 });
        return gains > losses;
      }
      includesHammer(data, confirm = true) {
        let start = confirm ? 3 : 4;
        let end = confirm ? 4 : void 0;
        let possibleHammerData = {
          open: data.open.slice(start, end),
          close: data.close.slice(start, end),
          low: data.low.slice(start, end),
          high: data.high.slice(start, end)
        };
        let isPattern = bearishinvertedhammerstick(possibleHammerData);
        isPattern = isPattern || bullishinvertedhammerstick(possibleHammerData);
        return isPattern;
      }
      hasConfirmation(data) {
        let possibleHammer = {
          open: data.open[3],
          close: data.close[3],
          low: data.low[3],
          high: data.high[3]
        };
        let possibleConfirmation = {
          open: data.open[4],
          close: data.close[4],
          low: data.low[4],
          high: data.high[4]
        };
        let isPattern = possibleConfirmation.open > possibleConfirmation.close;
        return isPattern && possibleHammer.close > possibleConfirmation.close;
      }
    };
    function shootingstar(data) {
      return new ShootingStar().hasPattern(data);
    }
    var ShootingStarUnconfirmed = class extends ShootingStar {
      constructor() {
        super();
        this.name = "ShootingStarUnconfirmed";
      }
      logic(data) {
        let isPattern = this.upwardTrend(data, false);
        isPattern = isPattern && this.includesHammer(data, false);
        return isPattern;
      }
    };
    function shootingstarunconfirmed(data) {
      return new ShootingStarUnconfirmed().hasPattern(data);
    }
    var TweezerTop = class extends CandlestickFinder {
      constructor() {
        super();
        this.name = "TweezerTop";
        this.requiredCount = 5;
      }
      logic(data) {
        return this.upwardTrend(data) && data.high[3] == data.high[4];
      }
      upwardTrend(data) {
        let gains = averagegain({ values: data.close.slice(0, 3), period: 2 });
        let losses = averageloss({ values: data.close.slice(0, 3), period: 2 });
        return gains > losses;
      }
    };
    function tweezertop(data) {
      return new TweezerTop().hasPattern(data);
    }
    var bearishPatterns = [
      new BearishEngulfingPattern(),
      new BearishHarami(),
      new BearishHaramiCross(),
      new EveningDojiStar(),
      new EveningStar(),
      new BearishMarubozu(),
      new ThreeBlackCrows(),
      new BearishHammerStick(),
      new BearishInvertedHammerStick(),
      new HangingMan(),
      new HangingManUnconfirmed(),
      new ShootingStar(),
      new ShootingStarUnconfirmed(),
      new TweezerTop()
    ];
    var BearishPatterns = class extends CandlestickFinder {
      constructor() {
        super();
        this.name = "Bearish Candlesticks";
      }
      hasPattern(data) {
        return bearishPatterns.reduce(function(state, pattern) {
          return state || pattern.hasPattern(data);
        }, false);
      }
    };
    function bearish(data) {
      return new BearishPatterns().hasPattern(data);
    }
    var AbandonedBaby = class extends CandlestickFinder {
      constructor() {
        super();
        this.name = "AbandonedBaby";
        this.requiredCount = 3;
      }
      logic(data) {
        let firstdaysOpen = data.open[0];
        let firstdaysClose = data.close[0];
        let firstdaysHigh = data.high[0];
        let firstdaysLow = data.low[0];
        let seconddaysOpen = data.open[1];
        let seconddaysClose = data.close[1];
        let seconddaysHigh = data.high[1];
        let seconddaysLow = data.low[1];
        let thirddaysOpen = data.open[2];
        let thirddaysClose = data.close[2];
        let thirddaysHigh = data.high[2];
        let thirddaysLow = data.low[2];
        let isFirstBearish = firstdaysClose < firstdaysOpen;
        let dojiExists = new Doji().hasPattern({
          "open": [seconddaysOpen],
          "close": [seconddaysClose],
          "high": [seconddaysHigh],
          "low": [seconddaysLow]
        });
        let gapExists = seconddaysHigh < firstdaysLow && thirddaysLow > seconddaysHigh && thirddaysClose > thirddaysOpen;
        let isThirdBullish = thirddaysHigh < firstdaysOpen;
        return isFirstBearish && dojiExists && gapExists && isThirdBullish;
      }
    };
    function abandonedbaby(data) {
      return new AbandonedBaby().hasPattern(data);
    }
    var DarkCloudCover = class extends CandlestickFinder {
      constructor() {
        super();
        this.name = "DarkCloudCover";
        this.requiredCount = 2;
      }
      logic(data) {
        let firstdaysOpen = data.open[0];
        let firstdaysClose = data.close[0];
        let firstdaysHigh = data.high[0];
        let firstdaysLow = data.low[0];
        let seconddaysOpen = data.open[1];
        let seconddaysClose = data.close[1];
        let seconddaysHigh = data.high[1];
        let seconddaysLow = data.low[1];
        let firstdayMidpoint = (firstdaysClose + firstdaysOpen) / 2;
        let isFirstBullish = firstdaysClose > firstdaysOpen;
        let isSecondBearish = seconddaysClose < seconddaysOpen;
        let isDarkCloudPattern = seconddaysOpen > firstdaysHigh && seconddaysClose < firstdayMidpoint && seconddaysClose > firstdaysOpen;
        return isFirstBullish && isSecondBearish && isDarkCloudPattern;
      }
    };
    function darkcloudcover(data) {
      return new DarkCloudCover().hasPattern(data);
    }
    var DragonFlyDoji = class extends CandlestickFinder {
      constructor() {
        super();
        this.requiredCount = 1;
        this.name = "DragonFlyDoji";
      }
      logic(data) {
        let daysOpen = data.open[0];
        let daysClose = data.close[0];
        let daysHigh = data.high[0];
        let daysLow = data.low[0];
        let isOpenEqualsClose = this.approximateEqual(daysOpen, daysClose);
        let isHighEqualsOpen = isOpenEqualsClose && this.approximateEqual(daysOpen, daysHigh);
        let isLowEqualsClose = isOpenEqualsClose && this.approximateEqual(daysClose, daysLow);
        return isOpenEqualsClose && isHighEqualsOpen && !isLowEqualsClose;
      }
    };
    function dragonflydoji(data) {
      return new DragonFlyDoji().hasPattern(data);
    }
    var GraveStoneDoji = class extends CandlestickFinder {
      constructor() {
        super();
        this.requiredCount = 1;
        this.name = "GraveStoneDoji";
      }
      logic(data) {
        let daysOpen = data.open[0];
        let daysClose = data.close[0];
        let daysHigh = data.high[0];
        let daysLow = data.low[0];
        let isOpenEqualsClose = this.approximateEqual(daysOpen, daysClose);
        let isHighEqualsOpen = isOpenEqualsClose && this.approximateEqual(daysOpen, daysHigh);
        let isLowEqualsClose = isOpenEqualsClose && this.approximateEqual(daysClose, daysLow);
        return isOpenEqualsClose && isLowEqualsClose && !isHighEqualsOpen;
      }
    };
    function gravestonedoji(data) {
      return new GraveStoneDoji().hasPattern(data);
    }
    var BullishSpinningTop = class extends CandlestickFinder {
      constructor() {
        super();
        this.name = "BullishSpinningTop";
        this.requiredCount = 1;
      }
      logic(data) {
        let daysOpen = data.open[0];
        let daysClose = data.close[0];
        let daysHigh = data.high[0];
        let daysLow = data.low[0];
        let bodyLength = Math.abs(daysClose - daysOpen);
        let upperShadowLength = Math.abs(daysHigh - daysClose);
        let lowerShadowLength = Math.abs(daysOpen - daysLow);
        let isBullishSpinningTop = bodyLength < upperShadowLength && bodyLength < lowerShadowLength;
        return isBullishSpinningTop;
      }
    };
    function bullishspinningtop(data) {
      return new BullishSpinningTop().hasPattern(data);
    }
    var BearishSpinningTop = class extends CandlestickFinder {
      constructor() {
        super();
        this.name = "BearishSpinningTop";
        this.requiredCount = 1;
      }
      logic(data) {
        let daysOpen = data.open[0];
        let daysClose = data.close[0];
        let daysHigh = data.high[0];
        let daysLow = data.low[0];
        let bodyLength = Math.abs(daysClose - daysOpen);
        let upperShadowLength = Math.abs(daysHigh - daysOpen);
        let lowerShadowLength = Math.abs(daysHigh - daysLow);
        let isBearishSpinningTop = bodyLength < upperShadowLength && bodyLength < lowerShadowLength;
        return isBearishSpinningTop;
      }
    };
    function bearishspinningtop(data) {
      return new BearishSpinningTop().hasPattern(data);
    }
    function fibonacciretracement(start, end) {
      let levels = [0, 23.6, 38.2, 50, 61.8, 78.6, 100, 127.2, 161.8, 261.8, 423.6];
      let retracements;
      if (start < end) {
        retracements = levels.map(function(level) {
          let calculated = end - Math.abs(start - end) * level / 100;
          return calculated > 0 ? calculated : 0;
        });
      } else {
        retracements = levels.map(function(level) {
          let calculated = end + Math.abs(start - end) * level / 100;
          return calculated > 0 ? calculated : 0;
        });
      }
      return retracements;
    }
    var IchimokuCloud = class extends Indicator {
      constructor(input) {
        super(input);
        this.result = [];
        var defaults = {
          conversionPeriod: 9,
          basePeriod: 26,
          spanPeriod: 52,
          displacement: 26
        };
        var params = Object.assign({}, defaults, input);
        var currentConversionData = new FixedSizeLinkedList(params.conversionPeriod * 2, true, true, false);
        var currentBaseData = new FixedSizeLinkedList(params.basePeriod * 2, true, true, false);
        var currenSpanData = new FixedSizeLinkedList(params.spanPeriod * 2, true, true, false);
        this.generator = function* () {
          let result;
          let tick;
          let period = Math.max(params.conversionPeriod, params.basePeriod, params.spanPeriod, params.displacement);
          let periodCounter = 1;
          tick = yield;
          while (true) {
            currentConversionData.push(tick.high);
            currentConversionData.push(tick.low);
            currentBaseData.push(tick.high);
            currentBaseData.push(tick.low);
            currenSpanData.push(tick.high);
            currenSpanData.push(tick.low);
            if (periodCounter < period) {
              periodCounter++;
            } else {
              let conversionLine = (currentConversionData.periodHigh + currentConversionData.periodLow) / 2;
              let baseLine = (currentBaseData.periodHigh + currentBaseData.periodLow) / 2;
              let spanA = (conversionLine + baseLine) / 2;
              let spanB = (currenSpanData.periodHigh + currenSpanData.periodLow) / 2;
              result = {
                conversion: conversionLine,
                base: baseLine,
                spanA,
                spanB
              };
            }
            tick = yield result;
          }
        }();
        this.generator.next();
        input.low.forEach((tick, index) => {
          var result = this.generator.next({
            high: input.high[index],
            low: input.low[index]
          });
          if (result.value) {
            this.result.push(result.value);
          }
        });
      }
      nextValue(price) {
        return this.generator.next(price).value;
      }
    };
    IchimokuCloud.calculate = ichimokucloud;
    function ichimokucloud(input) {
      Indicator.reverseInputs(input);
      var result = new IchimokuCloud(input).result;
      if (input.reversedInput) {
        result.reverse();
      }
      Indicator.reverseInputs(input);
      return result;
    }
    var KeltnerChannelsInput = class extends IndicatorInput {
      constructor() {
        super(...arguments);
        this.maPeriod = 20;
        this.atrPeriod = 10;
        this.useSMA = false;
        this.multiplier = 1;
      }
    };
    var KeltnerChannelsOutput = class extends IndicatorInput {
    };
    var KeltnerChannels = class extends Indicator {
      constructor(input) {
        super(input);
        var maType = input.useSMA ? SMA : EMA;
        var maProducer = new maType({ period: input.maPeriod, values: [], format: (v) => {
          return v;
        } });
        var atrProducer = new ATR({ period: input.atrPeriod, high: [], low: [], close: [], format: (v) => {
          return v;
        } });
        var tick;
        this.result = [];
        this.generator = function* () {
          var KeltnerChannelsOutput2;
          var result;
          tick = yield;
          while (true) {
            var { close } = tick;
            var ma = maProducer.nextValue(close);
            var atr$$1 = atrProducer.nextValue(tick);
            if (ma != void 0 && atr$$1 != void 0) {
              result = {
                middle: ma,
                upper: ma + input.multiplier * atr$$1,
                lower: ma - input.multiplier * atr$$1
              };
            }
            tick = yield result;
          }
        }();
        this.generator.next();
        var highs = input.high;
        highs.forEach((tickHigh, index) => {
          var tickInput = {
            high: tickHigh,
            low: input.low[index],
            close: input.close[index]
          };
          var result = this.generator.next(tickInput);
          if (result.value != void 0) {
            this.result.push(result.value);
          }
        });
      }
      nextValue(price) {
        var result = this.generator.next(price);
        if (result.value != void 0) {
          return result.value;
        }
      }
    };
    KeltnerChannels.calculate = keltnerchannels;
    function keltnerchannels(input) {
      Indicator.reverseInputs(input);
      var result = new KeltnerChannels(input).result;
      if (input.reversedInput) {
        result.reverse();
      }
      Indicator.reverseInputs(input);
      return result;
    }
    var ChandelierExitInput = class extends IndicatorInput {
      constructor() {
        super(...arguments);
        this.period = 22;
        this.multiplier = 3;
      }
    };
    var ChandelierExitOutput = class extends IndicatorInput {
    };
    var ChandelierExit = class extends Indicator {
      constructor(input) {
        super(input);
        var highs = input.high;
        var lows = input.low;
        var closes = input.close;
        this.result = [];
        var atrProducer = new ATR({ period: input.period, high: [], low: [], close: [], format: (v) => {
          return v;
        } });
        var dataCollector = new FixedSizeLinkedList(input.period * 2, true, true, false);
        this.generator = function* () {
          var result;
          var tick = yield;
          var atr$$1;
          while (true) {
            var { high, low } = tick;
            dataCollector.push(high);
            dataCollector.push(low);
            atr$$1 = atrProducer.nextValue(tick);
            if (dataCollector.totalPushed >= 2 * input.period && atr$$1 != void 0) {
              result = {
                exitLong: dataCollector.periodHigh - atr$$1 * input.multiplier,
                exitShort: dataCollector.periodLow + atr$$1 * input.multiplier
              };
            }
            tick = yield result;
          }
        }();
        this.generator.next();
        highs.forEach((tickHigh, index) => {
          var tickInput = {
            high: tickHigh,
            low: lows[index],
            close: closes[index]
          };
          var result = this.generator.next(tickInput);
          if (result.value != void 0) {
            this.result.push(result.value);
          }
        });
      }
      nextValue(price) {
        var result = this.generator.next(price);
        if (result.value != void 0) {
          return result.value;
        }
      }
    };
    ChandelierExit.calculate = chandelierexit;
    function chandelierexit(input) {
      Indicator.reverseInputs(input);
      var result = new ChandelierExit(input).result;
      if (input.reversedInput) {
        result.reverse();
      }
      Indicator.reverseInputs(input);
      return result;
    }
    var CrossUp = class extends Indicator {
      constructor(input) {
        super(input);
        this.lineA = input.lineA;
        this.lineB = input.lineB;
        var currentLineA = [];
        var currentLineB = [];
        const genFn = function* () {
          var current = yield;
          var result = false;
          while (true) {
            currentLineA.unshift(current.valueA);
            currentLineB.unshift(current.valueB);
            result = current.valueA > current.valueB;
            var pointer = 1;
            while (result === true && currentLineA[pointer] >= currentLineB[pointer]) {
              if (currentLineA[pointer] > currentLineB[pointer]) {
                result = false;
              } else if (currentLineA[pointer] < currentLineB[pointer]) {
                result = true;
              } else if (currentLineA[pointer] === currentLineB[pointer]) {
                pointer += 1;
              }
            }
            if (result === true) {
              currentLineA = [current.valueA];
              currentLineB = [current.valueB];
            }
            current = yield result;
          }
        };
        this.generator = genFn();
        this.generator.next();
        this.result = [];
        this.lineA.forEach((value, index) => {
          var result = this.generator.next({
            valueA: this.lineA[index],
            valueB: this.lineB[index]
          });
          if (result.value !== void 0) {
            this.result.push(result.value);
          }
        });
      }
      static reverseInputs(input) {
        if (input.reversedInput) {
          input.lineA ? input.lineA.reverse() : void 0;
          input.lineB ? input.lineB.reverse() : void 0;
        }
      }
      nextValue(valueA, valueB) {
        return this.generator.next({
          valueA,
          valueB
        }).value;
      }
    };
    CrossUp.calculate = crossUp;
    function crossUp(input) {
      Indicator.reverseInputs(input);
      var result = new CrossUp(input).result;
      if (input.reversedInput) {
        result.reverse();
      }
      Indicator.reverseInputs(input);
      return result;
    }
    var CrossDown = class extends Indicator {
      constructor(input) {
        super(input);
        this.lineA = input.lineA;
        this.lineB = input.lineB;
        var currentLineA = [];
        var currentLineB = [];
        const genFn = function* () {
          var current = yield;
          var result = false;
          while (true) {
            currentLineA.unshift(current.valueA);
            currentLineB.unshift(current.valueB);
            result = current.valueA < current.valueB;
            var pointer = 1;
            while (result === true && currentLineA[pointer] <= currentLineB[pointer]) {
              if (currentLineA[pointer] < currentLineB[pointer]) {
                result = false;
              } else if (currentLineA[pointer] > currentLineB[pointer]) {
                result = true;
              } else if (currentLineA[pointer] === currentLineB[pointer]) {
                pointer += 1;
              }
            }
            if (result === true) {
              currentLineA = [current.valueA];
              currentLineB = [current.valueB];
            }
            current = yield result;
          }
        };
        this.generator = genFn();
        this.generator.next();
        this.result = [];
        this.lineA.forEach((value, index) => {
          var result = this.generator.next({
            valueA: this.lineA[index],
            valueB: this.lineB[index]
          });
          if (result.value !== void 0) {
            this.result.push(result.value);
          }
        });
      }
      static reverseInputs(input) {
        if (input.reversedInput) {
          input.lineA ? input.lineA.reverse() : void 0;
          input.lineB ? input.lineB.reverse() : void 0;
        }
      }
      nextValue(valueA, valueB) {
        return this.generator.next({
          valueA,
          valueB
        }).value;
      }
    };
    CrossDown.calculate = crossDown;
    function crossDown(input) {
      Indicator.reverseInputs(input);
      var result = new CrossDown(input).result;
      if (input.reversedInput) {
        result.reverse();
      }
      Indicator.reverseInputs(input);
      return result;
    }
    function getAvailableIndicators() {
      let AvailableIndicators2 = [];
      AvailableIndicators2.push("sma");
      AvailableIndicators2.push("ema");
      AvailableIndicators2.push("wma");
      AvailableIndicators2.push("wema");
      AvailableIndicators2.push("macd");
      AvailableIndicators2.push("rsi");
      AvailableIndicators2.push("bollingerbands");
      AvailableIndicators2.push("adx");
      AvailableIndicators2.push("atr");
      AvailableIndicators2.push("truerange");
      AvailableIndicators2.push("roc");
      AvailableIndicators2.push("kst");
      AvailableIndicators2.push("psar");
      AvailableIndicators2.push("stochastic");
      AvailableIndicators2.push("williamsr");
      AvailableIndicators2.push("adl");
      AvailableIndicators2.push("obv");
      AvailableIndicators2.push("trix");
      AvailableIndicators2.push("cci");
      AvailableIndicators2.push("awesomeoscillator");
      AvailableIndicators2.push("forceindex");
      AvailableIndicators2.push("vwap");
      AvailableIndicators2.push("volumeprofile");
      AvailableIndicators2.push("renko");
      AvailableIndicators2.push("heikinashi");
      AvailableIndicators2.push("stochasticrsi");
      AvailableIndicators2.push("mfi");
      AvailableIndicators2.push("averagegain");
      AvailableIndicators2.push("averageloss");
      AvailableIndicators2.push("highest");
      AvailableIndicators2.push("lowest");
      AvailableIndicators2.push("sum");
      AvailableIndicators2.push("FixedSizeLinkedList");
      AvailableIndicators2.push("sd");
      AvailableIndicators2.push("bullish");
      AvailableIndicators2.push("bearish");
      AvailableIndicators2.push("abandonedbaby");
      AvailableIndicators2.push("doji");
      AvailableIndicators2.push("bearishengulfingpattern");
      AvailableIndicators2.push("bullishengulfingpattern");
      AvailableIndicators2.push("darkcloudcover");
      AvailableIndicators2.push("downsidetasukigap");
      AvailableIndicators2.push("dragonflydoji");
      AvailableIndicators2.push("gravestonedoji");
      AvailableIndicators2.push("bullishharami");
      AvailableIndicators2.push("bearishharami");
      AvailableIndicators2.push("bullishharamicross");
      AvailableIndicators2.push("bearishharamicross");
      AvailableIndicators2.push("eveningdojistar");
      AvailableIndicators2.push("eveningstar");
      AvailableIndicators2.push("morningdojistar");
      AvailableIndicators2.push("morningstar");
      AvailableIndicators2.push("bullishmarubozu");
      AvailableIndicators2.push("bearishmarubozu");
      AvailableIndicators2.push("piercingline");
      AvailableIndicators2.push("bullishspinningtop");
      AvailableIndicators2.push("bearishspinningtop");
      AvailableIndicators2.push("threeblackcrows");
      AvailableIndicators2.push("threewhitesoldiers");
      AvailableIndicators2.push("bullishhammerstick");
      AvailableIndicators2.push("bearishhammerstick");
      AvailableIndicators2.push("bullishinvertedhammerstick");
      AvailableIndicators2.push("bearishinvertedhammerstick");
      AvailableIndicators2.push("hammerpattern");
      AvailableIndicators2.push("hammerpatternunconfirmed");
      AvailableIndicators2.push("hangingman");
      AvailableIndicators2.push("hangingmanunconfirmed");
      AvailableIndicators2.push("shootingstar");
      AvailableIndicators2.push("shootingstarunconfirmed");
      AvailableIndicators2.push("tweezertop");
      AvailableIndicators2.push("tweezerbottom");
      AvailableIndicators2.push("ichimokucloud");
      AvailableIndicators2.push("keltnerchannels");
      AvailableIndicators2.push("chandelierexit");
      AvailableIndicators2.push("crossup");
      AvailableIndicators2.push("crossdown");
      AvailableIndicators2.push("crossover");
      return AvailableIndicators2;
    }
    var AvailableIndicators = getAvailableIndicators();
    exports2.getAvailableIndicators = getAvailableIndicators;
    exports2.AvailableIndicators = AvailableIndicators;
    exports2.FixedSizeLinkedList = FixedSizeLinkedList;
    exports2.CandleData = CandleData;
    exports2.CandleList = CandleList;
    exports2.sma = sma;
    exports2.SMA = SMA;
    exports2.ema = ema;
    exports2.EMA = EMA;
    exports2.wma = wma;
    exports2.WMA = WMA;
    exports2.wema = wema;
    exports2.WEMA = WEMA;
    exports2.macd = macd;
    exports2.MACD = MACD;
    exports2.rsi = rsi;
    exports2.RSI = RSI;
    exports2.bollingerbands = bollingerbands;
    exports2.BollingerBands = BollingerBands;
    exports2.adx = adx;
    exports2.ADX = ADX;
    exports2.atr = atr;
    exports2.ATR = ATR;
    exports2.truerange = truerange;
    exports2.TrueRange = TrueRange;
    exports2.roc = roc;
    exports2.ROC = ROC;
    exports2.kst = kst;
    exports2.KST = KST;
    exports2.psar = psar;
    exports2.PSAR = PSAR;
    exports2.stochastic = stochastic;
    exports2.Stochastic = Stochastic;
    exports2.williamsr = williamsr;
    exports2.WilliamsR = WilliamsR;
    exports2.adl = adl;
    exports2.ADL = ADL;
    exports2.obv = obv;
    exports2.OBV = OBV;
    exports2.trix = trix;
    exports2.TRIX = TRIX;
    exports2.forceindex = forceindex;
    exports2.ForceIndex = ForceIndex;
    exports2.cci = cci;
    exports2.CCI = CCI;
    exports2.awesomeoscillator = awesomeoscillator;
    exports2.AwesomeOscillator = AwesomeOscillator;
    exports2.vwap = vwap;
    exports2.VWAP = VWAP;
    exports2.volumeprofile = volumeprofile;
    exports2.VolumeProfile = VolumeProfile;
    exports2.mfi = mfi;
    exports2.MFI = MFI;
    exports2.stochasticrsi = stochasticrsi;
    exports2.StochasticRSI = StochasticRSI;
    exports2.averagegain = averagegain;
    exports2.AverageGain = AverageGain;
    exports2.averageloss = averageloss;
    exports2.AverageLoss = AverageLoss;
    exports2.sd = sd;
    exports2.SD = SD;
    exports2.highest = highest;
    exports2.Highest = Highest;
    exports2.lowest = lowest;
    exports2.Lowest = Lowest;
    exports2.sum = sum;
    exports2.Sum = Sum;
    exports2.renko = renko;
    exports2.HeikinAshi = HeikinAshi;
    exports2.heikinashi = heikinashi;
    exports2.bullish = bullish;
    exports2.bearish = bearish;
    exports2.abandonedbaby = abandonedbaby;
    exports2.doji = doji;
    exports2.bearishengulfingpattern = bearishengulfingpattern;
    exports2.bullishengulfingpattern = bullishengulfingpattern;
    exports2.darkcloudcover = darkcloudcover;
    exports2.downsidetasukigap = downsidetasukigap;
    exports2.dragonflydoji = dragonflydoji;
    exports2.gravestonedoji = gravestonedoji;
    exports2.bullishharami = bullishharami;
    exports2.bearishharami = bearishharami;
    exports2.bullishharamicross = bullishharamicross;
    exports2.bearishharamicross = bearishharamicross;
    exports2.eveningdojistar = eveningdojistar;
    exports2.eveningstar = eveningstar;
    exports2.morningdojistar = morningdojistar;
    exports2.morningstar = morningstar;
    exports2.bullishmarubozu = bullishmarubozu;
    exports2.bearishmarubozu = bearishmarubozu;
    exports2.piercingline = piercingline;
    exports2.bullishspinningtop = bullishspinningtop;
    exports2.bearishspinningtop = bearishspinningtop;
    exports2.threeblackcrows = threeblackcrows;
    exports2.threewhitesoldiers = threewhitesoldiers;
    exports2.bullishhammerstick = bullishhammerstick;
    exports2.bearishhammerstick = bearishhammerstick;
    exports2.bullishinvertedhammerstick = bullishinvertedhammerstick;
    exports2.bearishinvertedhammerstick = bearishinvertedhammerstick;
    exports2.hammerpattern = hammerpattern;
    exports2.hammerpatternunconfirmed = hammerpatternunconfirmed;
    exports2.hangingman = hangingman;
    exports2.hangingmanunconfirmed = hangingmanunconfirmed;
    exports2.shootingstar = shootingstar;
    exports2.shootingstarunconfirmed = shootingstarunconfirmed;
    exports2.tweezertop = tweezertop;
    exports2.tweezerbottom = tweezerbottom;
    exports2.fibonacciretracement = fibonacciretracement;
    exports2.ichimokucloud = ichimokucloud;
    exports2.IchimokuCloud = IchimokuCloud;
    exports2.keltnerchannels = keltnerchannels;
    exports2.KeltnerChannels = KeltnerChannels;
    exports2.KeltnerChannelsInput = KeltnerChannelsInput;
    exports2.KeltnerChannelsOutput = KeltnerChannelsOutput;
    exports2.chandelierexit = chandelierexit;
    exports2.ChandelierExit = ChandelierExit;
    exports2.ChandelierExitInput = ChandelierExitInput;
    exports2.ChandelierExitOutput = ChandelierExitOutput;
    exports2.crossUp = crossUp;
    exports2.CrossUp = CrossUp;
    exports2.crossDown = crossDown;
    exports2.CrossDown = CrossDown;
    exports2.setConfig = setConfig;
    exports2.getConfig = getConfig;
  }
});

// node_modules/supertrend/build/supertrend.js
var require_supertrend = __commonJS({
  "node_modules/supertrend/build/supertrend.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.supertrend = void 0;
    var technicalindicators_1 = require_dist();
    function supertrend2({ initialArray, period = 10, multiplier = 3 }) {
      const v = {
        high: [],
        low: [],
        close: [],
        period
      };
      for (let i2 = 0; i2 < initialArray.length; i2++) {
        v.high.push(initialArray[i2].high);
        v.low.push(initialArray[i2].low);
        v.close.push(initialArray[i2].close);
      }
      const atr = technicalindicators_1.ATR.calculate(v);
      const r2 = [...initialArray];
      for (let i2 = 0; i2 < period; i2++) {
        r2.shift();
      }
      const basicUpperBand = [];
      const basicLowerBand = [];
      for (let i2 = 0; i2 < r2.length; i2++) {
        basicUpperBand.push((r2[i2].high + r2[i2].low) / 2 + multiplier * atr[i2]);
        basicLowerBand.push((r2[i2].high + r2[i2].low) / 2 - multiplier * atr[i2]);
      }
      const finalUpperBand = [];
      const finalLowerBand = [];
      let previousFinalUpperBand = 0;
      let previousFinalLowerBand = 0;
      for (let i2 = 0; i2 < r2.length; i2++) {
        if (basicUpperBand[i2] < previousFinalUpperBand || r2[i2 - 1] && r2[i2 - 1].close > previousFinalUpperBand) {
          finalUpperBand.push(basicUpperBand[i2]);
        } else {
          finalUpperBand.push(previousFinalUpperBand);
        }
        if (basicLowerBand[i2] > previousFinalLowerBand || r2[i2 - 1] && r2[i2 - 1].close < previousFinalLowerBand) {
          finalLowerBand.push(basicLowerBand[i2]);
        } else {
          finalLowerBand.push(previousFinalLowerBand);
        }
        previousFinalUpperBand = finalUpperBand[i2];
        previousFinalLowerBand = finalLowerBand[i2];
      }
      const superTrend = [];
      let previousSuperTrend = 0;
      for (let i2 = 0; i2 < r2.length; i2++) {
        let nowSuperTrend = 0;
        if (previousSuperTrend == finalUpperBand[i2 - 1] && r2[i2].close <= finalUpperBand[i2]) {
          nowSuperTrend = finalUpperBand[i2];
        } else if (previousSuperTrend == finalUpperBand[i2 - 1] && r2[i2].close > finalUpperBand[i2]) {
          nowSuperTrend = finalLowerBand[i2];
        } else if (previousSuperTrend == finalLowerBand[i2 - 1] && r2[i2].close >= finalLowerBand[i2]) {
          nowSuperTrend = finalLowerBand[i2];
        } else if (previousSuperTrend == finalLowerBand[i2 - 1] && r2[i2].close < finalLowerBand[i2]) {
          nowSuperTrend = finalUpperBand[i2];
        }
        superTrend.push(nowSuperTrend);
        previousSuperTrend = superTrend[i2];
      }
      return superTrend;
    }
    exports2.supertrend = supertrend2;
  }
});

// node_modules/supertrend/build/index.js
var require_build = __commonJS({
  "node_modules/supertrend/build/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m2, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m2, k);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m2, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m2[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m2, exports3) {
      for (var p in m2) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m2, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_supertrend(), exports2);
  }
});

// node_modules/web-streams-polyfill/dist/ponyfill.es2018.js
var require_ponyfill_es2018 = __commonJS({
  "node_modules/web-streams-polyfill/dist/ponyfill.es2018.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.WebStreamsPolyfill = {}));
    })(exports2, function(exports3) {
      "use strict";
      function noop2() {
        return void 0;
      }
      function typeIsObject(x2) {
        return typeof x2 === "object" && x2 !== null || typeof x2 === "function";
      }
      const rethrowAssertionErrorRejection = noop2;
      function setFunctionName(fn, name) {
        try {
          Object.defineProperty(fn, "name", {
            value: name,
            configurable: true
          });
        } catch (_a2) {
        }
      }
      const originalPromise = Promise;
      const originalPromiseThen = Promise.prototype.then;
      const originalPromiseReject = Promise.reject.bind(originalPromise);
      function newPromise(executor) {
        return new originalPromise(executor);
      }
      function promiseResolvedWith(value) {
        return newPromise((resolve) => resolve(value));
      }
      function promiseRejectedWith(reason) {
        return originalPromiseReject(reason);
      }
      function PerformPromiseThen(promise, onFulfilled, onRejected) {
        return originalPromiseThen.call(promise, onFulfilled, onRejected);
      }
      function uponPromise(promise, onFulfilled, onRejected) {
        PerformPromiseThen(PerformPromiseThen(promise, onFulfilled, onRejected), void 0, rethrowAssertionErrorRejection);
      }
      function uponFulfillment(promise, onFulfilled) {
        uponPromise(promise, onFulfilled);
      }
      function uponRejection(promise, onRejected) {
        uponPromise(promise, void 0, onRejected);
      }
      function transformPromiseWith(promise, fulfillmentHandler, rejectionHandler) {
        return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);
      }
      function setPromiseIsHandledToTrue(promise) {
        PerformPromiseThen(promise, void 0, rethrowAssertionErrorRejection);
      }
      let _queueMicrotask = (callback) => {
        if (typeof queueMicrotask === "function") {
          _queueMicrotask = queueMicrotask;
        } else {
          const resolvedPromise = promiseResolvedWith(void 0);
          _queueMicrotask = (cb) => PerformPromiseThen(resolvedPromise, cb);
        }
        return _queueMicrotask(callback);
      };
      function reflectCall(F2, V, args) {
        if (typeof F2 !== "function") {
          throw new TypeError("Argument is not a function");
        }
        return Function.prototype.apply.call(F2, V, args);
      }
      function promiseCall(F2, V, args) {
        try {
          return promiseResolvedWith(reflectCall(F2, V, args));
        } catch (value) {
          return promiseRejectedWith(value);
        }
      }
      const QUEUE_MAX_ARRAY_SIZE = 16384;
      class SimpleQueue {
        constructor() {
          this._cursor = 0;
          this._size = 0;
          this._front = {
            _elements: [],
            _next: void 0
          };
          this._back = this._front;
          this._cursor = 0;
          this._size = 0;
        }
        get length() {
          return this._size;
        }
        // For exception safety, this method is structured in order:
        // 1. Read state
        // 2. Calculate required state mutations
        // 3. Perform state mutations
        push(element) {
          const oldBack = this._back;
          let newBack = oldBack;
          if (oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1) {
            newBack = {
              _elements: [],
              _next: void 0
            };
          }
          oldBack._elements.push(element);
          if (newBack !== oldBack) {
            this._back = newBack;
            oldBack._next = newBack;
          }
          ++this._size;
        }
        // Like push(), shift() follows the read -> calculate -> mutate pattern for
        // exception safety.
        shift() {
          const oldFront = this._front;
          let newFront = oldFront;
          const oldCursor = this._cursor;
          let newCursor = oldCursor + 1;
          const elements = oldFront._elements;
          const element = elements[oldCursor];
          if (newCursor === QUEUE_MAX_ARRAY_SIZE) {
            newFront = oldFront._next;
            newCursor = 0;
          }
          --this._size;
          this._cursor = newCursor;
          if (oldFront !== newFront) {
            this._front = newFront;
          }
          elements[oldCursor] = void 0;
          return element;
        }
        // The tricky thing about forEach() is that it can be called
        // re-entrantly. The queue may be mutated inside the callback. It is easy to
        // see that push() within the callback has no negative effects since the end
        // of the queue is checked for on every iteration. If shift() is called
        // repeatedly within the callback then the next iteration may return an
        // element that has been removed. In this case the callback will be called
        // with undefined values until we either "catch up" with elements that still
        // exist or reach the back of the queue.
        forEach(callback) {
          let i2 = this._cursor;
          let node = this._front;
          let elements = node._elements;
          while (i2 !== elements.length || node._next !== void 0) {
            if (i2 === elements.length) {
              node = node._next;
              elements = node._elements;
              i2 = 0;
              if (elements.length === 0) {
                break;
              }
            }
            callback(elements[i2]);
            ++i2;
          }
        }
        // Return the element that would be returned if shift() was called now,
        // without modifying the queue.
        peek() {
          const front = this._front;
          const cursor = this._cursor;
          return front._elements[cursor];
        }
      }
      const AbortSteps = Symbol("[[AbortSteps]]");
      const ErrorSteps = Symbol("[[ErrorSteps]]");
      const CancelSteps = Symbol("[[CancelSteps]]");
      const PullSteps = Symbol("[[PullSteps]]");
      const ReleaseSteps = Symbol("[[ReleaseSteps]]");
      function ReadableStreamReaderGenericInitialize(reader, stream) {
        reader._ownerReadableStream = stream;
        stream._reader = reader;
        if (stream._state === "readable") {
          defaultReaderClosedPromiseInitialize(reader);
        } else if (stream._state === "closed") {
          defaultReaderClosedPromiseInitializeAsResolved(reader);
        } else {
          defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);
        }
      }
      function ReadableStreamReaderGenericCancel(reader, reason) {
        const stream = reader._ownerReadableStream;
        return ReadableStreamCancel(stream, reason);
      }
      function ReadableStreamReaderGenericRelease(reader) {
        const stream = reader._ownerReadableStream;
        if (stream._state === "readable") {
          defaultReaderClosedPromiseReject(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));
        } else {
          defaultReaderClosedPromiseResetToRejected(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));
        }
        stream._readableStreamController[ReleaseSteps]();
        stream._reader = void 0;
        reader._ownerReadableStream = void 0;
      }
      function readerLockException(name) {
        return new TypeError("Cannot " + name + " a stream using a released reader");
      }
      function defaultReaderClosedPromiseInitialize(reader) {
        reader._closedPromise = newPromise((resolve, reject) => {
          reader._closedPromise_resolve = resolve;
          reader._closedPromise_reject = reject;
        });
      }
      function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {
        defaultReaderClosedPromiseInitialize(reader);
        defaultReaderClosedPromiseReject(reader, reason);
      }
      function defaultReaderClosedPromiseInitializeAsResolved(reader) {
        defaultReaderClosedPromiseInitialize(reader);
        defaultReaderClosedPromiseResolve(reader);
      }
      function defaultReaderClosedPromiseReject(reader, reason) {
        if (reader._closedPromise_reject === void 0) {
          return;
        }
        setPromiseIsHandledToTrue(reader._closedPromise);
        reader._closedPromise_reject(reason);
        reader._closedPromise_resolve = void 0;
        reader._closedPromise_reject = void 0;
      }
      function defaultReaderClosedPromiseResetToRejected(reader, reason) {
        defaultReaderClosedPromiseInitializeAsRejected(reader, reason);
      }
      function defaultReaderClosedPromiseResolve(reader) {
        if (reader._closedPromise_resolve === void 0) {
          return;
        }
        reader._closedPromise_resolve(void 0);
        reader._closedPromise_resolve = void 0;
        reader._closedPromise_reject = void 0;
      }
      const NumberIsFinite = Number.isFinite || function(x2) {
        return typeof x2 === "number" && isFinite(x2);
      };
      const MathTrunc = Math.trunc || function(v) {
        return v < 0 ? Math.ceil(v) : Math.floor(v);
      };
      function isDictionary(x2) {
        return typeof x2 === "object" || typeof x2 === "function";
      }
      function assertDictionary(obj, context) {
        if (obj !== void 0 && !isDictionary(obj)) {
          throw new TypeError(`${context} is not an object.`);
        }
      }
      function assertFunction(x2, context) {
        if (typeof x2 !== "function") {
          throw new TypeError(`${context} is not a function.`);
        }
      }
      function isObject(x2) {
        return typeof x2 === "object" && x2 !== null || typeof x2 === "function";
      }
      function assertObject(x2, context) {
        if (!isObject(x2)) {
          throw new TypeError(`${context} is not an object.`);
        }
      }
      function assertRequiredArgument(x2, position, context) {
        if (x2 === void 0) {
          throw new TypeError(`Parameter ${position} is required in '${context}'.`);
        }
      }
      function assertRequiredField(x2, field, context) {
        if (x2 === void 0) {
          throw new TypeError(`${field} is required in '${context}'.`);
        }
      }
      function convertUnrestrictedDouble(value) {
        return Number(value);
      }
      function censorNegativeZero(x2) {
        return x2 === 0 ? 0 : x2;
      }
      function integerPart(x2) {
        return censorNegativeZero(MathTrunc(x2));
      }
      function convertUnsignedLongLongWithEnforceRange(value, context) {
        const lowerBound = 0;
        const upperBound = Number.MAX_SAFE_INTEGER;
        let x2 = Number(value);
        x2 = censorNegativeZero(x2);
        if (!NumberIsFinite(x2)) {
          throw new TypeError(`${context} is not a finite number`);
        }
        x2 = integerPart(x2);
        if (x2 < lowerBound || x2 > upperBound) {
          throw new TypeError(`${context} is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`);
        }
        if (!NumberIsFinite(x2) || x2 === 0) {
          return 0;
        }
        return x2;
      }
      function assertReadableStream(x2, context) {
        if (!IsReadableStream(x2)) {
          throw new TypeError(`${context} is not a ReadableStream.`);
        }
      }
      function AcquireReadableStreamDefaultReader(stream) {
        return new ReadableStreamDefaultReader(stream);
      }
      function ReadableStreamAddReadRequest(stream, readRequest) {
        stream._reader._readRequests.push(readRequest);
      }
      function ReadableStreamFulfillReadRequest(stream, chunk, done) {
        const reader = stream._reader;
        const readRequest = reader._readRequests.shift();
        if (done) {
          readRequest._closeSteps();
        } else {
          readRequest._chunkSteps(chunk);
        }
      }
      function ReadableStreamGetNumReadRequests(stream) {
        return stream._reader._readRequests.length;
      }
      function ReadableStreamHasDefaultReader(stream) {
        const reader = stream._reader;
        if (reader === void 0) {
          return false;
        }
        if (!IsReadableStreamDefaultReader(reader)) {
          return false;
        }
        return true;
      }
      class ReadableStreamDefaultReader {
        constructor(stream) {
          assertRequiredArgument(stream, 1, "ReadableStreamDefaultReader");
          assertReadableStream(stream, "First parameter");
          if (IsReadableStreamLocked(stream)) {
            throw new TypeError("This stream has already been locked for exclusive reading by another reader");
          }
          ReadableStreamReaderGenericInitialize(this, stream);
          this._readRequests = new SimpleQueue();
        }
        /**
         * Returns a promise that will be fulfilled when the stream becomes closed,
         * or rejected if the stream ever errors or the reader's lock is released before the stream finishes closing.
         */
        get closed() {
          if (!IsReadableStreamDefaultReader(this)) {
            return promiseRejectedWith(defaultReaderBrandCheckException("closed"));
          }
          return this._closedPromise;
        }
        /**
         * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.
         */
        cancel(reason = void 0) {
          if (!IsReadableStreamDefaultReader(this)) {
            return promiseRejectedWith(defaultReaderBrandCheckException("cancel"));
          }
          if (this._ownerReadableStream === void 0) {
            return promiseRejectedWith(readerLockException("cancel"));
          }
          return ReadableStreamReaderGenericCancel(this, reason);
        }
        /**
         * Returns a promise that allows access to the next chunk from the stream's internal queue, if available.
         *
         * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.
         */
        read() {
          if (!IsReadableStreamDefaultReader(this)) {
            return promiseRejectedWith(defaultReaderBrandCheckException("read"));
          }
          if (this._ownerReadableStream === void 0) {
            return promiseRejectedWith(readerLockException("read from"));
          }
          let resolvePromise;
          let rejectPromise;
          const promise = newPromise((resolve, reject) => {
            resolvePromise = resolve;
            rejectPromise = reject;
          });
          const readRequest = {
            _chunkSteps: (chunk) => resolvePromise({ value: chunk, done: false }),
            _closeSteps: () => resolvePromise({ value: void 0, done: true }),
            _errorSteps: (e2) => rejectPromise(e2)
          };
          ReadableStreamDefaultReaderRead(this, readRequest);
          return promise;
        }
        /**
         * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.
         * If the associated stream is errored when the lock is released, the reader will appear errored in the same way
         * from now on; otherwise, the reader will appear closed.
         *
         * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by
         * the reader's {@link ReadableStreamDefaultReader.read | read()} method has not yet been settled. Attempting to
         * do so will throw a `TypeError` and leave the reader locked to the stream.
         */
        releaseLock() {
          if (!IsReadableStreamDefaultReader(this)) {
            throw defaultReaderBrandCheckException("releaseLock");
          }
          if (this._ownerReadableStream === void 0) {
            return;
          }
          ReadableStreamDefaultReaderRelease(this);
        }
      }
      Object.defineProperties(ReadableStreamDefaultReader.prototype, {
        cancel: { enumerable: true },
        read: { enumerable: true },
        releaseLock: { enumerable: true },
        closed: { enumerable: true }
      });
      setFunctionName(ReadableStreamDefaultReader.prototype.cancel, "cancel");
      setFunctionName(ReadableStreamDefaultReader.prototype.read, "read");
      setFunctionName(ReadableStreamDefaultReader.prototype.releaseLock, "releaseLock");
      if (typeof Symbol.toStringTag === "symbol") {
        Object.defineProperty(ReadableStreamDefaultReader.prototype, Symbol.toStringTag, {
          value: "ReadableStreamDefaultReader",
          configurable: true
        });
      }
      function IsReadableStreamDefaultReader(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_readRequests")) {
          return false;
        }
        return x2 instanceof ReadableStreamDefaultReader;
      }
      function ReadableStreamDefaultReaderRead(reader, readRequest) {
        const stream = reader._ownerReadableStream;
        stream._disturbed = true;
        if (stream._state === "closed") {
          readRequest._closeSteps();
        } else if (stream._state === "errored") {
          readRequest._errorSteps(stream._storedError);
        } else {
          stream._readableStreamController[PullSteps](readRequest);
        }
      }
      function ReadableStreamDefaultReaderRelease(reader) {
        ReadableStreamReaderGenericRelease(reader);
        const e2 = new TypeError("Reader was released");
        ReadableStreamDefaultReaderErrorReadRequests(reader, e2);
      }
      function ReadableStreamDefaultReaderErrorReadRequests(reader, e2) {
        const readRequests = reader._readRequests;
        reader._readRequests = new SimpleQueue();
        readRequests.forEach((readRequest) => {
          readRequest._errorSteps(e2);
        });
      }
      function defaultReaderBrandCheckException(name) {
        return new TypeError(`ReadableStreamDefaultReader.prototype.${name} can only be used on a ReadableStreamDefaultReader`);
      }
      const AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(async function* () {
      }).prototype);
      class ReadableStreamAsyncIteratorImpl {
        constructor(reader, preventCancel) {
          this._ongoingPromise = void 0;
          this._isFinished = false;
          this._reader = reader;
          this._preventCancel = preventCancel;
        }
        next() {
          const nextSteps = () => this._nextSteps();
          this._ongoingPromise = this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, nextSteps, nextSteps) : nextSteps();
          return this._ongoingPromise;
        }
        return(value) {
          const returnSteps = () => this._returnSteps(value);
          return this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, returnSteps, returnSteps) : returnSteps();
        }
        _nextSteps() {
          if (this._isFinished) {
            return Promise.resolve({ value: void 0, done: true });
          }
          const reader = this._reader;
          let resolvePromise;
          let rejectPromise;
          const promise = newPromise((resolve, reject) => {
            resolvePromise = resolve;
            rejectPromise = reject;
          });
          const readRequest = {
            _chunkSteps: (chunk) => {
              this._ongoingPromise = void 0;
              _queueMicrotask(() => resolvePromise({ value: chunk, done: false }));
            },
            _closeSteps: () => {
              this._ongoingPromise = void 0;
              this._isFinished = true;
              ReadableStreamReaderGenericRelease(reader);
              resolvePromise({ value: void 0, done: true });
            },
            _errorSteps: (reason) => {
              this._ongoingPromise = void 0;
              this._isFinished = true;
              ReadableStreamReaderGenericRelease(reader);
              rejectPromise(reason);
            }
          };
          ReadableStreamDefaultReaderRead(reader, readRequest);
          return promise;
        }
        _returnSteps(value) {
          if (this._isFinished) {
            return Promise.resolve({ value, done: true });
          }
          this._isFinished = true;
          const reader = this._reader;
          if (!this._preventCancel) {
            const result = ReadableStreamReaderGenericCancel(reader, value);
            ReadableStreamReaderGenericRelease(reader);
            return transformPromiseWith(result, () => ({ value, done: true }));
          }
          ReadableStreamReaderGenericRelease(reader);
          return promiseResolvedWith({ value, done: true });
        }
      }
      const ReadableStreamAsyncIteratorPrototype = {
        next() {
          if (!IsReadableStreamAsyncIterator(this)) {
            return promiseRejectedWith(streamAsyncIteratorBrandCheckException("next"));
          }
          return this._asyncIteratorImpl.next();
        },
        return(value) {
          if (!IsReadableStreamAsyncIterator(this)) {
            return promiseRejectedWith(streamAsyncIteratorBrandCheckException("return"));
          }
          return this._asyncIteratorImpl.return(value);
        }
      };
      Object.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);
      function AcquireReadableStreamAsyncIterator(stream, preventCancel) {
        const reader = AcquireReadableStreamDefaultReader(stream);
        const impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel);
        const iterator = Object.create(ReadableStreamAsyncIteratorPrototype);
        iterator._asyncIteratorImpl = impl;
        return iterator;
      }
      function IsReadableStreamAsyncIterator(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_asyncIteratorImpl")) {
          return false;
        }
        try {
          return x2._asyncIteratorImpl instanceof ReadableStreamAsyncIteratorImpl;
        } catch (_a2) {
          return false;
        }
      }
      function streamAsyncIteratorBrandCheckException(name) {
        return new TypeError(`ReadableStreamAsyncIterator.${name} can only be used on a ReadableSteamAsyncIterator`);
      }
      const NumberIsNaN = Number.isNaN || function(x2) {
        return x2 !== x2;
      };
      var _a, _b, _c;
      function CreateArrayFromList(elements) {
        return elements.slice();
      }
      function CopyDataBlockBytes(dest, destOffset, src, srcOffset, n) {
        new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);
      }
      let TransferArrayBuffer = (O) => {
        if (typeof O.transfer === "function") {
          TransferArrayBuffer = (buffer) => buffer.transfer();
        } else if (typeof structuredClone === "function") {
          TransferArrayBuffer = (buffer) => structuredClone(buffer, { transfer: [buffer] });
        } else {
          TransferArrayBuffer = (buffer) => buffer;
        }
        return TransferArrayBuffer(O);
      };
      let IsDetachedBuffer = (O) => {
        if (typeof O.detached === "boolean") {
          IsDetachedBuffer = (buffer) => buffer.detached;
        } else {
          IsDetachedBuffer = (buffer) => buffer.byteLength === 0;
        }
        return IsDetachedBuffer(O);
      };
      function ArrayBufferSlice(buffer, begin, end) {
        if (buffer.slice) {
          return buffer.slice(begin, end);
        }
        const length = end - begin;
        const slice = new ArrayBuffer(length);
        CopyDataBlockBytes(slice, 0, buffer, begin, length);
        return slice;
      }
      function GetMethod(receiver, prop) {
        const func = receiver[prop];
        if (func === void 0 || func === null) {
          return void 0;
        }
        if (typeof func !== "function") {
          throw new TypeError(`${String(prop)} is not a function`);
        }
        return func;
      }
      function CreateAsyncFromSyncIterator(syncIteratorRecord) {
        const syncIterable = {
          [Symbol.iterator]: () => syncIteratorRecord.iterator
        };
        const asyncIterator = async function* () {
          return yield* syncIterable;
        }();
        const nextMethod = asyncIterator.next;
        return { iterator: asyncIterator, nextMethod, done: false };
      }
      const SymbolAsyncIterator = (_c = (_a = Symbol.asyncIterator) !== null && _a !== void 0 ? _a : (_b = Symbol.for) === null || _b === void 0 ? void 0 : _b.call(Symbol, "Symbol.asyncIterator")) !== null && _c !== void 0 ? _c : "@@asyncIterator";
      function GetIterator(obj, hint = "sync", method) {
        if (method === void 0) {
          if (hint === "async") {
            method = GetMethod(obj, SymbolAsyncIterator);
            if (method === void 0) {
              const syncMethod = GetMethod(obj, Symbol.iterator);
              const syncIteratorRecord = GetIterator(obj, "sync", syncMethod);
              return CreateAsyncFromSyncIterator(syncIteratorRecord);
            }
          } else {
            method = GetMethod(obj, Symbol.iterator);
          }
        }
        if (method === void 0) {
          throw new TypeError("The object is not iterable");
        }
        const iterator = reflectCall(method, obj, []);
        if (!typeIsObject(iterator)) {
          throw new TypeError("The iterator method must return an object");
        }
        const nextMethod = iterator.next;
        return { iterator, nextMethod, done: false };
      }
      function IteratorNext(iteratorRecord) {
        const result = reflectCall(iteratorRecord.nextMethod, iteratorRecord.iterator, []);
        if (!typeIsObject(result)) {
          throw new TypeError("The iterator.next() method must return an object");
        }
        return result;
      }
      function IteratorComplete(iterResult) {
        return Boolean(iterResult.done);
      }
      function IteratorValue(iterResult) {
        return iterResult.value;
      }
      function IsNonNegativeNumber(v) {
        if (typeof v !== "number") {
          return false;
        }
        if (NumberIsNaN(v)) {
          return false;
        }
        if (v < 0) {
          return false;
        }
        return true;
      }
      function CloneAsUint8Array(O) {
        const buffer = ArrayBufferSlice(O.buffer, O.byteOffset, O.byteOffset + O.byteLength);
        return new Uint8Array(buffer);
      }
      function DequeueValue(container) {
        const pair = container._queue.shift();
        container._queueTotalSize -= pair.size;
        if (container._queueTotalSize < 0) {
          container._queueTotalSize = 0;
        }
        return pair.value;
      }
      function EnqueueValueWithSize(container, value, size) {
        if (!IsNonNegativeNumber(size) || size === Infinity) {
          throw new RangeError("Size must be a finite, non-NaN, non-negative number.");
        }
        container._queue.push({ value, size });
        container._queueTotalSize += size;
      }
      function PeekQueueValue(container) {
        const pair = container._queue.peek();
        return pair.value;
      }
      function ResetQueue(container) {
        container._queue = new SimpleQueue();
        container._queueTotalSize = 0;
      }
      function isDataViewConstructor(ctor) {
        return ctor === DataView;
      }
      function isDataView(view) {
        return isDataViewConstructor(view.constructor);
      }
      function arrayBufferViewElementSize(ctor) {
        if (isDataViewConstructor(ctor)) {
          return 1;
        }
        return ctor.BYTES_PER_ELEMENT;
      }
      class ReadableStreamBYOBRequest {
        constructor() {
          throw new TypeError("Illegal constructor");
        }
        /**
         * Returns the view for writing in to, or `null` if the BYOB request has already been responded to.
         */
        get view() {
          if (!IsReadableStreamBYOBRequest(this)) {
            throw byobRequestBrandCheckException("view");
          }
          return this._view;
        }
        respond(bytesWritten) {
          if (!IsReadableStreamBYOBRequest(this)) {
            throw byobRequestBrandCheckException("respond");
          }
          assertRequiredArgument(bytesWritten, 1, "respond");
          bytesWritten = convertUnsignedLongLongWithEnforceRange(bytesWritten, "First parameter");
          if (this._associatedReadableByteStreamController === void 0) {
            throw new TypeError("This BYOB request has been invalidated");
          }
          if (IsDetachedBuffer(this._view.buffer)) {
            throw new TypeError(`The BYOB request's buffer has been detached and so cannot be used as a response`);
          }
          ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);
        }
        respondWithNewView(view) {
          if (!IsReadableStreamBYOBRequest(this)) {
            throw byobRequestBrandCheckException("respondWithNewView");
          }
          assertRequiredArgument(view, 1, "respondWithNewView");
          if (!ArrayBuffer.isView(view)) {
            throw new TypeError("You can only respond with array buffer views");
          }
          if (this._associatedReadableByteStreamController === void 0) {
            throw new TypeError("This BYOB request has been invalidated");
          }
          if (IsDetachedBuffer(view.buffer)) {
            throw new TypeError("The given view's buffer has been detached and so cannot be used as a response");
          }
          ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);
        }
      }
      Object.defineProperties(ReadableStreamBYOBRequest.prototype, {
        respond: { enumerable: true },
        respondWithNewView: { enumerable: true },
        view: { enumerable: true }
      });
      setFunctionName(ReadableStreamBYOBRequest.prototype.respond, "respond");
      setFunctionName(ReadableStreamBYOBRequest.prototype.respondWithNewView, "respondWithNewView");
      if (typeof Symbol.toStringTag === "symbol") {
        Object.defineProperty(ReadableStreamBYOBRequest.prototype, Symbol.toStringTag, {
          value: "ReadableStreamBYOBRequest",
          configurable: true
        });
      }
      class ReadableByteStreamController {
        constructor() {
          throw new TypeError("Illegal constructor");
        }
        /**
         * Returns the current BYOB pull request, or `null` if there isn't one.
         */
        get byobRequest() {
          if (!IsReadableByteStreamController(this)) {
            throw byteStreamControllerBrandCheckException("byobRequest");
          }
          return ReadableByteStreamControllerGetBYOBRequest(this);
        }
        /**
         * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is
         * over-full. An underlying byte source ought to use this information to determine when and how to apply backpressure.
         */
        get desiredSize() {
          if (!IsReadableByteStreamController(this)) {
            throw byteStreamControllerBrandCheckException("desiredSize");
          }
          return ReadableByteStreamControllerGetDesiredSize(this);
        }
        /**
         * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from
         * the stream, but once those are read, the stream will become closed.
         */
        close() {
          if (!IsReadableByteStreamController(this)) {
            throw byteStreamControllerBrandCheckException("close");
          }
          if (this._closeRequested) {
            throw new TypeError("The stream has already been closed; do not close it again!");
          }
          const state = this._controlledReadableByteStream._state;
          if (state !== "readable") {
            throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);
          }
          ReadableByteStreamControllerClose(this);
        }
        enqueue(chunk) {
          if (!IsReadableByteStreamController(this)) {
            throw byteStreamControllerBrandCheckException("enqueue");
          }
          assertRequiredArgument(chunk, 1, "enqueue");
          if (!ArrayBuffer.isView(chunk)) {
            throw new TypeError("chunk must be an array buffer view");
          }
          if (chunk.byteLength === 0) {
            throw new TypeError("chunk must have non-zero byteLength");
          }
          if (chunk.buffer.byteLength === 0) {
            throw new TypeError(`chunk's buffer must have non-zero byteLength`);
          }
          if (this._closeRequested) {
            throw new TypeError("stream is closed or draining");
          }
          const state = this._controlledReadableByteStream._state;
          if (state !== "readable") {
            throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);
          }
          ReadableByteStreamControllerEnqueue(this, chunk);
        }
        /**
         * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.
         */
        error(e2 = void 0) {
          if (!IsReadableByteStreamController(this)) {
            throw byteStreamControllerBrandCheckException("error");
          }
          ReadableByteStreamControllerError(this, e2);
        }
        /** @internal */
        [CancelSteps](reason) {
          ReadableByteStreamControllerClearPendingPullIntos(this);
          ResetQueue(this);
          const result = this._cancelAlgorithm(reason);
          ReadableByteStreamControllerClearAlgorithms(this);
          return result;
        }
        /** @internal */
        [PullSteps](readRequest) {
          const stream = this._controlledReadableByteStream;
          if (this._queueTotalSize > 0) {
            ReadableByteStreamControllerFillReadRequestFromQueue(this, readRequest);
            return;
          }
          const autoAllocateChunkSize = this._autoAllocateChunkSize;
          if (autoAllocateChunkSize !== void 0) {
            let buffer;
            try {
              buffer = new ArrayBuffer(autoAllocateChunkSize);
            } catch (bufferE) {
              readRequest._errorSteps(bufferE);
              return;
            }
            const pullIntoDescriptor = {
              buffer,
              bufferByteLength: autoAllocateChunkSize,
              byteOffset: 0,
              byteLength: autoAllocateChunkSize,
              bytesFilled: 0,
              minimumFill: 1,
              elementSize: 1,
              viewConstructor: Uint8Array,
              readerType: "default"
            };
            this._pendingPullIntos.push(pullIntoDescriptor);
          }
          ReadableStreamAddReadRequest(stream, readRequest);
          ReadableByteStreamControllerCallPullIfNeeded(this);
        }
        /** @internal */
        [ReleaseSteps]() {
          if (this._pendingPullIntos.length > 0) {
            const firstPullInto = this._pendingPullIntos.peek();
            firstPullInto.readerType = "none";
            this._pendingPullIntos = new SimpleQueue();
            this._pendingPullIntos.push(firstPullInto);
          }
        }
      }
      Object.defineProperties(ReadableByteStreamController.prototype, {
        close: { enumerable: true },
        enqueue: { enumerable: true },
        error: { enumerable: true },
        byobRequest: { enumerable: true },
        desiredSize: { enumerable: true }
      });
      setFunctionName(ReadableByteStreamController.prototype.close, "close");
      setFunctionName(ReadableByteStreamController.prototype.enqueue, "enqueue");
      setFunctionName(ReadableByteStreamController.prototype.error, "error");
      if (typeof Symbol.toStringTag === "symbol") {
        Object.defineProperty(ReadableByteStreamController.prototype, Symbol.toStringTag, {
          value: "ReadableByteStreamController",
          configurable: true
        });
      }
      function IsReadableByteStreamController(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_controlledReadableByteStream")) {
          return false;
        }
        return x2 instanceof ReadableByteStreamController;
      }
      function IsReadableStreamBYOBRequest(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_associatedReadableByteStreamController")) {
          return false;
        }
        return x2 instanceof ReadableStreamBYOBRequest;
      }
      function ReadableByteStreamControllerCallPullIfNeeded(controller) {
        const shouldPull = ReadableByteStreamControllerShouldCallPull(controller);
        if (!shouldPull) {
          return;
        }
        if (controller._pulling) {
          controller._pullAgain = true;
          return;
        }
        controller._pulling = true;
        const pullPromise = controller._pullAlgorithm();
        uponPromise(pullPromise, () => {
          controller._pulling = false;
          if (controller._pullAgain) {
            controller._pullAgain = false;
            ReadableByteStreamControllerCallPullIfNeeded(controller);
          }
          return null;
        }, (e2) => {
          ReadableByteStreamControllerError(controller, e2);
          return null;
        });
      }
      function ReadableByteStreamControllerClearPendingPullIntos(controller) {
        ReadableByteStreamControllerInvalidateBYOBRequest(controller);
        controller._pendingPullIntos = new SimpleQueue();
      }
      function ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {
        let done = false;
        if (stream._state === "closed") {
          done = true;
        }
        const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
        if (pullIntoDescriptor.readerType === "default") {
          ReadableStreamFulfillReadRequest(stream, filledView, done);
        } else {
          ReadableStreamFulfillReadIntoRequest(stream, filledView, done);
        }
      }
      function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {
        const bytesFilled = pullIntoDescriptor.bytesFilled;
        const elementSize = pullIntoDescriptor.elementSize;
        return new pullIntoDescriptor.viewConstructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);
      }
      function ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {
        controller._queue.push({ buffer, byteOffset, byteLength });
        controller._queueTotalSize += byteLength;
      }
      function ReadableByteStreamControllerEnqueueClonedChunkToQueue(controller, buffer, byteOffset, byteLength) {
        let clonedChunk;
        try {
          clonedChunk = ArrayBufferSlice(buffer, byteOffset, byteOffset + byteLength);
        } catch (cloneE) {
          ReadableByteStreamControllerError(controller, cloneE);
          throw cloneE;
        }
        ReadableByteStreamControllerEnqueueChunkToQueue(controller, clonedChunk, 0, byteLength);
      }
      function ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(controller, firstDescriptor) {
        if (firstDescriptor.bytesFilled > 0) {
          ReadableByteStreamControllerEnqueueClonedChunkToQueue(controller, firstDescriptor.buffer, firstDescriptor.byteOffset, firstDescriptor.bytesFilled);
        }
        ReadableByteStreamControllerShiftPendingPullInto(controller);
      }
      function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {
        const maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);
        const maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;
        let totalBytesToCopyRemaining = maxBytesToCopy;
        let ready = false;
        const remainderBytes = maxBytesFilled % pullIntoDescriptor.elementSize;
        const maxAlignedBytes = maxBytesFilled - remainderBytes;
        if (maxAlignedBytes >= pullIntoDescriptor.minimumFill) {
          totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;
          ready = true;
        }
        const queue = controller._queue;
        while (totalBytesToCopyRemaining > 0) {
          const headOfQueue = queue.peek();
          const bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);
          const destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
          CopyDataBlockBytes(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);
          if (headOfQueue.byteLength === bytesToCopy) {
            queue.shift();
          } else {
            headOfQueue.byteOffset += bytesToCopy;
            headOfQueue.byteLength -= bytesToCopy;
          }
          controller._queueTotalSize -= bytesToCopy;
          ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);
          totalBytesToCopyRemaining -= bytesToCopy;
        }
        return ready;
      }
      function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {
        pullIntoDescriptor.bytesFilled += size;
      }
      function ReadableByteStreamControllerHandleQueueDrain(controller) {
        if (controller._queueTotalSize === 0 && controller._closeRequested) {
          ReadableByteStreamControllerClearAlgorithms(controller);
          ReadableStreamClose(controller._controlledReadableByteStream);
        } else {
          ReadableByteStreamControllerCallPullIfNeeded(controller);
        }
      }
      function ReadableByteStreamControllerInvalidateBYOBRequest(controller) {
        if (controller._byobRequest === null) {
          return;
        }
        controller._byobRequest._associatedReadableByteStreamController = void 0;
        controller._byobRequest._view = null;
        controller._byobRequest = null;
      }
      function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {
        while (controller._pendingPullIntos.length > 0) {
          if (controller._queueTotalSize === 0) {
            return;
          }
          const pullIntoDescriptor = controller._pendingPullIntos.peek();
          if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
            ReadableByteStreamControllerShiftPendingPullInto(controller);
            ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
          }
        }
      }
      function ReadableByteStreamControllerProcessReadRequestsUsingQueue(controller) {
        const reader = controller._controlledReadableByteStream._reader;
        while (reader._readRequests.length > 0) {
          if (controller._queueTotalSize === 0) {
            return;
          }
          const readRequest = reader._readRequests.shift();
          ReadableByteStreamControllerFillReadRequestFromQueue(controller, readRequest);
        }
      }
      function ReadableByteStreamControllerPullInto(controller, view, min, readIntoRequest) {
        const stream = controller._controlledReadableByteStream;
        const ctor = view.constructor;
        const elementSize = arrayBufferViewElementSize(ctor);
        const { byteOffset, byteLength } = view;
        const minimumFill = min * elementSize;
        let buffer;
        try {
          buffer = TransferArrayBuffer(view.buffer);
        } catch (e2) {
          readIntoRequest._errorSteps(e2);
          return;
        }
        const pullIntoDescriptor = {
          buffer,
          bufferByteLength: buffer.byteLength,
          byteOffset,
          byteLength,
          bytesFilled: 0,
          minimumFill,
          elementSize,
          viewConstructor: ctor,
          readerType: "byob"
        };
        if (controller._pendingPullIntos.length > 0) {
          controller._pendingPullIntos.push(pullIntoDescriptor);
          ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
          return;
        }
        if (stream._state === "closed") {
          const emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);
          readIntoRequest._closeSteps(emptyView);
          return;
        }
        if (controller._queueTotalSize > 0) {
          if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
            const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
            ReadableByteStreamControllerHandleQueueDrain(controller);
            readIntoRequest._chunkSteps(filledView);
            return;
          }
          if (controller._closeRequested) {
            const e2 = new TypeError("Insufficient bytes to fill elements in the given buffer");
            ReadableByteStreamControllerError(controller, e2);
            readIntoRequest._errorSteps(e2);
            return;
          }
        }
        controller._pendingPullIntos.push(pullIntoDescriptor);
        ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
        ReadableByteStreamControllerCallPullIfNeeded(controller);
      }
      function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {
        if (firstDescriptor.readerType === "none") {
          ReadableByteStreamControllerShiftPendingPullInto(controller);
        }
        const stream = controller._controlledReadableByteStream;
        if (ReadableStreamHasBYOBReader(stream)) {
          while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {
            const pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);
            ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);
          }
        }
      }
      function ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {
        ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);
        if (pullIntoDescriptor.readerType === "none") {
          ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(controller, pullIntoDescriptor);
          ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
          return;
        }
        if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.minimumFill) {
          return;
        }
        ReadableByteStreamControllerShiftPendingPullInto(controller);
        const remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;
        if (remainderSize > 0) {
          const end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
          ReadableByteStreamControllerEnqueueClonedChunkToQueue(controller, pullIntoDescriptor.buffer, end - remainderSize, remainderSize);
        }
        pullIntoDescriptor.bytesFilled -= remainderSize;
        ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
        ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
      }
      function ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {
        const firstDescriptor = controller._pendingPullIntos.peek();
        ReadableByteStreamControllerInvalidateBYOBRequest(controller);
        const state = controller._controlledReadableByteStream._state;
        if (state === "closed") {
          ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor);
        } else {
          ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);
        }
        ReadableByteStreamControllerCallPullIfNeeded(controller);
      }
      function ReadableByteStreamControllerShiftPendingPullInto(controller) {
        const descriptor = controller._pendingPullIntos.shift();
        return descriptor;
      }
      function ReadableByteStreamControllerShouldCallPull(controller) {
        const stream = controller._controlledReadableByteStream;
        if (stream._state !== "readable") {
          return false;
        }
        if (controller._closeRequested) {
          return false;
        }
        if (!controller._started) {
          return false;
        }
        if (ReadableStreamHasDefaultReader(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
          return true;
        }
        if (ReadableStreamHasBYOBReader(stream) && ReadableStreamGetNumReadIntoRequests(stream) > 0) {
          return true;
        }
        const desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);
        if (desiredSize > 0) {
          return true;
        }
        return false;
      }
      function ReadableByteStreamControllerClearAlgorithms(controller) {
        controller._pullAlgorithm = void 0;
        controller._cancelAlgorithm = void 0;
      }
      function ReadableByteStreamControllerClose(controller) {
        const stream = controller._controlledReadableByteStream;
        if (controller._closeRequested || stream._state !== "readable") {
          return;
        }
        if (controller._queueTotalSize > 0) {
          controller._closeRequested = true;
          return;
        }
        if (controller._pendingPullIntos.length > 0) {
          const firstPendingPullInto = controller._pendingPullIntos.peek();
          if (firstPendingPullInto.bytesFilled % firstPendingPullInto.elementSize !== 0) {
            const e2 = new TypeError("Insufficient bytes to fill elements in the given buffer");
            ReadableByteStreamControllerError(controller, e2);
            throw e2;
          }
        }
        ReadableByteStreamControllerClearAlgorithms(controller);
        ReadableStreamClose(stream);
      }
      function ReadableByteStreamControllerEnqueue(controller, chunk) {
        const stream = controller._controlledReadableByteStream;
        if (controller._closeRequested || stream._state !== "readable") {
          return;
        }
        const { buffer, byteOffset, byteLength } = chunk;
        if (IsDetachedBuffer(buffer)) {
          throw new TypeError("chunk's buffer is detached and so cannot be enqueued");
        }
        const transferredBuffer = TransferArrayBuffer(buffer);
        if (controller._pendingPullIntos.length > 0) {
          const firstPendingPullInto = controller._pendingPullIntos.peek();
          if (IsDetachedBuffer(firstPendingPullInto.buffer)) {
            throw new TypeError("The BYOB request's buffer has been detached and so cannot be filled with an enqueued chunk");
          }
          ReadableByteStreamControllerInvalidateBYOBRequest(controller);
          firstPendingPullInto.buffer = TransferArrayBuffer(firstPendingPullInto.buffer);
          if (firstPendingPullInto.readerType === "none") {
            ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(controller, firstPendingPullInto);
          }
        }
        if (ReadableStreamHasDefaultReader(stream)) {
          ReadableByteStreamControllerProcessReadRequestsUsingQueue(controller);
          if (ReadableStreamGetNumReadRequests(stream) === 0) {
            ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
          } else {
            if (controller._pendingPullIntos.length > 0) {
              ReadableByteStreamControllerShiftPendingPullInto(controller);
            }
            const transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);
            ReadableStreamFulfillReadRequest(stream, transferredView, false);
          }
        } else if (ReadableStreamHasBYOBReader(stream)) {
          ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
          ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
        } else {
          ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
        }
        ReadableByteStreamControllerCallPullIfNeeded(controller);
      }
      function ReadableByteStreamControllerError(controller, e2) {
        const stream = controller._controlledReadableByteStream;
        if (stream._state !== "readable") {
          return;
        }
        ReadableByteStreamControllerClearPendingPullIntos(controller);
        ResetQueue(controller);
        ReadableByteStreamControllerClearAlgorithms(controller);
        ReadableStreamError(stream, e2);
      }
      function ReadableByteStreamControllerFillReadRequestFromQueue(controller, readRequest) {
        const entry = controller._queue.shift();
        controller._queueTotalSize -= entry.byteLength;
        ReadableByteStreamControllerHandleQueueDrain(controller);
        const view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);
        readRequest._chunkSteps(view);
      }
      function ReadableByteStreamControllerGetBYOBRequest(controller) {
        if (controller._byobRequest === null && controller._pendingPullIntos.length > 0) {
          const firstDescriptor = controller._pendingPullIntos.peek();
          const view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled);
          const byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);
          SetUpReadableStreamBYOBRequest(byobRequest, controller, view);
          controller._byobRequest = byobRequest;
        }
        return controller._byobRequest;
      }
      function ReadableByteStreamControllerGetDesiredSize(controller) {
        const state = controller._controlledReadableByteStream._state;
        if (state === "errored") {
          return null;
        }
        if (state === "closed") {
          return 0;
        }
        return controller._strategyHWM - controller._queueTotalSize;
      }
      function ReadableByteStreamControllerRespond(controller, bytesWritten) {
        const firstDescriptor = controller._pendingPullIntos.peek();
        const state = controller._controlledReadableByteStream._state;
        if (state === "closed") {
          if (bytesWritten !== 0) {
            throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream");
          }
        } else {
          if (bytesWritten === 0) {
            throw new TypeError("bytesWritten must be greater than 0 when calling respond() on a readable stream");
          }
          if (firstDescriptor.bytesFilled + bytesWritten > firstDescriptor.byteLength) {
            throw new RangeError("bytesWritten out of range");
          }
        }
        firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);
        ReadableByteStreamControllerRespondInternal(controller, bytesWritten);
      }
      function ReadableByteStreamControllerRespondWithNewView(controller, view) {
        const firstDescriptor = controller._pendingPullIntos.peek();
        const state = controller._controlledReadableByteStream._state;
        if (state === "closed") {
          if (view.byteLength !== 0) {
            throw new TypeError("The view's length must be 0 when calling respondWithNewView() on a closed stream");
          }
        } else {
          if (view.byteLength === 0) {
            throw new TypeError("The view's length must be greater than 0 when calling respondWithNewView() on a readable stream");
          }
        }
        if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {
          throw new RangeError("The region specified by view does not match byobRequest");
        }
        if (firstDescriptor.bufferByteLength !== view.buffer.byteLength) {
          throw new RangeError("The buffer of view has different capacity than byobRequest");
        }
        if (firstDescriptor.bytesFilled + view.byteLength > firstDescriptor.byteLength) {
          throw new RangeError("The region specified by view is larger than byobRequest");
        }
        const viewByteLength = view.byteLength;
        firstDescriptor.buffer = TransferArrayBuffer(view.buffer);
        ReadableByteStreamControllerRespondInternal(controller, viewByteLength);
      }
      function SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {
        controller._controlledReadableByteStream = stream;
        controller._pullAgain = false;
        controller._pulling = false;
        controller._byobRequest = null;
        controller._queue = controller._queueTotalSize = void 0;
        ResetQueue(controller);
        controller._closeRequested = false;
        controller._started = false;
        controller._strategyHWM = highWaterMark;
        controller._pullAlgorithm = pullAlgorithm;
        controller._cancelAlgorithm = cancelAlgorithm;
        controller._autoAllocateChunkSize = autoAllocateChunkSize;
        controller._pendingPullIntos = new SimpleQueue();
        stream._readableStreamController = controller;
        const startResult = startAlgorithm();
        uponPromise(promiseResolvedWith(startResult), () => {
          controller._started = true;
          ReadableByteStreamControllerCallPullIfNeeded(controller);
          return null;
        }, (r2) => {
          ReadableByteStreamControllerError(controller, r2);
          return null;
        });
      }
      function SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {
        const controller = Object.create(ReadableByteStreamController.prototype);
        let startAlgorithm;
        let pullAlgorithm;
        let cancelAlgorithm;
        if (underlyingByteSource.start !== void 0) {
          startAlgorithm = () => underlyingByteSource.start(controller);
        } else {
          startAlgorithm = () => void 0;
        }
        if (underlyingByteSource.pull !== void 0) {
          pullAlgorithm = () => underlyingByteSource.pull(controller);
        } else {
          pullAlgorithm = () => promiseResolvedWith(void 0);
        }
        if (underlyingByteSource.cancel !== void 0) {
          cancelAlgorithm = (reason) => underlyingByteSource.cancel(reason);
        } else {
          cancelAlgorithm = () => promiseResolvedWith(void 0);
        }
        const autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;
        if (autoAllocateChunkSize === 0) {
          throw new TypeError("autoAllocateChunkSize must be greater than 0");
        }
        SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);
      }
      function SetUpReadableStreamBYOBRequest(request, controller, view) {
        request._associatedReadableByteStreamController = controller;
        request._view = view;
      }
      function byobRequestBrandCheckException(name) {
        return new TypeError(`ReadableStreamBYOBRequest.prototype.${name} can only be used on a ReadableStreamBYOBRequest`);
      }
      function byteStreamControllerBrandCheckException(name) {
        return new TypeError(`ReadableByteStreamController.prototype.${name} can only be used on a ReadableByteStreamController`);
      }
      function convertReaderOptions(options, context) {
        assertDictionary(options, context);
        const mode = options === null || options === void 0 ? void 0 : options.mode;
        return {
          mode: mode === void 0 ? void 0 : convertReadableStreamReaderMode(mode, `${context} has member 'mode' that`)
        };
      }
      function convertReadableStreamReaderMode(mode, context) {
        mode = `${mode}`;
        if (mode !== "byob") {
          throw new TypeError(`${context} '${mode}' is not a valid enumeration value for ReadableStreamReaderMode`);
        }
        return mode;
      }
      function convertByobReadOptions(options, context) {
        var _a2;
        assertDictionary(options, context);
        const min = (_a2 = options === null || options === void 0 ? void 0 : options.min) !== null && _a2 !== void 0 ? _a2 : 1;
        return {
          min: convertUnsignedLongLongWithEnforceRange(min, `${context} has member 'min' that`)
        };
      }
      function AcquireReadableStreamBYOBReader(stream) {
        return new ReadableStreamBYOBReader(stream);
      }
      function ReadableStreamAddReadIntoRequest(stream, readIntoRequest) {
        stream._reader._readIntoRequests.push(readIntoRequest);
      }
      function ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {
        const reader = stream._reader;
        const readIntoRequest = reader._readIntoRequests.shift();
        if (done) {
          readIntoRequest._closeSteps(chunk);
        } else {
          readIntoRequest._chunkSteps(chunk);
        }
      }
      function ReadableStreamGetNumReadIntoRequests(stream) {
        return stream._reader._readIntoRequests.length;
      }
      function ReadableStreamHasBYOBReader(stream) {
        const reader = stream._reader;
        if (reader === void 0) {
          return false;
        }
        if (!IsReadableStreamBYOBReader(reader)) {
          return false;
        }
        return true;
      }
      class ReadableStreamBYOBReader {
        constructor(stream) {
          assertRequiredArgument(stream, 1, "ReadableStreamBYOBReader");
          assertReadableStream(stream, "First parameter");
          if (IsReadableStreamLocked(stream)) {
            throw new TypeError("This stream has already been locked for exclusive reading by another reader");
          }
          if (!IsReadableByteStreamController(stream._readableStreamController)) {
            throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");
          }
          ReadableStreamReaderGenericInitialize(this, stream);
          this._readIntoRequests = new SimpleQueue();
        }
        /**
         * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or
         * the reader's lock is released before the stream finishes closing.
         */
        get closed() {
          if (!IsReadableStreamBYOBReader(this)) {
            return promiseRejectedWith(byobReaderBrandCheckException("closed"));
          }
          return this._closedPromise;
        }
        /**
         * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.
         */
        cancel(reason = void 0) {
          if (!IsReadableStreamBYOBReader(this)) {
            return promiseRejectedWith(byobReaderBrandCheckException("cancel"));
          }
          if (this._ownerReadableStream === void 0) {
            return promiseRejectedWith(readerLockException("cancel"));
          }
          return ReadableStreamReaderGenericCancel(this, reason);
        }
        read(view, rawOptions = {}) {
          if (!IsReadableStreamBYOBReader(this)) {
            return promiseRejectedWith(byobReaderBrandCheckException("read"));
          }
          if (!ArrayBuffer.isView(view)) {
            return promiseRejectedWith(new TypeError("view must be an array buffer view"));
          }
          if (view.byteLength === 0) {
            return promiseRejectedWith(new TypeError("view must have non-zero byteLength"));
          }
          if (view.buffer.byteLength === 0) {
            return promiseRejectedWith(new TypeError(`view's buffer must have non-zero byteLength`));
          }
          if (IsDetachedBuffer(view.buffer)) {
            return promiseRejectedWith(new TypeError("view's buffer has been detached"));
          }
          let options;
          try {
            options = convertByobReadOptions(rawOptions, "options");
          } catch (e2) {
            return promiseRejectedWith(e2);
          }
          const min = options.min;
          if (min === 0) {
            return promiseRejectedWith(new TypeError("options.min must be greater than 0"));
          }
          if (!isDataView(view)) {
            if (min > view.length) {
              return promiseRejectedWith(new RangeError("options.min must be less than or equal to view's length"));
            }
          } else if (min > view.byteLength) {
            return promiseRejectedWith(new RangeError("options.min must be less than or equal to view's byteLength"));
          }
          if (this._ownerReadableStream === void 0) {
            return promiseRejectedWith(readerLockException("read from"));
          }
          let resolvePromise;
          let rejectPromise;
          const promise = newPromise((resolve, reject) => {
            resolvePromise = resolve;
            rejectPromise = reject;
          });
          const readIntoRequest = {
            _chunkSteps: (chunk) => resolvePromise({ value: chunk, done: false }),
            _closeSteps: (chunk) => resolvePromise({ value: chunk, done: true }),
            _errorSteps: (e2) => rejectPromise(e2)
          };
          ReadableStreamBYOBReaderRead(this, view, min, readIntoRequest);
          return promise;
        }
        /**
         * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.
         * If the associated stream is errored when the lock is released, the reader will appear errored in the same way
         * from now on; otherwise, the reader will appear closed.
         *
         * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by
         * the reader's {@link ReadableStreamBYOBReader.read | read()} method has not yet been settled. Attempting to
         * do so will throw a `TypeError` and leave the reader locked to the stream.
         */
        releaseLock() {
          if (!IsReadableStreamBYOBReader(this)) {
            throw byobReaderBrandCheckException("releaseLock");
          }
          if (this._ownerReadableStream === void 0) {
            return;
          }
          ReadableStreamBYOBReaderRelease(this);
        }
      }
      Object.defineProperties(ReadableStreamBYOBReader.prototype, {
        cancel: { enumerable: true },
        read: { enumerable: true },
        releaseLock: { enumerable: true },
        closed: { enumerable: true }
      });
      setFunctionName(ReadableStreamBYOBReader.prototype.cancel, "cancel");
      setFunctionName(ReadableStreamBYOBReader.prototype.read, "read");
      setFunctionName(ReadableStreamBYOBReader.prototype.releaseLock, "releaseLock");
      if (typeof Symbol.toStringTag === "symbol") {
        Object.defineProperty(ReadableStreamBYOBReader.prototype, Symbol.toStringTag, {
          value: "ReadableStreamBYOBReader",
          configurable: true
        });
      }
      function IsReadableStreamBYOBReader(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_readIntoRequests")) {
          return false;
        }
        return x2 instanceof ReadableStreamBYOBReader;
      }
      function ReadableStreamBYOBReaderRead(reader, view, min, readIntoRequest) {
        const stream = reader._ownerReadableStream;
        stream._disturbed = true;
        if (stream._state === "errored") {
          readIntoRequest._errorSteps(stream._storedError);
        } else {
          ReadableByteStreamControllerPullInto(stream._readableStreamController, view, min, readIntoRequest);
        }
      }
      function ReadableStreamBYOBReaderRelease(reader) {
        ReadableStreamReaderGenericRelease(reader);
        const e2 = new TypeError("Reader was released");
        ReadableStreamBYOBReaderErrorReadIntoRequests(reader, e2);
      }
      function ReadableStreamBYOBReaderErrorReadIntoRequests(reader, e2) {
        const readIntoRequests = reader._readIntoRequests;
        reader._readIntoRequests = new SimpleQueue();
        readIntoRequests.forEach((readIntoRequest) => {
          readIntoRequest._errorSteps(e2);
        });
      }
      function byobReaderBrandCheckException(name) {
        return new TypeError(`ReadableStreamBYOBReader.prototype.${name} can only be used on a ReadableStreamBYOBReader`);
      }
      function ExtractHighWaterMark(strategy, defaultHWM) {
        const { highWaterMark } = strategy;
        if (highWaterMark === void 0) {
          return defaultHWM;
        }
        if (NumberIsNaN(highWaterMark) || highWaterMark < 0) {
          throw new RangeError("Invalid highWaterMark");
        }
        return highWaterMark;
      }
      function ExtractSizeAlgorithm(strategy) {
        const { size } = strategy;
        if (!size) {
          return () => 1;
        }
        return size;
      }
      function convertQueuingStrategy(init, context) {
        assertDictionary(init, context);
        const highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;
        const size = init === null || init === void 0 ? void 0 : init.size;
        return {
          highWaterMark: highWaterMark === void 0 ? void 0 : convertUnrestrictedDouble(highWaterMark),
          size: size === void 0 ? void 0 : convertQueuingStrategySize(size, `${context} has member 'size' that`)
        };
      }
      function convertQueuingStrategySize(fn, context) {
        assertFunction(fn, context);
        return (chunk) => convertUnrestrictedDouble(fn(chunk));
      }
      function convertUnderlyingSink(original, context) {
        assertDictionary(original, context);
        const abort = original === null || original === void 0 ? void 0 : original.abort;
        const close = original === null || original === void 0 ? void 0 : original.close;
        const start = original === null || original === void 0 ? void 0 : original.start;
        const type = original === null || original === void 0 ? void 0 : original.type;
        const write = original === null || original === void 0 ? void 0 : original.write;
        return {
          abort: abort === void 0 ? void 0 : convertUnderlyingSinkAbortCallback(abort, original, `${context} has member 'abort' that`),
          close: close === void 0 ? void 0 : convertUnderlyingSinkCloseCallback(close, original, `${context} has member 'close' that`),
          start: start === void 0 ? void 0 : convertUnderlyingSinkStartCallback(start, original, `${context} has member 'start' that`),
          write: write === void 0 ? void 0 : convertUnderlyingSinkWriteCallback(write, original, `${context} has member 'write' that`),
          type
        };
      }
      function convertUnderlyingSinkAbortCallback(fn, original, context) {
        assertFunction(fn, context);
        return (reason) => promiseCall(fn, original, [reason]);
      }
      function convertUnderlyingSinkCloseCallback(fn, original, context) {
        assertFunction(fn, context);
        return () => promiseCall(fn, original, []);
      }
      function convertUnderlyingSinkStartCallback(fn, original, context) {
        assertFunction(fn, context);
        return (controller) => reflectCall(fn, original, [controller]);
      }
      function convertUnderlyingSinkWriteCallback(fn, original, context) {
        assertFunction(fn, context);
        return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);
      }
      function assertWritableStream(x2, context) {
        if (!IsWritableStream(x2)) {
          throw new TypeError(`${context} is not a WritableStream.`);
        }
      }
      function isAbortSignal2(value) {
        if (typeof value !== "object" || value === null) {
          return false;
        }
        try {
          return typeof value.aborted === "boolean";
        } catch (_a2) {
          return false;
        }
      }
      const supportsAbortController = typeof AbortController === "function";
      function createAbortController() {
        if (supportsAbortController) {
          return new AbortController();
        }
        return void 0;
      }
      class WritableStream {
        constructor(rawUnderlyingSink = {}, rawStrategy = {}) {
          if (rawUnderlyingSink === void 0) {
            rawUnderlyingSink = null;
          } else {
            assertObject(rawUnderlyingSink, "First parameter");
          }
          const strategy = convertQueuingStrategy(rawStrategy, "Second parameter");
          const underlyingSink = convertUnderlyingSink(rawUnderlyingSink, "First parameter");
          InitializeWritableStream(this);
          const type = underlyingSink.type;
          if (type !== void 0) {
            throw new RangeError("Invalid type is specified");
          }
          const sizeAlgorithm = ExtractSizeAlgorithm(strategy);
          const highWaterMark = ExtractHighWaterMark(strategy, 1);
          SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);
        }
        /**
         * Returns whether or not the writable stream is locked to a writer.
         */
        get locked() {
          if (!IsWritableStream(this)) {
            throw streamBrandCheckException$2("locked");
          }
          return IsWritableStreamLocked(this);
        }
        /**
         * Aborts the stream, signaling that the producer can no longer successfully write to the stream and it is to be
         * immediately moved to an errored state, with any queued-up writes discarded. This will also execute any abort
         * mechanism of the underlying sink.
         *
         * The returned promise will fulfill if the stream shuts down successfully, or reject if the underlying sink signaled
         * that there was an error doing so. Additionally, it will reject with a `TypeError` (without attempting to cancel
         * the stream) if the stream is currently locked.
         */
        abort(reason = void 0) {
          if (!IsWritableStream(this)) {
            return promiseRejectedWith(streamBrandCheckException$2("abort"));
          }
          if (IsWritableStreamLocked(this)) {
            return promiseRejectedWith(new TypeError("Cannot abort a stream that already has a writer"));
          }
          return WritableStreamAbort(this, reason);
        }
        /**
         * Closes the stream. The underlying sink will finish processing any previously-written chunks, before invoking its
         * close behavior. During this time any further attempts to write will fail (without erroring the stream).
         *
         * The method returns a promise that will fulfill if all remaining chunks are successfully written and the stream
         * successfully closes, or rejects if an error is encountered during this process. Additionally, it will reject with
         * a `TypeError` (without attempting to cancel the stream) if the stream is currently locked.
         */
        close() {
          if (!IsWritableStream(this)) {
            return promiseRejectedWith(streamBrandCheckException$2("close"));
          }
          if (IsWritableStreamLocked(this)) {
            return promiseRejectedWith(new TypeError("Cannot close a stream that already has a writer"));
          }
          if (WritableStreamCloseQueuedOrInFlight(this)) {
            return promiseRejectedWith(new TypeError("Cannot close an already-closing stream"));
          }
          return WritableStreamClose(this);
        }
        /**
         * Creates a {@link WritableStreamDefaultWriter | writer} and locks the stream to the new writer. While the stream
         * is locked, no other writer can be acquired until this one is released.
         *
         * This functionality is especially useful for creating abstractions that desire the ability to write to a stream
         * without interruption or interleaving. By getting a writer for the stream, you can ensure nobody else can write at
         * the same time, which would cause the resulting written data to be unpredictable and probably useless.
         */
        getWriter() {
          if (!IsWritableStream(this)) {
            throw streamBrandCheckException$2("getWriter");
          }
          return AcquireWritableStreamDefaultWriter(this);
        }
      }
      Object.defineProperties(WritableStream.prototype, {
        abort: { enumerable: true },
        close: { enumerable: true },
        getWriter: { enumerable: true },
        locked: { enumerable: true }
      });
      setFunctionName(WritableStream.prototype.abort, "abort");
      setFunctionName(WritableStream.prototype.close, "close");
      setFunctionName(WritableStream.prototype.getWriter, "getWriter");
      if (typeof Symbol.toStringTag === "symbol") {
        Object.defineProperty(WritableStream.prototype, Symbol.toStringTag, {
          value: "WritableStream",
          configurable: true
        });
      }
      function AcquireWritableStreamDefaultWriter(stream) {
        return new WritableStreamDefaultWriter(stream);
      }
      function CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {
        const stream = Object.create(WritableStream.prototype);
        InitializeWritableStream(stream);
        const controller = Object.create(WritableStreamDefaultController.prototype);
        SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
        return stream;
      }
      function InitializeWritableStream(stream) {
        stream._state = "writable";
        stream._storedError = void 0;
        stream._writer = void 0;
        stream._writableStreamController = void 0;
        stream._writeRequests = new SimpleQueue();
        stream._inFlightWriteRequest = void 0;
        stream._closeRequest = void 0;
        stream._inFlightCloseRequest = void 0;
        stream._pendingAbortRequest = void 0;
        stream._backpressure = false;
      }
      function IsWritableStream(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_writableStreamController")) {
          return false;
        }
        return x2 instanceof WritableStream;
      }
      function IsWritableStreamLocked(stream) {
        if (stream._writer === void 0) {
          return false;
        }
        return true;
      }
      function WritableStreamAbort(stream, reason) {
        var _a2;
        if (stream._state === "closed" || stream._state === "errored") {
          return promiseResolvedWith(void 0);
        }
        stream._writableStreamController._abortReason = reason;
        (_a2 = stream._writableStreamController._abortController) === null || _a2 === void 0 ? void 0 : _a2.abort(reason);
        const state = stream._state;
        if (state === "closed" || state === "errored") {
          return promiseResolvedWith(void 0);
        }
        if (stream._pendingAbortRequest !== void 0) {
          return stream._pendingAbortRequest._promise;
        }
        let wasAlreadyErroring = false;
        if (state === "erroring") {
          wasAlreadyErroring = true;
          reason = void 0;
        }
        const promise = newPromise((resolve, reject) => {
          stream._pendingAbortRequest = {
            _promise: void 0,
            _resolve: resolve,
            _reject: reject,
            _reason: reason,
            _wasAlreadyErroring: wasAlreadyErroring
          };
        });
        stream._pendingAbortRequest._promise = promise;
        if (!wasAlreadyErroring) {
          WritableStreamStartErroring(stream, reason);
        }
        return promise;
      }
      function WritableStreamClose(stream) {
        const state = stream._state;
        if (state === "closed" || state === "errored") {
          return promiseRejectedWith(new TypeError(`The stream (in ${state} state) is not in the writable state and cannot be closed`));
        }
        const promise = newPromise((resolve, reject) => {
          const closeRequest = {
            _resolve: resolve,
            _reject: reject
          };
          stream._closeRequest = closeRequest;
        });
        const writer = stream._writer;
        if (writer !== void 0 && stream._backpressure && state === "writable") {
          defaultWriterReadyPromiseResolve(writer);
        }
        WritableStreamDefaultControllerClose(stream._writableStreamController);
        return promise;
      }
      function WritableStreamAddWriteRequest(stream) {
        const promise = newPromise((resolve, reject) => {
          const writeRequest = {
            _resolve: resolve,
            _reject: reject
          };
          stream._writeRequests.push(writeRequest);
        });
        return promise;
      }
      function WritableStreamDealWithRejection(stream, error) {
        const state = stream._state;
        if (state === "writable") {
          WritableStreamStartErroring(stream, error);
          return;
        }
        WritableStreamFinishErroring(stream);
      }
      function WritableStreamStartErroring(stream, reason) {
        const controller = stream._writableStreamController;
        stream._state = "erroring";
        stream._storedError = reason;
        const writer = stream._writer;
        if (writer !== void 0) {
          WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);
        }
        if (!WritableStreamHasOperationMarkedInFlight(stream) && controller._started) {
          WritableStreamFinishErroring(stream);
        }
      }
      function WritableStreamFinishErroring(stream) {
        stream._state = "errored";
        stream._writableStreamController[ErrorSteps]();
        const storedError = stream._storedError;
        stream._writeRequests.forEach((writeRequest) => {
          writeRequest._reject(storedError);
        });
        stream._writeRequests = new SimpleQueue();
        if (stream._pendingAbortRequest === void 0) {
          WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
          return;
        }
        const abortRequest = stream._pendingAbortRequest;
        stream._pendingAbortRequest = void 0;
        if (abortRequest._wasAlreadyErroring) {
          abortRequest._reject(storedError);
          WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
          return;
        }
        const promise = stream._writableStreamController[AbortSteps](abortRequest._reason);
        uponPromise(promise, () => {
          abortRequest._resolve();
          WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
          return null;
        }, (reason) => {
          abortRequest._reject(reason);
          WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
          return null;
        });
      }
      function WritableStreamFinishInFlightWrite(stream) {
        stream._inFlightWriteRequest._resolve(void 0);
        stream._inFlightWriteRequest = void 0;
      }
      function WritableStreamFinishInFlightWriteWithError(stream, error) {
        stream._inFlightWriteRequest._reject(error);
        stream._inFlightWriteRequest = void 0;
        WritableStreamDealWithRejection(stream, error);
      }
      function WritableStreamFinishInFlightClose(stream) {
        stream._inFlightCloseRequest._resolve(void 0);
        stream._inFlightCloseRequest = void 0;
        const state = stream._state;
        if (state === "erroring") {
          stream._storedError = void 0;
          if (stream._pendingAbortRequest !== void 0) {
            stream._pendingAbortRequest._resolve();
            stream._pendingAbortRequest = void 0;
          }
        }
        stream._state = "closed";
        const writer = stream._writer;
        if (writer !== void 0) {
          defaultWriterClosedPromiseResolve(writer);
        }
      }
      function WritableStreamFinishInFlightCloseWithError(stream, error) {
        stream._inFlightCloseRequest._reject(error);
        stream._inFlightCloseRequest = void 0;
        if (stream._pendingAbortRequest !== void 0) {
          stream._pendingAbortRequest._reject(error);
          stream._pendingAbortRequest = void 0;
        }
        WritableStreamDealWithRejection(stream, error);
      }
      function WritableStreamCloseQueuedOrInFlight(stream) {
        if (stream._closeRequest === void 0 && stream._inFlightCloseRequest === void 0) {
          return false;
        }
        return true;
      }
      function WritableStreamHasOperationMarkedInFlight(stream) {
        if (stream._inFlightWriteRequest === void 0 && stream._inFlightCloseRequest === void 0) {
          return false;
        }
        return true;
      }
      function WritableStreamMarkCloseRequestInFlight(stream) {
        stream._inFlightCloseRequest = stream._closeRequest;
        stream._closeRequest = void 0;
      }
      function WritableStreamMarkFirstWriteRequestInFlight(stream) {
        stream._inFlightWriteRequest = stream._writeRequests.shift();
      }
      function WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {
        if (stream._closeRequest !== void 0) {
          stream._closeRequest._reject(stream._storedError);
          stream._closeRequest = void 0;
        }
        const writer = stream._writer;
        if (writer !== void 0) {
          defaultWriterClosedPromiseReject(writer, stream._storedError);
        }
      }
      function WritableStreamUpdateBackpressure(stream, backpressure) {
        const writer = stream._writer;
        if (writer !== void 0 && backpressure !== stream._backpressure) {
          if (backpressure) {
            defaultWriterReadyPromiseReset(writer);
          } else {
            defaultWriterReadyPromiseResolve(writer);
          }
        }
        stream._backpressure = backpressure;
      }
      class WritableStreamDefaultWriter {
        constructor(stream) {
          assertRequiredArgument(stream, 1, "WritableStreamDefaultWriter");
          assertWritableStream(stream, "First parameter");
          if (IsWritableStreamLocked(stream)) {
            throw new TypeError("This stream has already been locked for exclusive writing by another writer");
          }
          this._ownerWritableStream = stream;
          stream._writer = this;
          const state = stream._state;
          if (state === "writable") {
            if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._backpressure) {
              defaultWriterReadyPromiseInitialize(this);
            } else {
              defaultWriterReadyPromiseInitializeAsResolved(this);
            }
            defaultWriterClosedPromiseInitialize(this);
          } else if (state === "erroring") {
            defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);
            defaultWriterClosedPromiseInitialize(this);
          } else if (state === "closed") {
            defaultWriterReadyPromiseInitializeAsResolved(this);
            defaultWriterClosedPromiseInitializeAsResolved(this);
          } else {
            const storedError = stream._storedError;
            defaultWriterReadyPromiseInitializeAsRejected(this, storedError);
            defaultWriterClosedPromiseInitializeAsRejected(this, storedError);
          }
        }
        /**
         * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or
         * the writer’s lock is released before the stream finishes closing.
         */
        get closed() {
          if (!IsWritableStreamDefaultWriter(this)) {
            return promiseRejectedWith(defaultWriterBrandCheckException("closed"));
          }
          return this._closedPromise;
        }
        /**
         * Returns the desired size to fill the stream’s internal queue. It can be negative, if the queue is over-full.
         * A producer can use this information to determine the right amount of data to write.
         *
         * It will be `null` if the stream cannot be successfully written to (due to either being errored, or having an abort
         * queued up). It will return zero if the stream is closed. And the getter will throw an exception if invoked when
         * the writer’s lock is released.
         */
        get desiredSize() {
          if (!IsWritableStreamDefaultWriter(this)) {
            throw defaultWriterBrandCheckException("desiredSize");
          }
          if (this._ownerWritableStream === void 0) {
            throw defaultWriterLockException("desiredSize");
          }
          return WritableStreamDefaultWriterGetDesiredSize(this);
        }
        /**
         * Returns a promise that will be fulfilled when the desired size to fill the stream’s internal queue transitions
         * from non-positive to positive, signaling that it is no longer applying backpressure. Once the desired size dips
         * back to zero or below, the getter will return a new promise that stays pending until the next transition.
         *
         * If the stream becomes errored or aborted, or the writer’s lock is released, the returned promise will become
         * rejected.
         */
        get ready() {
          if (!IsWritableStreamDefaultWriter(this)) {
            return promiseRejectedWith(defaultWriterBrandCheckException("ready"));
          }
          return this._readyPromise;
        }
        /**
         * If the reader is active, behaves the same as {@link WritableStream.abort | stream.abort(reason)}.
         */
        abort(reason = void 0) {
          if (!IsWritableStreamDefaultWriter(this)) {
            return promiseRejectedWith(defaultWriterBrandCheckException("abort"));
          }
          if (this._ownerWritableStream === void 0) {
            return promiseRejectedWith(defaultWriterLockException("abort"));
          }
          return WritableStreamDefaultWriterAbort(this, reason);
        }
        /**
         * If the reader is active, behaves the same as {@link WritableStream.close | stream.close()}.
         */
        close() {
          if (!IsWritableStreamDefaultWriter(this)) {
            return promiseRejectedWith(defaultWriterBrandCheckException("close"));
          }
          const stream = this._ownerWritableStream;
          if (stream === void 0) {
            return promiseRejectedWith(defaultWriterLockException("close"));
          }
          if (WritableStreamCloseQueuedOrInFlight(stream)) {
            return promiseRejectedWith(new TypeError("Cannot close an already-closing stream"));
          }
          return WritableStreamDefaultWriterClose(this);
        }
        /**
         * Releases the writer’s lock on the corresponding stream. After the lock is released, the writer is no longer active.
         * If the associated stream is errored when the lock is released, the writer will appear errored in the same way from
         * now on; otherwise, the writer will appear closed.
         *
         * Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the
         * promises returned from previous calls to {@link WritableStreamDefaultWriter.write | write()} have not yet settled).
         * It’s not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents
         * other producers from writing in an interleaved manner.
         */
        releaseLock() {
          if (!IsWritableStreamDefaultWriter(this)) {
            throw defaultWriterBrandCheckException("releaseLock");
          }
          const stream = this._ownerWritableStream;
          if (stream === void 0) {
            return;
          }
          WritableStreamDefaultWriterRelease(this);
        }
        write(chunk = void 0) {
          if (!IsWritableStreamDefaultWriter(this)) {
            return promiseRejectedWith(defaultWriterBrandCheckException("write"));
          }
          if (this._ownerWritableStream === void 0) {
            return promiseRejectedWith(defaultWriterLockException("write to"));
          }
          return WritableStreamDefaultWriterWrite(this, chunk);
        }
      }
      Object.defineProperties(WritableStreamDefaultWriter.prototype, {
        abort: { enumerable: true },
        close: { enumerable: true },
        releaseLock: { enumerable: true },
        write: { enumerable: true },
        closed: { enumerable: true },
        desiredSize: { enumerable: true },
        ready: { enumerable: true }
      });
      setFunctionName(WritableStreamDefaultWriter.prototype.abort, "abort");
      setFunctionName(WritableStreamDefaultWriter.prototype.close, "close");
      setFunctionName(WritableStreamDefaultWriter.prototype.releaseLock, "releaseLock");
      setFunctionName(WritableStreamDefaultWriter.prototype.write, "write");
      if (typeof Symbol.toStringTag === "symbol") {
        Object.defineProperty(WritableStreamDefaultWriter.prototype, Symbol.toStringTag, {
          value: "WritableStreamDefaultWriter",
          configurable: true
        });
      }
      function IsWritableStreamDefaultWriter(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_ownerWritableStream")) {
          return false;
        }
        return x2 instanceof WritableStreamDefaultWriter;
      }
      function WritableStreamDefaultWriterAbort(writer, reason) {
        const stream = writer._ownerWritableStream;
        return WritableStreamAbort(stream, reason);
      }
      function WritableStreamDefaultWriterClose(writer) {
        const stream = writer._ownerWritableStream;
        return WritableStreamClose(stream);
      }
      function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {
        const stream = writer._ownerWritableStream;
        const state = stream._state;
        if (WritableStreamCloseQueuedOrInFlight(stream) || state === "closed") {
          return promiseResolvedWith(void 0);
        }
        if (state === "errored") {
          return promiseRejectedWith(stream._storedError);
        }
        return WritableStreamDefaultWriterClose(writer);
      }
      function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {
        if (writer._closedPromiseState === "pending") {
          defaultWriterClosedPromiseReject(writer, error);
        } else {
          defaultWriterClosedPromiseResetToRejected(writer, error);
        }
      }
      function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {
        if (writer._readyPromiseState === "pending") {
          defaultWriterReadyPromiseReject(writer, error);
        } else {
          defaultWriterReadyPromiseResetToRejected(writer, error);
        }
      }
      function WritableStreamDefaultWriterGetDesiredSize(writer) {
        const stream = writer._ownerWritableStream;
        const state = stream._state;
        if (state === "errored" || state === "erroring") {
          return null;
        }
        if (state === "closed") {
          return 0;
        }
        return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);
      }
      function WritableStreamDefaultWriterRelease(writer) {
        const stream = writer._ownerWritableStream;
        const releasedError = new TypeError(`Writer was released and can no longer be used to monitor the stream's closedness`);
        WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);
        WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);
        stream._writer = void 0;
        writer._ownerWritableStream = void 0;
      }
      function WritableStreamDefaultWriterWrite(writer, chunk) {
        const stream = writer._ownerWritableStream;
        const controller = stream._writableStreamController;
        const chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);
        if (stream !== writer._ownerWritableStream) {
          return promiseRejectedWith(defaultWriterLockException("write to"));
        }
        const state = stream._state;
        if (state === "errored") {
          return promiseRejectedWith(stream._storedError);
        }
        if (WritableStreamCloseQueuedOrInFlight(stream) || state === "closed") {
          return promiseRejectedWith(new TypeError("The stream is closing or closed and cannot be written to"));
        }
        if (state === "erroring") {
          return promiseRejectedWith(stream._storedError);
        }
        const promise = WritableStreamAddWriteRequest(stream);
        WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);
        return promise;
      }
      const closeSentinel = {};
      class WritableStreamDefaultController {
        constructor() {
          throw new TypeError("Illegal constructor");
        }
        /**
         * The reason which was passed to `WritableStream.abort(reason)` when the stream was aborted.
         *
         * @deprecated
         *  This property has been removed from the specification, see https://github.com/whatwg/streams/pull/1177.
         *  Use {@link WritableStreamDefaultController.signal}'s `reason` instead.
         */
        get abortReason() {
          if (!IsWritableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$2("abortReason");
          }
          return this._abortReason;
        }
        /**
         * An `AbortSignal` that can be used to abort the pending write or close operation when the stream is aborted.
         */
        get signal() {
          if (!IsWritableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$2("signal");
          }
          if (this._abortController === void 0) {
            throw new TypeError("WritableStreamDefaultController.prototype.signal is not supported");
          }
          return this._abortController.signal;
        }
        /**
         * Closes the controlled writable stream, making all future interactions with it fail with the given error `e`.
         *
         * This method is rarely used, since usually it suffices to return a rejected promise from one of the underlying
         * sink's methods. However, it can be useful for suddenly shutting down a stream in response to an event outside the
         * normal lifecycle of interactions with the underlying sink.
         */
        error(e2 = void 0) {
          if (!IsWritableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$2("error");
          }
          const state = this._controlledWritableStream._state;
          if (state !== "writable") {
            return;
          }
          WritableStreamDefaultControllerError(this, e2);
        }
        /** @internal */
        [AbortSteps](reason) {
          const result = this._abortAlgorithm(reason);
          WritableStreamDefaultControllerClearAlgorithms(this);
          return result;
        }
        /** @internal */
        [ErrorSteps]() {
          ResetQueue(this);
        }
      }
      Object.defineProperties(WritableStreamDefaultController.prototype, {
        abortReason: { enumerable: true },
        signal: { enumerable: true },
        error: { enumerable: true }
      });
      if (typeof Symbol.toStringTag === "symbol") {
        Object.defineProperty(WritableStreamDefaultController.prototype, Symbol.toStringTag, {
          value: "WritableStreamDefaultController",
          configurable: true
        });
      }
      function IsWritableStreamDefaultController(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_controlledWritableStream")) {
          return false;
        }
        return x2 instanceof WritableStreamDefaultController;
      }
      function SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {
        controller._controlledWritableStream = stream;
        stream._writableStreamController = controller;
        controller._queue = void 0;
        controller._queueTotalSize = void 0;
        ResetQueue(controller);
        controller._abortReason = void 0;
        controller._abortController = createAbortController();
        controller._started = false;
        controller._strategySizeAlgorithm = sizeAlgorithm;
        controller._strategyHWM = highWaterMark;
        controller._writeAlgorithm = writeAlgorithm;
        controller._closeAlgorithm = closeAlgorithm;
        controller._abortAlgorithm = abortAlgorithm;
        const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
        WritableStreamUpdateBackpressure(stream, backpressure);
        const startResult = startAlgorithm();
        const startPromise = promiseResolvedWith(startResult);
        uponPromise(startPromise, () => {
          controller._started = true;
          WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
          return null;
        }, (r2) => {
          controller._started = true;
          WritableStreamDealWithRejection(stream, r2);
          return null;
        });
      }
      function SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {
        const controller = Object.create(WritableStreamDefaultController.prototype);
        let startAlgorithm;
        let writeAlgorithm;
        let closeAlgorithm;
        let abortAlgorithm;
        if (underlyingSink.start !== void 0) {
          startAlgorithm = () => underlyingSink.start(controller);
        } else {
          startAlgorithm = () => void 0;
        }
        if (underlyingSink.write !== void 0) {
          writeAlgorithm = (chunk) => underlyingSink.write(chunk, controller);
        } else {
          writeAlgorithm = () => promiseResolvedWith(void 0);
        }
        if (underlyingSink.close !== void 0) {
          closeAlgorithm = () => underlyingSink.close();
        } else {
          closeAlgorithm = () => promiseResolvedWith(void 0);
        }
        if (underlyingSink.abort !== void 0) {
          abortAlgorithm = (reason) => underlyingSink.abort(reason);
        } else {
          abortAlgorithm = () => promiseResolvedWith(void 0);
        }
        SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
      }
      function WritableStreamDefaultControllerClearAlgorithms(controller) {
        controller._writeAlgorithm = void 0;
        controller._closeAlgorithm = void 0;
        controller._abortAlgorithm = void 0;
        controller._strategySizeAlgorithm = void 0;
      }
      function WritableStreamDefaultControllerClose(controller) {
        EnqueueValueWithSize(controller, closeSentinel, 0);
        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
      }
      function WritableStreamDefaultControllerGetChunkSize(controller, chunk) {
        try {
          return controller._strategySizeAlgorithm(chunk);
        } catch (chunkSizeE) {
          WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);
          return 1;
        }
      }
      function WritableStreamDefaultControllerGetDesiredSize(controller) {
        return controller._strategyHWM - controller._queueTotalSize;
      }
      function WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {
        try {
          EnqueueValueWithSize(controller, chunk, chunkSize);
        } catch (enqueueE) {
          WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);
          return;
        }
        const stream = controller._controlledWritableStream;
        if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._state === "writable") {
          const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
          WritableStreamUpdateBackpressure(stream, backpressure);
        }
        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
      }
      function WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {
        const stream = controller._controlledWritableStream;
        if (!controller._started) {
          return;
        }
        if (stream._inFlightWriteRequest !== void 0) {
          return;
        }
        const state = stream._state;
        if (state === "erroring") {
          WritableStreamFinishErroring(stream);
          return;
        }
        if (controller._queue.length === 0) {
          return;
        }
        const value = PeekQueueValue(controller);
        if (value === closeSentinel) {
          WritableStreamDefaultControllerProcessClose(controller);
        } else {
          WritableStreamDefaultControllerProcessWrite(controller, value);
        }
      }
      function WritableStreamDefaultControllerErrorIfNeeded(controller, error) {
        if (controller._controlledWritableStream._state === "writable") {
          WritableStreamDefaultControllerError(controller, error);
        }
      }
      function WritableStreamDefaultControllerProcessClose(controller) {
        const stream = controller._controlledWritableStream;
        WritableStreamMarkCloseRequestInFlight(stream);
        DequeueValue(controller);
        const sinkClosePromise = controller._closeAlgorithm();
        WritableStreamDefaultControllerClearAlgorithms(controller);
        uponPromise(sinkClosePromise, () => {
          WritableStreamFinishInFlightClose(stream);
          return null;
        }, (reason) => {
          WritableStreamFinishInFlightCloseWithError(stream, reason);
          return null;
        });
      }
      function WritableStreamDefaultControllerProcessWrite(controller, chunk) {
        const stream = controller._controlledWritableStream;
        WritableStreamMarkFirstWriteRequestInFlight(stream);
        const sinkWritePromise = controller._writeAlgorithm(chunk);
        uponPromise(sinkWritePromise, () => {
          WritableStreamFinishInFlightWrite(stream);
          const state = stream._state;
          DequeueValue(controller);
          if (!WritableStreamCloseQueuedOrInFlight(stream) && state === "writable") {
            const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
            WritableStreamUpdateBackpressure(stream, backpressure);
          }
          WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
          return null;
        }, (reason) => {
          if (stream._state === "writable") {
            WritableStreamDefaultControllerClearAlgorithms(controller);
          }
          WritableStreamFinishInFlightWriteWithError(stream, reason);
          return null;
        });
      }
      function WritableStreamDefaultControllerGetBackpressure(controller) {
        const desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);
        return desiredSize <= 0;
      }
      function WritableStreamDefaultControllerError(controller, error) {
        const stream = controller._controlledWritableStream;
        WritableStreamDefaultControllerClearAlgorithms(controller);
        WritableStreamStartErroring(stream, error);
      }
      function streamBrandCheckException$2(name) {
        return new TypeError(`WritableStream.prototype.${name} can only be used on a WritableStream`);
      }
      function defaultControllerBrandCheckException$2(name) {
        return new TypeError(`WritableStreamDefaultController.prototype.${name} can only be used on a WritableStreamDefaultController`);
      }
      function defaultWriterBrandCheckException(name) {
        return new TypeError(`WritableStreamDefaultWriter.prototype.${name} can only be used on a WritableStreamDefaultWriter`);
      }
      function defaultWriterLockException(name) {
        return new TypeError("Cannot " + name + " a stream using a released writer");
      }
      function defaultWriterClosedPromiseInitialize(writer) {
        writer._closedPromise = newPromise((resolve, reject) => {
          writer._closedPromise_resolve = resolve;
          writer._closedPromise_reject = reject;
          writer._closedPromiseState = "pending";
        });
      }
      function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {
        defaultWriterClosedPromiseInitialize(writer);
        defaultWriterClosedPromiseReject(writer, reason);
      }
      function defaultWriterClosedPromiseInitializeAsResolved(writer) {
        defaultWriterClosedPromiseInitialize(writer);
        defaultWriterClosedPromiseResolve(writer);
      }
      function defaultWriterClosedPromiseReject(writer, reason) {
        if (writer._closedPromise_reject === void 0) {
          return;
        }
        setPromiseIsHandledToTrue(writer._closedPromise);
        writer._closedPromise_reject(reason);
        writer._closedPromise_resolve = void 0;
        writer._closedPromise_reject = void 0;
        writer._closedPromiseState = "rejected";
      }
      function defaultWriterClosedPromiseResetToRejected(writer, reason) {
        defaultWriterClosedPromiseInitializeAsRejected(writer, reason);
      }
      function defaultWriterClosedPromiseResolve(writer) {
        if (writer._closedPromise_resolve === void 0) {
          return;
        }
        writer._closedPromise_resolve(void 0);
        writer._closedPromise_resolve = void 0;
        writer._closedPromise_reject = void 0;
        writer._closedPromiseState = "resolved";
      }
      function defaultWriterReadyPromiseInitialize(writer) {
        writer._readyPromise = newPromise((resolve, reject) => {
          writer._readyPromise_resolve = resolve;
          writer._readyPromise_reject = reject;
        });
        writer._readyPromiseState = "pending";
      }
      function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {
        defaultWriterReadyPromiseInitialize(writer);
        defaultWriterReadyPromiseReject(writer, reason);
      }
      function defaultWriterReadyPromiseInitializeAsResolved(writer) {
        defaultWriterReadyPromiseInitialize(writer);
        defaultWriterReadyPromiseResolve(writer);
      }
      function defaultWriterReadyPromiseReject(writer, reason) {
        if (writer._readyPromise_reject === void 0) {
          return;
        }
        setPromiseIsHandledToTrue(writer._readyPromise);
        writer._readyPromise_reject(reason);
        writer._readyPromise_resolve = void 0;
        writer._readyPromise_reject = void 0;
        writer._readyPromiseState = "rejected";
      }
      function defaultWriterReadyPromiseReset(writer) {
        defaultWriterReadyPromiseInitialize(writer);
      }
      function defaultWriterReadyPromiseResetToRejected(writer, reason) {
        defaultWriterReadyPromiseInitializeAsRejected(writer, reason);
      }
      function defaultWriterReadyPromiseResolve(writer) {
        if (writer._readyPromise_resolve === void 0) {
          return;
        }
        writer._readyPromise_resolve(void 0);
        writer._readyPromise_resolve = void 0;
        writer._readyPromise_reject = void 0;
        writer._readyPromiseState = "fulfilled";
      }
      function getGlobals() {
        if (typeof globalThis !== "undefined") {
          return globalThis;
        } else if (typeof self !== "undefined") {
          return self;
        } else if (typeof global !== "undefined") {
          return global;
        }
        return void 0;
      }
      const globals = getGlobals();
      function isDOMExceptionConstructor(ctor) {
        if (!(typeof ctor === "function" || typeof ctor === "object")) {
          return false;
        }
        if (ctor.name !== "DOMException") {
          return false;
        }
        try {
          new ctor();
          return true;
        } catch (_a2) {
          return false;
        }
      }
      function getFromGlobal() {
        const ctor = globals === null || globals === void 0 ? void 0 : globals.DOMException;
        return isDOMExceptionConstructor(ctor) ? ctor : void 0;
      }
      function createPolyfill() {
        const ctor = function DOMException3(message, name) {
          this.message = message || "";
          this.name = name || "Error";
          if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
          }
        };
        setFunctionName(ctor, "DOMException");
        ctor.prototype = Object.create(Error.prototype);
        Object.defineProperty(ctor.prototype, "constructor", { value: ctor, writable: true, configurable: true });
        return ctor;
      }
      const DOMException2 = getFromGlobal() || createPolyfill();
      function ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {
        const reader = AcquireReadableStreamDefaultReader(source);
        const writer = AcquireWritableStreamDefaultWriter(dest);
        source._disturbed = true;
        let shuttingDown = false;
        let currentWrite = promiseResolvedWith(void 0);
        return newPromise((resolve, reject) => {
          let abortAlgorithm;
          if (signal !== void 0) {
            abortAlgorithm = () => {
              const error = signal.reason !== void 0 ? signal.reason : new DOMException2("Aborted", "AbortError");
              const actions = [];
              if (!preventAbort) {
                actions.push(() => {
                  if (dest._state === "writable") {
                    return WritableStreamAbort(dest, error);
                  }
                  return promiseResolvedWith(void 0);
                });
              }
              if (!preventCancel) {
                actions.push(() => {
                  if (source._state === "readable") {
                    return ReadableStreamCancel(source, error);
                  }
                  return promiseResolvedWith(void 0);
                });
              }
              shutdownWithAction(() => Promise.all(actions.map((action) => action())), true, error);
            };
            if (signal.aborted) {
              abortAlgorithm();
              return;
            }
            signal.addEventListener("abort", abortAlgorithm);
          }
          function pipeLoop() {
            return newPromise((resolveLoop, rejectLoop) => {
              function next(done) {
                if (done) {
                  resolveLoop();
                } else {
                  PerformPromiseThen(pipeStep(), next, rejectLoop);
                }
              }
              next(false);
            });
          }
          function pipeStep() {
            if (shuttingDown) {
              return promiseResolvedWith(true);
            }
            return PerformPromiseThen(writer._readyPromise, () => {
              return newPromise((resolveRead, rejectRead) => {
                ReadableStreamDefaultReaderRead(reader, {
                  _chunkSteps: (chunk) => {
                    currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), void 0, noop2);
                    resolveRead(false);
                  },
                  _closeSteps: () => resolveRead(true),
                  _errorSteps: rejectRead
                });
              });
            });
          }
          isOrBecomesErrored(source, reader._closedPromise, (storedError) => {
            if (!preventAbort) {
              shutdownWithAction(() => WritableStreamAbort(dest, storedError), true, storedError);
            } else {
              shutdown(true, storedError);
            }
            return null;
          });
          isOrBecomesErrored(dest, writer._closedPromise, (storedError) => {
            if (!preventCancel) {
              shutdownWithAction(() => ReadableStreamCancel(source, storedError), true, storedError);
            } else {
              shutdown(true, storedError);
            }
            return null;
          });
          isOrBecomesClosed(source, reader._closedPromise, () => {
            if (!preventClose) {
              shutdownWithAction(() => WritableStreamDefaultWriterCloseWithErrorPropagation(writer));
            } else {
              shutdown();
            }
            return null;
          });
          if (WritableStreamCloseQueuedOrInFlight(dest) || dest._state === "closed") {
            const destClosed = new TypeError("the destination writable stream closed before all data could be piped to it");
            if (!preventCancel) {
              shutdownWithAction(() => ReadableStreamCancel(source, destClosed), true, destClosed);
            } else {
              shutdown(true, destClosed);
            }
          }
          setPromiseIsHandledToTrue(pipeLoop());
          function waitForWritesToFinish() {
            const oldCurrentWrite = currentWrite;
            return PerformPromiseThen(currentWrite, () => oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : void 0);
          }
          function isOrBecomesErrored(stream, promise, action) {
            if (stream._state === "errored") {
              action(stream._storedError);
            } else {
              uponRejection(promise, action);
            }
          }
          function isOrBecomesClosed(stream, promise, action) {
            if (stream._state === "closed") {
              action();
            } else {
              uponFulfillment(promise, action);
            }
          }
          function shutdownWithAction(action, originalIsError, originalError) {
            if (shuttingDown) {
              return;
            }
            shuttingDown = true;
            if (dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest)) {
              uponFulfillment(waitForWritesToFinish(), doTheRest);
            } else {
              doTheRest();
            }
            function doTheRest() {
              uponPromise(action(), () => finalize(originalIsError, originalError), (newError) => finalize(true, newError));
              return null;
            }
          }
          function shutdown(isError, error) {
            if (shuttingDown) {
              return;
            }
            shuttingDown = true;
            if (dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest)) {
              uponFulfillment(waitForWritesToFinish(), () => finalize(isError, error));
            } else {
              finalize(isError, error);
            }
          }
          function finalize(isError, error) {
            WritableStreamDefaultWriterRelease(writer);
            ReadableStreamReaderGenericRelease(reader);
            if (signal !== void 0) {
              signal.removeEventListener("abort", abortAlgorithm);
            }
            if (isError) {
              reject(error);
            } else {
              resolve(void 0);
            }
            return null;
          }
        });
      }
      class ReadableStreamDefaultController {
        constructor() {
          throw new TypeError("Illegal constructor");
        }
        /**
         * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is
         * over-full. An underlying source ought to use this information to determine when and how to apply backpressure.
         */
        get desiredSize() {
          if (!IsReadableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$1("desiredSize");
          }
          return ReadableStreamDefaultControllerGetDesiredSize(this);
        }
        /**
         * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from
         * the stream, but once those are read, the stream will become closed.
         */
        close() {
          if (!IsReadableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$1("close");
          }
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
            throw new TypeError("The stream is not in a state that permits close");
          }
          ReadableStreamDefaultControllerClose(this);
        }
        enqueue(chunk = void 0) {
          if (!IsReadableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$1("enqueue");
          }
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
            throw new TypeError("The stream is not in a state that permits enqueue");
          }
          return ReadableStreamDefaultControllerEnqueue(this, chunk);
        }
        /**
         * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.
         */
        error(e2 = void 0) {
          if (!IsReadableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$1("error");
          }
          ReadableStreamDefaultControllerError(this, e2);
        }
        /** @internal */
        [CancelSteps](reason) {
          ResetQueue(this);
          const result = this._cancelAlgorithm(reason);
          ReadableStreamDefaultControllerClearAlgorithms(this);
          return result;
        }
        /** @internal */
        [PullSteps](readRequest) {
          const stream = this._controlledReadableStream;
          if (this._queue.length > 0) {
            const chunk = DequeueValue(this);
            if (this._closeRequested && this._queue.length === 0) {
              ReadableStreamDefaultControllerClearAlgorithms(this);
              ReadableStreamClose(stream);
            } else {
              ReadableStreamDefaultControllerCallPullIfNeeded(this);
            }
            readRequest._chunkSteps(chunk);
          } else {
            ReadableStreamAddReadRequest(stream, readRequest);
            ReadableStreamDefaultControllerCallPullIfNeeded(this);
          }
        }
        /** @internal */
        [ReleaseSteps]() {
        }
      }
      Object.defineProperties(ReadableStreamDefaultController.prototype, {
        close: { enumerable: true },
        enqueue: { enumerable: true },
        error: { enumerable: true },
        desiredSize: { enumerable: true }
      });
      setFunctionName(ReadableStreamDefaultController.prototype.close, "close");
      setFunctionName(ReadableStreamDefaultController.prototype.enqueue, "enqueue");
      setFunctionName(ReadableStreamDefaultController.prototype.error, "error");
      if (typeof Symbol.toStringTag === "symbol") {
        Object.defineProperty(ReadableStreamDefaultController.prototype, Symbol.toStringTag, {
          value: "ReadableStreamDefaultController",
          configurable: true
        });
      }
      function IsReadableStreamDefaultController(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_controlledReadableStream")) {
          return false;
        }
        return x2 instanceof ReadableStreamDefaultController;
      }
      function ReadableStreamDefaultControllerCallPullIfNeeded(controller) {
        const shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);
        if (!shouldPull) {
          return;
        }
        if (controller._pulling) {
          controller._pullAgain = true;
          return;
        }
        controller._pulling = true;
        const pullPromise = controller._pullAlgorithm();
        uponPromise(pullPromise, () => {
          controller._pulling = false;
          if (controller._pullAgain) {
            controller._pullAgain = false;
            ReadableStreamDefaultControllerCallPullIfNeeded(controller);
          }
          return null;
        }, (e2) => {
          ReadableStreamDefaultControllerError(controller, e2);
          return null;
        });
      }
      function ReadableStreamDefaultControllerShouldCallPull(controller) {
        const stream = controller._controlledReadableStream;
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
          return false;
        }
        if (!controller._started) {
          return false;
        }
        if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
          return true;
        }
        const desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);
        if (desiredSize > 0) {
          return true;
        }
        return false;
      }
      function ReadableStreamDefaultControllerClearAlgorithms(controller) {
        controller._pullAlgorithm = void 0;
        controller._cancelAlgorithm = void 0;
        controller._strategySizeAlgorithm = void 0;
      }
      function ReadableStreamDefaultControllerClose(controller) {
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
          return;
        }
        const stream = controller._controlledReadableStream;
        controller._closeRequested = true;
        if (controller._queue.length === 0) {
          ReadableStreamDefaultControllerClearAlgorithms(controller);
          ReadableStreamClose(stream);
        }
      }
      function ReadableStreamDefaultControllerEnqueue(controller, chunk) {
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
          return;
        }
        const stream = controller._controlledReadableStream;
        if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
          ReadableStreamFulfillReadRequest(stream, chunk, false);
        } else {
          let chunkSize;
          try {
            chunkSize = controller._strategySizeAlgorithm(chunk);
          } catch (chunkSizeE) {
            ReadableStreamDefaultControllerError(controller, chunkSizeE);
            throw chunkSizeE;
          }
          try {
            EnqueueValueWithSize(controller, chunk, chunkSize);
          } catch (enqueueE) {
            ReadableStreamDefaultControllerError(controller, enqueueE);
            throw enqueueE;
          }
        }
        ReadableStreamDefaultControllerCallPullIfNeeded(controller);
      }
      function ReadableStreamDefaultControllerError(controller, e2) {
        const stream = controller._controlledReadableStream;
        if (stream._state !== "readable") {
          return;
        }
        ResetQueue(controller);
        ReadableStreamDefaultControllerClearAlgorithms(controller);
        ReadableStreamError(stream, e2);
      }
      function ReadableStreamDefaultControllerGetDesiredSize(controller) {
        const state = controller._controlledReadableStream._state;
        if (state === "errored") {
          return null;
        }
        if (state === "closed") {
          return 0;
        }
        return controller._strategyHWM - controller._queueTotalSize;
      }
      function ReadableStreamDefaultControllerHasBackpressure(controller) {
        if (ReadableStreamDefaultControllerShouldCallPull(controller)) {
          return false;
        }
        return true;
      }
      function ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {
        const state = controller._controlledReadableStream._state;
        if (!controller._closeRequested && state === "readable") {
          return true;
        }
        return false;
      }
      function SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {
        controller._controlledReadableStream = stream;
        controller._queue = void 0;
        controller._queueTotalSize = void 0;
        ResetQueue(controller);
        controller._started = false;
        controller._closeRequested = false;
        controller._pullAgain = false;
        controller._pulling = false;
        controller._strategySizeAlgorithm = sizeAlgorithm;
        controller._strategyHWM = highWaterMark;
        controller._pullAlgorithm = pullAlgorithm;
        controller._cancelAlgorithm = cancelAlgorithm;
        stream._readableStreamController = controller;
        const startResult = startAlgorithm();
        uponPromise(promiseResolvedWith(startResult), () => {
          controller._started = true;
          ReadableStreamDefaultControllerCallPullIfNeeded(controller);
          return null;
        }, (r2) => {
          ReadableStreamDefaultControllerError(controller, r2);
          return null;
        });
      }
      function SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark, sizeAlgorithm) {
        const controller = Object.create(ReadableStreamDefaultController.prototype);
        let startAlgorithm;
        let pullAlgorithm;
        let cancelAlgorithm;
        if (underlyingSource.start !== void 0) {
          startAlgorithm = () => underlyingSource.start(controller);
        } else {
          startAlgorithm = () => void 0;
        }
        if (underlyingSource.pull !== void 0) {
          pullAlgorithm = () => underlyingSource.pull(controller);
        } else {
          pullAlgorithm = () => promiseResolvedWith(void 0);
        }
        if (underlyingSource.cancel !== void 0) {
          cancelAlgorithm = (reason) => underlyingSource.cancel(reason);
        } else {
          cancelAlgorithm = () => promiseResolvedWith(void 0);
        }
        SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
      }
      function defaultControllerBrandCheckException$1(name) {
        return new TypeError(`ReadableStreamDefaultController.prototype.${name} can only be used on a ReadableStreamDefaultController`);
      }
      function ReadableStreamTee(stream, cloneForBranch2) {
        if (IsReadableByteStreamController(stream._readableStreamController)) {
          return ReadableByteStreamTee(stream);
        }
        return ReadableStreamDefaultTee(stream);
      }
      function ReadableStreamDefaultTee(stream, cloneForBranch2) {
        const reader = AcquireReadableStreamDefaultReader(stream);
        let reading = false;
        let readAgain = false;
        let canceled1 = false;
        let canceled2 = false;
        let reason1;
        let reason2;
        let branch1;
        let branch2;
        let resolveCancelPromise;
        const cancelPromise = newPromise((resolve) => {
          resolveCancelPromise = resolve;
        });
        function pullAlgorithm() {
          if (reading) {
            readAgain = true;
            return promiseResolvedWith(void 0);
          }
          reading = true;
          const readRequest = {
            _chunkSteps: (chunk) => {
              _queueMicrotask(() => {
                readAgain = false;
                const chunk1 = chunk;
                const chunk2 = chunk;
                if (!canceled1) {
                  ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, chunk1);
                }
                if (!canceled2) {
                  ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, chunk2);
                }
                reading = false;
                if (readAgain) {
                  pullAlgorithm();
                }
              });
            },
            _closeSteps: () => {
              reading = false;
              if (!canceled1) {
                ReadableStreamDefaultControllerClose(branch1._readableStreamController);
              }
              if (!canceled2) {
                ReadableStreamDefaultControllerClose(branch2._readableStreamController);
              }
              if (!canceled1 || !canceled2) {
                resolveCancelPromise(void 0);
              }
            },
            _errorSteps: () => {
              reading = false;
            }
          };
          ReadableStreamDefaultReaderRead(reader, readRequest);
          return promiseResolvedWith(void 0);
        }
        function cancel1Algorithm(reason) {
          canceled1 = true;
          reason1 = reason;
          if (canceled2) {
            const compositeReason = CreateArrayFromList([reason1, reason2]);
            const cancelResult = ReadableStreamCancel(stream, compositeReason);
            resolveCancelPromise(cancelResult);
          }
          return cancelPromise;
        }
        function cancel2Algorithm(reason) {
          canceled2 = true;
          reason2 = reason;
          if (canceled1) {
            const compositeReason = CreateArrayFromList([reason1, reason2]);
            const cancelResult = ReadableStreamCancel(stream, compositeReason);
            resolveCancelPromise(cancelResult);
          }
          return cancelPromise;
        }
        function startAlgorithm() {
        }
        branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);
        branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);
        uponRejection(reader._closedPromise, (r2) => {
          ReadableStreamDefaultControllerError(branch1._readableStreamController, r2);
          ReadableStreamDefaultControllerError(branch2._readableStreamController, r2);
          if (!canceled1 || !canceled2) {
            resolveCancelPromise(void 0);
          }
          return null;
        });
        return [branch1, branch2];
      }
      function ReadableByteStreamTee(stream) {
        let reader = AcquireReadableStreamDefaultReader(stream);
        let reading = false;
        let readAgainForBranch1 = false;
        let readAgainForBranch2 = false;
        let canceled1 = false;
        let canceled2 = false;
        let reason1;
        let reason2;
        let branch1;
        let branch2;
        let resolveCancelPromise;
        const cancelPromise = newPromise((resolve) => {
          resolveCancelPromise = resolve;
        });
        function forwardReaderError(thisReader) {
          uponRejection(thisReader._closedPromise, (r2) => {
            if (thisReader !== reader) {
              return null;
            }
            ReadableByteStreamControllerError(branch1._readableStreamController, r2);
            ReadableByteStreamControllerError(branch2._readableStreamController, r2);
            if (!canceled1 || !canceled2) {
              resolveCancelPromise(void 0);
            }
            return null;
          });
        }
        function pullWithDefaultReader() {
          if (IsReadableStreamBYOBReader(reader)) {
            ReadableStreamReaderGenericRelease(reader);
            reader = AcquireReadableStreamDefaultReader(stream);
            forwardReaderError(reader);
          }
          const readRequest = {
            _chunkSteps: (chunk) => {
              _queueMicrotask(() => {
                readAgainForBranch1 = false;
                readAgainForBranch2 = false;
                const chunk1 = chunk;
                let chunk2 = chunk;
                if (!canceled1 && !canceled2) {
                  try {
                    chunk2 = CloneAsUint8Array(chunk);
                  } catch (cloneE) {
                    ReadableByteStreamControllerError(branch1._readableStreamController, cloneE);
                    ReadableByteStreamControllerError(branch2._readableStreamController, cloneE);
                    resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                    return;
                  }
                }
                if (!canceled1) {
                  ReadableByteStreamControllerEnqueue(branch1._readableStreamController, chunk1);
                }
                if (!canceled2) {
                  ReadableByteStreamControllerEnqueue(branch2._readableStreamController, chunk2);
                }
                reading = false;
                if (readAgainForBranch1) {
                  pull1Algorithm();
                } else if (readAgainForBranch2) {
                  pull2Algorithm();
                }
              });
            },
            _closeSteps: () => {
              reading = false;
              if (!canceled1) {
                ReadableByteStreamControllerClose(branch1._readableStreamController);
              }
              if (!canceled2) {
                ReadableByteStreamControllerClose(branch2._readableStreamController);
              }
              if (branch1._readableStreamController._pendingPullIntos.length > 0) {
                ReadableByteStreamControllerRespond(branch1._readableStreamController, 0);
              }
              if (branch2._readableStreamController._pendingPullIntos.length > 0) {
                ReadableByteStreamControllerRespond(branch2._readableStreamController, 0);
              }
              if (!canceled1 || !canceled2) {
                resolveCancelPromise(void 0);
              }
            },
            _errorSteps: () => {
              reading = false;
            }
          };
          ReadableStreamDefaultReaderRead(reader, readRequest);
        }
        function pullWithBYOBReader(view, forBranch2) {
          if (IsReadableStreamDefaultReader(reader)) {
            ReadableStreamReaderGenericRelease(reader);
            reader = AcquireReadableStreamBYOBReader(stream);
            forwardReaderError(reader);
          }
          const byobBranch = forBranch2 ? branch2 : branch1;
          const otherBranch = forBranch2 ? branch1 : branch2;
          const readIntoRequest = {
            _chunkSteps: (chunk) => {
              _queueMicrotask(() => {
                readAgainForBranch1 = false;
                readAgainForBranch2 = false;
                const byobCanceled = forBranch2 ? canceled2 : canceled1;
                const otherCanceled = forBranch2 ? canceled1 : canceled2;
                if (!otherCanceled) {
                  let clonedChunk;
                  try {
                    clonedChunk = CloneAsUint8Array(chunk);
                  } catch (cloneE) {
                    ReadableByteStreamControllerError(byobBranch._readableStreamController, cloneE);
                    ReadableByteStreamControllerError(otherBranch._readableStreamController, cloneE);
                    resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                    return;
                  }
                  if (!byobCanceled) {
                    ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                  }
                  ReadableByteStreamControllerEnqueue(otherBranch._readableStreamController, clonedChunk);
                } else if (!byobCanceled) {
                  ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                }
                reading = false;
                if (readAgainForBranch1) {
                  pull1Algorithm();
                } else if (readAgainForBranch2) {
                  pull2Algorithm();
                }
              });
            },
            _closeSteps: (chunk) => {
              reading = false;
              const byobCanceled = forBranch2 ? canceled2 : canceled1;
              const otherCanceled = forBranch2 ? canceled1 : canceled2;
              if (!byobCanceled) {
                ReadableByteStreamControllerClose(byobBranch._readableStreamController);
              }
              if (!otherCanceled) {
                ReadableByteStreamControllerClose(otherBranch._readableStreamController);
              }
              if (chunk !== void 0) {
                if (!byobCanceled) {
                  ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                }
                if (!otherCanceled && otherBranch._readableStreamController._pendingPullIntos.length > 0) {
                  ReadableByteStreamControllerRespond(otherBranch._readableStreamController, 0);
                }
              }
              if (!byobCanceled || !otherCanceled) {
                resolveCancelPromise(void 0);
              }
            },
            _errorSteps: () => {
              reading = false;
            }
          };
          ReadableStreamBYOBReaderRead(reader, view, 1, readIntoRequest);
        }
        function pull1Algorithm() {
          if (reading) {
            readAgainForBranch1 = true;
            return promiseResolvedWith(void 0);
          }
          reading = true;
          const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch1._readableStreamController);
          if (byobRequest === null) {
            pullWithDefaultReader();
          } else {
            pullWithBYOBReader(byobRequest._view, false);
          }
          return promiseResolvedWith(void 0);
        }
        function pull2Algorithm() {
          if (reading) {
            readAgainForBranch2 = true;
            return promiseResolvedWith(void 0);
          }
          reading = true;
          const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch2._readableStreamController);
          if (byobRequest === null) {
            pullWithDefaultReader();
          } else {
            pullWithBYOBReader(byobRequest._view, true);
          }
          return promiseResolvedWith(void 0);
        }
        function cancel1Algorithm(reason) {
          canceled1 = true;
          reason1 = reason;
          if (canceled2) {
            const compositeReason = CreateArrayFromList([reason1, reason2]);
            const cancelResult = ReadableStreamCancel(stream, compositeReason);
            resolveCancelPromise(cancelResult);
          }
          return cancelPromise;
        }
        function cancel2Algorithm(reason) {
          canceled2 = true;
          reason2 = reason;
          if (canceled1) {
            const compositeReason = CreateArrayFromList([reason1, reason2]);
            const cancelResult = ReadableStreamCancel(stream, compositeReason);
            resolveCancelPromise(cancelResult);
          }
          return cancelPromise;
        }
        function startAlgorithm() {
          return;
        }
        branch1 = CreateReadableByteStream(startAlgorithm, pull1Algorithm, cancel1Algorithm);
        branch2 = CreateReadableByteStream(startAlgorithm, pull2Algorithm, cancel2Algorithm);
        forwardReaderError(reader);
        return [branch1, branch2];
      }
      function isReadableStreamLike(stream) {
        return typeIsObject(stream) && typeof stream.getReader !== "undefined";
      }
      function ReadableStreamFrom(source) {
        if (isReadableStreamLike(source)) {
          return ReadableStreamFromDefaultReader(source.getReader());
        }
        return ReadableStreamFromIterable(source);
      }
      function ReadableStreamFromIterable(asyncIterable) {
        let stream;
        const iteratorRecord = GetIterator(asyncIterable, "async");
        const startAlgorithm = noop2;
        function pullAlgorithm() {
          let nextResult;
          try {
            nextResult = IteratorNext(iteratorRecord);
          } catch (e2) {
            return promiseRejectedWith(e2);
          }
          const nextPromise = promiseResolvedWith(nextResult);
          return transformPromiseWith(nextPromise, (iterResult) => {
            if (!typeIsObject(iterResult)) {
              throw new TypeError("The promise returned by the iterator.next() method must fulfill with an object");
            }
            const done = IteratorComplete(iterResult);
            if (done) {
              ReadableStreamDefaultControllerClose(stream._readableStreamController);
            } else {
              const value = IteratorValue(iterResult);
              ReadableStreamDefaultControllerEnqueue(stream._readableStreamController, value);
            }
          });
        }
        function cancelAlgorithm(reason) {
          const iterator = iteratorRecord.iterator;
          let returnMethod;
          try {
            returnMethod = GetMethod(iterator, "return");
          } catch (e2) {
            return promiseRejectedWith(e2);
          }
          if (returnMethod === void 0) {
            return promiseResolvedWith(void 0);
          }
          let returnResult;
          try {
            returnResult = reflectCall(returnMethod, iterator, [reason]);
          } catch (e2) {
            return promiseRejectedWith(e2);
          }
          const returnPromise = promiseResolvedWith(returnResult);
          return transformPromiseWith(returnPromise, (iterResult) => {
            if (!typeIsObject(iterResult)) {
              throw new TypeError("The promise returned by the iterator.return() method must fulfill with an object");
            }
            return void 0;
          });
        }
        stream = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, 0);
        return stream;
      }
      function ReadableStreamFromDefaultReader(reader) {
        let stream;
        const startAlgorithm = noop2;
        function pullAlgorithm() {
          let readPromise;
          try {
            readPromise = reader.read();
          } catch (e2) {
            return promiseRejectedWith(e2);
          }
          return transformPromiseWith(readPromise, (readResult) => {
            if (!typeIsObject(readResult)) {
              throw new TypeError("The promise returned by the reader.read() method must fulfill with an object");
            }
            if (readResult.done) {
              ReadableStreamDefaultControllerClose(stream._readableStreamController);
            } else {
              const value = readResult.value;
              ReadableStreamDefaultControllerEnqueue(stream._readableStreamController, value);
            }
          });
        }
        function cancelAlgorithm(reason) {
          try {
            return promiseResolvedWith(reader.cancel(reason));
          } catch (e2) {
            return promiseRejectedWith(e2);
          }
        }
        stream = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, 0);
        return stream;
      }
      function convertUnderlyingDefaultOrByteSource(source, context) {
        assertDictionary(source, context);
        const original = source;
        const autoAllocateChunkSize = original === null || original === void 0 ? void 0 : original.autoAllocateChunkSize;
        const cancel = original === null || original === void 0 ? void 0 : original.cancel;
        const pull = original === null || original === void 0 ? void 0 : original.pull;
        const start = original === null || original === void 0 ? void 0 : original.start;
        const type = original === null || original === void 0 ? void 0 : original.type;
        return {
          autoAllocateChunkSize: autoAllocateChunkSize === void 0 ? void 0 : convertUnsignedLongLongWithEnforceRange(autoAllocateChunkSize, `${context} has member 'autoAllocateChunkSize' that`),
          cancel: cancel === void 0 ? void 0 : convertUnderlyingSourceCancelCallback(cancel, original, `${context} has member 'cancel' that`),
          pull: pull === void 0 ? void 0 : convertUnderlyingSourcePullCallback(pull, original, `${context} has member 'pull' that`),
          start: start === void 0 ? void 0 : convertUnderlyingSourceStartCallback(start, original, `${context} has member 'start' that`),
          type: type === void 0 ? void 0 : convertReadableStreamType(type, `${context} has member 'type' that`)
        };
      }
      function convertUnderlyingSourceCancelCallback(fn, original, context) {
        assertFunction(fn, context);
        return (reason) => promiseCall(fn, original, [reason]);
      }
      function convertUnderlyingSourcePullCallback(fn, original, context) {
        assertFunction(fn, context);
        return (controller) => promiseCall(fn, original, [controller]);
      }
      function convertUnderlyingSourceStartCallback(fn, original, context) {
        assertFunction(fn, context);
        return (controller) => reflectCall(fn, original, [controller]);
      }
      function convertReadableStreamType(type, context) {
        type = `${type}`;
        if (type !== "bytes") {
          throw new TypeError(`${context} '${type}' is not a valid enumeration value for ReadableStreamType`);
        }
        return type;
      }
      function convertIteratorOptions(options, context) {
        assertDictionary(options, context);
        const preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;
        return { preventCancel: Boolean(preventCancel) };
      }
      function convertPipeOptions(options, context) {
        assertDictionary(options, context);
        const preventAbort = options === null || options === void 0 ? void 0 : options.preventAbort;
        const preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;
        const preventClose = options === null || options === void 0 ? void 0 : options.preventClose;
        const signal = options === null || options === void 0 ? void 0 : options.signal;
        if (signal !== void 0) {
          assertAbortSignal(signal, `${context} has member 'signal' that`);
        }
        return {
          preventAbort: Boolean(preventAbort),
          preventCancel: Boolean(preventCancel),
          preventClose: Boolean(preventClose),
          signal
        };
      }
      function assertAbortSignal(signal, context) {
        if (!isAbortSignal2(signal)) {
          throw new TypeError(`${context} is not an AbortSignal.`);
        }
      }
      function convertReadableWritablePair(pair, context) {
        assertDictionary(pair, context);
        const readable = pair === null || pair === void 0 ? void 0 : pair.readable;
        assertRequiredField(readable, "readable", "ReadableWritablePair");
        assertReadableStream(readable, `${context} has member 'readable' that`);
        const writable = pair === null || pair === void 0 ? void 0 : pair.writable;
        assertRequiredField(writable, "writable", "ReadableWritablePair");
        assertWritableStream(writable, `${context} has member 'writable' that`);
        return { readable, writable };
      }
      class ReadableStream2 {
        constructor(rawUnderlyingSource = {}, rawStrategy = {}) {
          if (rawUnderlyingSource === void 0) {
            rawUnderlyingSource = null;
          } else {
            assertObject(rawUnderlyingSource, "First parameter");
          }
          const strategy = convertQueuingStrategy(rawStrategy, "Second parameter");
          const underlyingSource = convertUnderlyingDefaultOrByteSource(rawUnderlyingSource, "First parameter");
          InitializeReadableStream(this);
          if (underlyingSource.type === "bytes") {
            if (strategy.size !== void 0) {
              throw new RangeError("The strategy for a byte stream cannot have a size function");
            }
            const highWaterMark = ExtractHighWaterMark(strategy, 0);
            SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);
          } else {
            const sizeAlgorithm = ExtractSizeAlgorithm(strategy);
            const highWaterMark = ExtractHighWaterMark(strategy, 1);
            SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);
          }
        }
        /**
         * Whether or not the readable stream is locked to a {@link ReadableStreamDefaultReader | reader}.
         */
        get locked() {
          if (!IsReadableStream(this)) {
            throw streamBrandCheckException$1("locked");
          }
          return IsReadableStreamLocked(this);
        }
        /**
         * Cancels the stream, signaling a loss of interest in the stream by a consumer.
         *
         * The supplied `reason` argument will be given to the underlying source's {@link UnderlyingSource.cancel | cancel()}
         * method, which might or might not use it.
         */
        cancel(reason = void 0) {
          if (!IsReadableStream(this)) {
            return promiseRejectedWith(streamBrandCheckException$1("cancel"));
          }
          if (IsReadableStreamLocked(this)) {
            return promiseRejectedWith(new TypeError("Cannot cancel a stream that already has a reader"));
          }
          return ReadableStreamCancel(this, reason);
        }
        getReader(rawOptions = void 0) {
          if (!IsReadableStream(this)) {
            throw streamBrandCheckException$1("getReader");
          }
          const options = convertReaderOptions(rawOptions, "First parameter");
          if (options.mode === void 0) {
            return AcquireReadableStreamDefaultReader(this);
          }
          return AcquireReadableStreamBYOBReader(this);
        }
        pipeThrough(rawTransform, rawOptions = {}) {
          if (!IsReadableStream(this)) {
            throw streamBrandCheckException$1("pipeThrough");
          }
          assertRequiredArgument(rawTransform, 1, "pipeThrough");
          const transform = convertReadableWritablePair(rawTransform, "First parameter");
          const options = convertPipeOptions(rawOptions, "Second parameter");
          if (IsReadableStreamLocked(this)) {
            throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream");
          }
          if (IsWritableStreamLocked(transform.writable)) {
            throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream");
          }
          const promise = ReadableStreamPipeTo(this, transform.writable, options.preventClose, options.preventAbort, options.preventCancel, options.signal);
          setPromiseIsHandledToTrue(promise);
          return transform.readable;
        }
        pipeTo(destination, rawOptions = {}) {
          if (!IsReadableStream(this)) {
            return promiseRejectedWith(streamBrandCheckException$1("pipeTo"));
          }
          if (destination === void 0) {
            return promiseRejectedWith(`Parameter 1 is required in 'pipeTo'.`);
          }
          if (!IsWritableStream(destination)) {
            return promiseRejectedWith(new TypeError(`ReadableStream.prototype.pipeTo's first argument must be a WritableStream`));
          }
          let options;
          try {
            options = convertPipeOptions(rawOptions, "Second parameter");
          } catch (e2) {
            return promiseRejectedWith(e2);
          }
          if (IsReadableStreamLocked(this)) {
            return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream"));
          }
          if (IsWritableStreamLocked(destination)) {
            return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream"));
          }
          return ReadableStreamPipeTo(this, destination, options.preventClose, options.preventAbort, options.preventCancel, options.signal);
        }
        /**
         * Tees this readable stream, returning a two-element array containing the two resulting branches as
         * new {@link ReadableStream} instances.
         *
         * Teeing a stream will lock it, preventing any other consumer from acquiring a reader.
         * To cancel the stream, cancel both of the resulting branches; a composite cancellation reason will then be
         * propagated to the stream's underlying source.
         *
         * Note that the chunks seen in each branch will be the same object. If the chunks are not immutable,
         * this could allow interference between the two branches.
         */
        tee() {
          if (!IsReadableStream(this)) {
            throw streamBrandCheckException$1("tee");
          }
          const branches = ReadableStreamTee(this);
          return CreateArrayFromList(branches);
        }
        values(rawOptions = void 0) {
          if (!IsReadableStream(this)) {
            throw streamBrandCheckException$1("values");
          }
          const options = convertIteratorOptions(rawOptions, "First parameter");
          return AcquireReadableStreamAsyncIterator(this, options.preventCancel);
        }
        [SymbolAsyncIterator](options) {
          return this.values(options);
        }
        /**
         * Creates a new ReadableStream wrapping the provided iterable or async iterable.
         *
         * This can be used to adapt various kinds of objects into a readable stream,
         * such as an array, an async generator, or a Node.js readable stream.
         */
        static from(asyncIterable) {
          return ReadableStreamFrom(asyncIterable);
        }
      }
      Object.defineProperties(ReadableStream2, {
        from: { enumerable: true }
      });
      Object.defineProperties(ReadableStream2.prototype, {
        cancel: { enumerable: true },
        getReader: { enumerable: true },
        pipeThrough: { enumerable: true },
        pipeTo: { enumerable: true },
        tee: { enumerable: true },
        values: { enumerable: true },
        locked: { enumerable: true }
      });
      setFunctionName(ReadableStream2.from, "from");
      setFunctionName(ReadableStream2.prototype.cancel, "cancel");
      setFunctionName(ReadableStream2.prototype.getReader, "getReader");
      setFunctionName(ReadableStream2.prototype.pipeThrough, "pipeThrough");
      setFunctionName(ReadableStream2.prototype.pipeTo, "pipeTo");
      setFunctionName(ReadableStream2.prototype.tee, "tee");
      setFunctionName(ReadableStream2.prototype.values, "values");
      if (typeof Symbol.toStringTag === "symbol") {
        Object.defineProperty(ReadableStream2.prototype, Symbol.toStringTag, {
          value: "ReadableStream",
          configurable: true
        });
      }
      Object.defineProperty(ReadableStream2.prototype, SymbolAsyncIterator, {
        value: ReadableStream2.prototype.values,
        writable: true,
        configurable: true
      });
      function CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {
        const stream = Object.create(ReadableStream2.prototype);
        InitializeReadableStream(stream);
        const controller = Object.create(ReadableStreamDefaultController.prototype);
        SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
        return stream;
      }
      function CreateReadableByteStream(startAlgorithm, pullAlgorithm, cancelAlgorithm) {
        const stream = Object.create(ReadableStream2.prototype);
        InitializeReadableStream(stream);
        const controller = Object.create(ReadableByteStreamController.prototype);
        SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, 0, void 0);
        return stream;
      }
      function InitializeReadableStream(stream) {
        stream._state = "readable";
        stream._reader = void 0;
        stream._storedError = void 0;
        stream._disturbed = false;
      }
      function IsReadableStream(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_readableStreamController")) {
          return false;
        }
        return x2 instanceof ReadableStream2;
      }
      function IsReadableStreamLocked(stream) {
        if (stream._reader === void 0) {
          return false;
        }
        return true;
      }
      function ReadableStreamCancel(stream, reason) {
        stream._disturbed = true;
        if (stream._state === "closed") {
          return promiseResolvedWith(void 0);
        }
        if (stream._state === "errored") {
          return promiseRejectedWith(stream._storedError);
        }
        ReadableStreamClose(stream);
        const reader = stream._reader;
        if (reader !== void 0 && IsReadableStreamBYOBReader(reader)) {
          const readIntoRequests = reader._readIntoRequests;
          reader._readIntoRequests = new SimpleQueue();
          readIntoRequests.forEach((readIntoRequest) => {
            readIntoRequest._closeSteps(void 0);
          });
        }
        const sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);
        return transformPromiseWith(sourceCancelPromise, noop2);
      }
      function ReadableStreamClose(stream) {
        stream._state = "closed";
        const reader = stream._reader;
        if (reader === void 0) {
          return;
        }
        defaultReaderClosedPromiseResolve(reader);
        if (IsReadableStreamDefaultReader(reader)) {
          const readRequests = reader._readRequests;
          reader._readRequests = new SimpleQueue();
          readRequests.forEach((readRequest) => {
            readRequest._closeSteps();
          });
        }
      }
      function ReadableStreamError(stream, e2) {
        stream._state = "errored";
        stream._storedError = e2;
        const reader = stream._reader;
        if (reader === void 0) {
          return;
        }
        defaultReaderClosedPromiseReject(reader, e2);
        if (IsReadableStreamDefaultReader(reader)) {
          ReadableStreamDefaultReaderErrorReadRequests(reader, e2);
        } else {
          ReadableStreamBYOBReaderErrorReadIntoRequests(reader, e2);
        }
      }
      function streamBrandCheckException$1(name) {
        return new TypeError(`ReadableStream.prototype.${name} can only be used on a ReadableStream`);
      }
      function convertQueuingStrategyInit(init, context) {
        assertDictionary(init, context);
        const highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;
        assertRequiredField(highWaterMark, "highWaterMark", "QueuingStrategyInit");
        return {
          highWaterMark: convertUnrestrictedDouble(highWaterMark)
        };
      }
      const byteLengthSizeFunction = (chunk) => {
        return chunk.byteLength;
      };
      setFunctionName(byteLengthSizeFunction, "size");
      class ByteLengthQueuingStrategy {
        constructor(options) {
          assertRequiredArgument(options, 1, "ByteLengthQueuingStrategy");
          options = convertQueuingStrategyInit(options, "First parameter");
          this._byteLengthQueuingStrategyHighWaterMark = options.highWaterMark;
        }
        /**
         * Returns the high water mark provided to the constructor.
         */
        get highWaterMark() {
          if (!IsByteLengthQueuingStrategy(this)) {
            throw byteLengthBrandCheckException("highWaterMark");
          }
          return this._byteLengthQueuingStrategyHighWaterMark;
        }
        /**
         * Measures the size of `chunk` by returning the value of its `byteLength` property.
         */
        get size() {
          if (!IsByteLengthQueuingStrategy(this)) {
            throw byteLengthBrandCheckException("size");
          }
          return byteLengthSizeFunction;
        }
      }
      Object.defineProperties(ByteLengthQueuingStrategy.prototype, {
        highWaterMark: { enumerable: true },
        size: { enumerable: true }
      });
      if (typeof Symbol.toStringTag === "symbol") {
        Object.defineProperty(ByteLengthQueuingStrategy.prototype, Symbol.toStringTag, {
          value: "ByteLengthQueuingStrategy",
          configurable: true
        });
      }
      function byteLengthBrandCheckException(name) {
        return new TypeError(`ByteLengthQueuingStrategy.prototype.${name} can only be used on a ByteLengthQueuingStrategy`);
      }
      function IsByteLengthQueuingStrategy(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_byteLengthQueuingStrategyHighWaterMark")) {
          return false;
        }
        return x2 instanceof ByteLengthQueuingStrategy;
      }
      const countSizeFunction = () => {
        return 1;
      };
      setFunctionName(countSizeFunction, "size");
      class CountQueuingStrategy {
        constructor(options) {
          assertRequiredArgument(options, 1, "CountQueuingStrategy");
          options = convertQueuingStrategyInit(options, "First parameter");
          this._countQueuingStrategyHighWaterMark = options.highWaterMark;
        }
        /**
         * Returns the high water mark provided to the constructor.
         */
        get highWaterMark() {
          if (!IsCountQueuingStrategy(this)) {
            throw countBrandCheckException("highWaterMark");
          }
          return this._countQueuingStrategyHighWaterMark;
        }
        /**
         * Measures the size of `chunk` by always returning 1.
         * This ensures that the total queue size is a count of the number of chunks in the queue.
         */
        get size() {
          if (!IsCountQueuingStrategy(this)) {
            throw countBrandCheckException("size");
          }
          return countSizeFunction;
        }
      }
      Object.defineProperties(CountQueuingStrategy.prototype, {
        highWaterMark: { enumerable: true },
        size: { enumerable: true }
      });
      if (typeof Symbol.toStringTag === "symbol") {
        Object.defineProperty(CountQueuingStrategy.prototype, Symbol.toStringTag, {
          value: "CountQueuingStrategy",
          configurable: true
        });
      }
      function countBrandCheckException(name) {
        return new TypeError(`CountQueuingStrategy.prototype.${name} can only be used on a CountQueuingStrategy`);
      }
      function IsCountQueuingStrategy(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_countQueuingStrategyHighWaterMark")) {
          return false;
        }
        return x2 instanceof CountQueuingStrategy;
      }
      function convertTransformer(original, context) {
        assertDictionary(original, context);
        const cancel = original === null || original === void 0 ? void 0 : original.cancel;
        const flush = original === null || original === void 0 ? void 0 : original.flush;
        const readableType = original === null || original === void 0 ? void 0 : original.readableType;
        const start = original === null || original === void 0 ? void 0 : original.start;
        const transform = original === null || original === void 0 ? void 0 : original.transform;
        const writableType = original === null || original === void 0 ? void 0 : original.writableType;
        return {
          cancel: cancel === void 0 ? void 0 : convertTransformerCancelCallback(cancel, original, `${context} has member 'cancel' that`),
          flush: flush === void 0 ? void 0 : convertTransformerFlushCallback(flush, original, `${context} has member 'flush' that`),
          readableType,
          start: start === void 0 ? void 0 : convertTransformerStartCallback(start, original, `${context} has member 'start' that`),
          transform: transform === void 0 ? void 0 : convertTransformerTransformCallback(transform, original, `${context} has member 'transform' that`),
          writableType
        };
      }
      function convertTransformerFlushCallback(fn, original, context) {
        assertFunction(fn, context);
        return (controller) => promiseCall(fn, original, [controller]);
      }
      function convertTransformerStartCallback(fn, original, context) {
        assertFunction(fn, context);
        return (controller) => reflectCall(fn, original, [controller]);
      }
      function convertTransformerTransformCallback(fn, original, context) {
        assertFunction(fn, context);
        return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);
      }
      function convertTransformerCancelCallback(fn, original, context) {
        assertFunction(fn, context);
        return (reason) => promiseCall(fn, original, [reason]);
      }
      class TransformStream {
        constructor(rawTransformer = {}, rawWritableStrategy = {}, rawReadableStrategy = {}) {
          if (rawTransformer === void 0) {
            rawTransformer = null;
          }
          const writableStrategy = convertQueuingStrategy(rawWritableStrategy, "Second parameter");
          const readableStrategy = convertQueuingStrategy(rawReadableStrategy, "Third parameter");
          const transformer = convertTransformer(rawTransformer, "First parameter");
          if (transformer.readableType !== void 0) {
            throw new RangeError("Invalid readableType specified");
          }
          if (transformer.writableType !== void 0) {
            throw new RangeError("Invalid writableType specified");
          }
          const readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0);
          const readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy);
          const writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1);
          const writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);
          let startPromise_resolve;
          const startPromise = newPromise((resolve) => {
            startPromise_resolve = resolve;
          });
          InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
          SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);
          if (transformer.start !== void 0) {
            startPromise_resolve(transformer.start(this._transformStreamController));
          } else {
            startPromise_resolve(void 0);
          }
        }
        /**
         * The readable side of the transform stream.
         */
        get readable() {
          if (!IsTransformStream(this)) {
            throw streamBrandCheckException("readable");
          }
          return this._readable;
        }
        /**
         * The writable side of the transform stream.
         */
        get writable() {
          if (!IsTransformStream(this)) {
            throw streamBrandCheckException("writable");
          }
          return this._writable;
        }
      }
      Object.defineProperties(TransformStream.prototype, {
        readable: { enumerable: true },
        writable: { enumerable: true }
      });
      if (typeof Symbol.toStringTag === "symbol") {
        Object.defineProperty(TransformStream.prototype, Symbol.toStringTag, {
          value: "TransformStream",
          configurable: true
        });
      }
      function InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {
        function startAlgorithm() {
          return startPromise;
        }
        function writeAlgorithm(chunk) {
          return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);
        }
        function abortAlgorithm(reason) {
          return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);
        }
        function closeAlgorithm() {
          return TransformStreamDefaultSinkCloseAlgorithm(stream);
        }
        stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);
        function pullAlgorithm() {
          return TransformStreamDefaultSourcePullAlgorithm(stream);
        }
        function cancelAlgorithm(reason) {
          return TransformStreamDefaultSourceCancelAlgorithm(stream, reason);
        }
        stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
        stream._backpressure = void 0;
        stream._backpressureChangePromise = void 0;
        stream._backpressureChangePromise_resolve = void 0;
        TransformStreamSetBackpressure(stream, true);
        stream._transformStreamController = void 0;
      }
      function IsTransformStream(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_transformStreamController")) {
          return false;
        }
        return x2 instanceof TransformStream;
      }
      function TransformStreamError(stream, e2) {
        ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e2);
        TransformStreamErrorWritableAndUnblockWrite(stream, e2);
      }
      function TransformStreamErrorWritableAndUnblockWrite(stream, e2) {
        TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController);
        WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e2);
        TransformStreamUnblockWrite(stream);
      }
      function TransformStreamUnblockWrite(stream) {
        if (stream._backpressure) {
          TransformStreamSetBackpressure(stream, false);
        }
      }
      function TransformStreamSetBackpressure(stream, backpressure) {
        if (stream._backpressureChangePromise !== void 0) {
          stream._backpressureChangePromise_resolve();
        }
        stream._backpressureChangePromise = newPromise((resolve) => {
          stream._backpressureChangePromise_resolve = resolve;
        });
        stream._backpressure = backpressure;
      }
      class TransformStreamDefaultController {
        constructor() {
          throw new TypeError("Illegal constructor");
        }
        /**
         * Returns the desired size to fill the readable side’s internal queue. It can be negative, if the queue is over-full.
         */
        get desiredSize() {
          if (!IsTransformStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException("desiredSize");
          }
          const readableController = this._controlledTransformStream._readable._readableStreamController;
          return ReadableStreamDefaultControllerGetDesiredSize(readableController);
        }
        enqueue(chunk = void 0) {
          if (!IsTransformStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException("enqueue");
          }
          TransformStreamDefaultControllerEnqueue(this, chunk);
        }
        /**
         * Errors both the readable side and the writable side of the controlled transform stream, making all future
         * interactions with it fail with the given error `e`. Any chunks queued for transformation will be discarded.
         */
        error(reason = void 0) {
          if (!IsTransformStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException("error");
          }
          TransformStreamDefaultControllerError(this, reason);
        }
        /**
         * Closes the readable side and errors the writable side of the controlled transform stream. This is useful when the
         * transformer only needs to consume a portion of the chunks written to the writable side.
         */
        terminate() {
          if (!IsTransformStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException("terminate");
          }
          TransformStreamDefaultControllerTerminate(this);
        }
      }
      Object.defineProperties(TransformStreamDefaultController.prototype, {
        enqueue: { enumerable: true },
        error: { enumerable: true },
        terminate: { enumerable: true },
        desiredSize: { enumerable: true }
      });
      setFunctionName(TransformStreamDefaultController.prototype.enqueue, "enqueue");
      setFunctionName(TransformStreamDefaultController.prototype.error, "error");
      setFunctionName(TransformStreamDefaultController.prototype.terminate, "terminate");
      if (typeof Symbol.toStringTag === "symbol") {
        Object.defineProperty(TransformStreamDefaultController.prototype, Symbol.toStringTag, {
          value: "TransformStreamDefaultController",
          configurable: true
        });
      }
      function IsTransformStreamDefaultController(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_controlledTransformStream")) {
          return false;
        }
        return x2 instanceof TransformStreamDefaultController;
      }
      function SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm, cancelAlgorithm) {
        controller._controlledTransformStream = stream;
        stream._transformStreamController = controller;
        controller._transformAlgorithm = transformAlgorithm;
        controller._flushAlgorithm = flushAlgorithm;
        controller._cancelAlgorithm = cancelAlgorithm;
        controller._finishPromise = void 0;
        controller._finishPromise_resolve = void 0;
        controller._finishPromise_reject = void 0;
      }
      function SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer) {
        const controller = Object.create(TransformStreamDefaultController.prototype);
        let transformAlgorithm;
        let flushAlgorithm;
        let cancelAlgorithm;
        if (transformer.transform !== void 0) {
          transformAlgorithm = (chunk) => transformer.transform(chunk, controller);
        } else {
          transformAlgorithm = (chunk) => {
            try {
              TransformStreamDefaultControllerEnqueue(controller, chunk);
              return promiseResolvedWith(void 0);
            } catch (transformResultE) {
              return promiseRejectedWith(transformResultE);
            }
          };
        }
        if (transformer.flush !== void 0) {
          flushAlgorithm = () => transformer.flush(controller);
        } else {
          flushAlgorithm = () => promiseResolvedWith(void 0);
        }
        if (transformer.cancel !== void 0) {
          cancelAlgorithm = (reason) => transformer.cancel(reason);
        } else {
          cancelAlgorithm = () => promiseResolvedWith(void 0);
        }
        SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm, cancelAlgorithm);
      }
      function TransformStreamDefaultControllerClearAlgorithms(controller) {
        controller._transformAlgorithm = void 0;
        controller._flushAlgorithm = void 0;
        controller._cancelAlgorithm = void 0;
      }
      function TransformStreamDefaultControllerEnqueue(controller, chunk) {
        const stream = controller._controlledTransformStream;
        const readableController = stream._readable._readableStreamController;
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) {
          throw new TypeError("Readable side is not in a state that permits enqueue");
        }
        try {
          ReadableStreamDefaultControllerEnqueue(readableController, chunk);
        } catch (e2) {
          TransformStreamErrorWritableAndUnblockWrite(stream, e2);
          throw stream._readable._storedError;
        }
        const backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);
        if (backpressure !== stream._backpressure) {
          TransformStreamSetBackpressure(stream, true);
        }
      }
      function TransformStreamDefaultControllerError(controller, e2) {
        TransformStreamError(controller._controlledTransformStream, e2);
      }
      function TransformStreamDefaultControllerPerformTransform(controller, chunk) {
        const transformPromise = controller._transformAlgorithm(chunk);
        return transformPromiseWith(transformPromise, void 0, (r2) => {
          TransformStreamError(controller._controlledTransformStream, r2);
          throw r2;
        });
      }
      function TransformStreamDefaultControllerTerminate(controller) {
        const stream = controller._controlledTransformStream;
        const readableController = stream._readable._readableStreamController;
        ReadableStreamDefaultControllerClose(readableController);
        const error = new TypeError("TransformStream terminated");
        TransformStreamErrorWritableAndUnblockWrite(stream, error);
      }
      function TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {
        const controller = stream._transformStreamController;
        if (stream._backpressure) {
          const backpressureChangePromise = stream._backpressureChangePromise;
          return transformPromiseWith(backpressureChangePromise, () => {
            const writable = stream._writable;
            const state = writable._state;
            if (state === "erroring") {
              throw writable._storedError;
            }
            return TransformStreamDefaultControllerPerformTransform(controller, chunk);
          });
        }
        return TransformStreamDefaultControllerPerformTransform(controller, chunk);
      }
      function TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {
        const controller = stream._transformStreamController;
        if (controller._finishPromise !== void 0) {
          return controller._finishPromise;
        }
        const readable = stream._readable;
        controller._finishPromise = newPromise((resolve, reject) => {
          controller._finishPromise_resolve = resolve;
          controller._finishPromise_reject = reject;
        });
        const cancelPromise = controller._cancelAlgorithm(reason);
        TransformStreamDefaultControllerClearAlgorithms(controller);
        uponPromise(cancelPromise, () => {
          if (readable._state === "errored") {
            defaultControllerFinishPromiseReject(controller, readable._storedError);
          } else {
            ReadableStreamDefaultControllerError(readable._readableStreamController, reason);
            defaultControllerFinishPromiseResolve(controller);
          }
          return null;
        }, (r2) => {
          ReadableStreamDefaultControllerError(readable._readableStreamController, r2);
          defaultControllerFinishPromiseReject(controller, r2);
          return null;
        });
        return controller._finishPromise;
      }
      function TransformStreamDefaultSinkCloseAlgorithm(stream) {
        const controller = stream._transformStreamController;
        if (controller._finishPromise !== void 0) {
          return controller._finishPromise;
        }
        const readable = stream._readable;
        controller._finishPromise = newPromise((resolve, reject) => {
          controller._finishPromise_resolve = resolve;
          controller._finishPromise_reject = reject;
        });
        const flushPromise = controller._flushAlgorithm();
        TransformStreamDefaultControllerClearAlgorithms(controller);
        uponPromise(flushPromise, () => {
          if (readable._state === "errored") {
            defaultControllerFinishPromiseReject(controller, readable._storedError);
          } else {
            ReadableStreamDefaultControllerClose(readable._readableStreamController);
            defaultControllerFinishPromiseResolve(controller);
          }
          return null;
        }, (r2) => {
          ReadableStreamDefaultControllerError(readable._readableStreamController, r2);
          defaultControllerFinishPromiseReject(controller, r2);
          return null;
        });
        return controller._finishPromise;
      }
      function TransformStreamDefaultSourcePullAlgorithm(stream) {
        TransformStreamSetBackpressure(stream, false);
        return stream._backpressureChangePromise;
      }
      function TransformStreamDefaultSourceCancelAlgorithm(stream, reason) {
        const controller = stream._transformStreamController;
        if (controller._finishPromise !== void 0) {
          return controller._finishPromise;
        }
        const writable = stream._writable;
        controller._finishPromise = newPromise((resolve, reject) => {
          controller._finishPromise_resolve = resolve;
          controller._finishPromise_reject = reject;
        });
        const cancelPromise = controller._cancelAlgorithm(reason);
        TransformStreamDefaultControllerClearAlgorithms(controller);
        uponPromise(cancelPromise, () => {
          if (writable._state === "errored") {
            defaultControllerFinishPromiseReject(controller, writable._storedError);
          } else {
            WritableStreamDefaultControllerErrorIfNeeded(writable._writableStreamController, reason);
            TransformStreamUnblockWrite(stream);
            defaultControllerFinishPromiseResolve(controller);
          }
          return null;
        }, (r2) => {
          WritableStreamDefaultControllerErrorIfNeeded(writable._writableStreamController, r2);
          TransformStreamUnblockWrite(stream);
          defaultControllerFinishPromiseReject(controller, r2);
          return null;
        });
        return controller._finishPromise;
      }
      function defaultControllerBrandCheckException(name) {
        return new TypeError(`TransformStreamDefaultController.prototype.${name} can only be used on a TransformStreamDefaultController`);
      }
      function defaultControllerFinishPromiseResolve(controller) {
        if (controller._finishPromise_resolve === void 0) {
          return;
        }
        controller._finishPromise_resolve();
        controller._finishPromise_resolve = void 0;
        controller._finishPromise_reject = void 0;
      }
      function defaultControllerFinishPromiseReject(controller, reason) {
        if (controller._finishPromise_reject === void 0) {
          return;
        }
        setPromiseIsHandledToTrue(controller._finishPromise);
        controller._finishPromise_reject(reason);
        controller._finishPromise_resolve = void 0;
        controller._finishPromise_reject = void 0;
      }
      function streamBrandCheckException(name) {
        return new TypeError(`TransformStream.prototype.${name} can only be used on a TransformStream`);
      }
      exports3.ByteLengthQueuingStrategy = ByteLengthQueuingStrategy;
      exports3.CountQueuingStrategy = CountQueuingStrategy;
      exports3.ReadableByteStreamController = ReadableByteStreamController;
      exports3.ReadableStream = ReadableStream2;
      exports3.ReadableStreamBYOBReader = ReadableStreamBYOBReader;
      exports3.ReadableStreamBYOBRequest = ReadableStreamBYOBRequest;
      exports3.ReadableStreamDefaultController = ReadableStreamDefaultController;
      exports3.ReadableStreamDefaultReader = ReadableStreamDefaultReader;
      exports3.TransformStream = TransformStream;
      exports3.TransformStreamDefaultController = TransformStreamDefaultController;
      exports3.WritableStream = WritableStream;
      exports3.WritableStreamDefaultController = WritableStreamDefaultController;
      exports3.WritableStreamDefaultWriter = WritableStreamDefaultWriter;
    });
  }
});

// node_modules/fetch-blob/streams.cjs
var require_streams = __commonJS({
  "node_modules/fetch-blob/streams.cjs"() {
    var POOL_SIZE2 = 65536;
    if (!globalThis.ReadableStream) {
      try {
        const process2 = require("node:process");
        const { emitWarning } = process2;
        try {
          process2.emitWarning = () => {
          };
          Object.assign(globalThis, require("node:stream/web"));
          process2.emitWarning = emitWarning;
        } catch (error) {
          process2.emitWarning = emitWarning;
          throw error;
        }
      } catch (error) {
        Object.assign(globalThis, require_ponyfill_es2018());
      }
    }
    try {
      const { Blob: Blob3 } = require("buffer");
      if (Blob3 && !Blob3.prototype.stream) {
        Blob3.prototype.stream = function name(params) {
          let position = 0;
          const blob = this;
          return new ReadableStream({
            type: "bytes",
            async pull(ctrl) {
              const chunk = blob.slice(position, Math.min(blob.size, position + POOL_SIZE2));
              const buffer = await chunk.arrayBuffer();
              position += buffer.byteLength;
              ctrl.enqueue(new Uint8Array(buffer));
              if (position === blob.size) {
                ctrl.close();
              }
            }
          });
        };
      }
    } catch (error) {
    }
  }
});

// node_modules/fetch-blob/index.js
async function* toIterator(parts, clone2 = true) {
  for (const part of parts) {
    if ("stream" in part) {
      yield* (
        /** @type {AsyncIterableIterator<Uint8Array>} */
        part.stream()
      );
    } else if (ArrayBuffer.isView(part)) {
      if (clone2) {
        let position = part.byteOffset;
        const end = part.byteOffset + part.byteLength;
        while (position !== end) {
          const size = Math.min(end - position, POOL_SIZE);
          const chunk = part.buffer.slice(position, position + size);
          position += chunk.byteLength;
          yield new Uint8Array(chunk);
        }
      } else {
        yield part;
      }
    } else {
      let position = 0, b = (
        /** @type {Blob} */
        part
      );
      while (position !== b.size) {
        const chunk = b.slice(position, Math.min(b.size, position + POOL_SIZE));
        const buffer = await chunk.arrayBuffer();
        position += buffer.byteLength;
        yield new Uint8Array(buffer);
      }
    }
  }
}
var import_streams, POOL_SIZE, _Blob, Blob2, fetch_blob_default;
var init_fetch_blob = __esm({
  "node_modules/fetch-blob/index.js"() {
    import_streams = __toESM(require_streams(), 1);
    POOL_SIZE = 65536;
    _Blob = class Blob {
      /** @type {Array.<(Blob|Uint8Array)>} */
      #parts = [];
      #type = "";
      #size = 0;
      #endings = "transparent";
      /**
       * The Blob() constructor returns a new Blob object. The content
       * of the blob consists of the concatenation of the values given
       * in the parameter array.
       *
       * @param {*} blobParts
       * @param {{ type?: string, endings?: string }} [options]
       */
      constructor(blobParts = [], options = {}) {
        if (typeof blobParts !== "object" || blobParts === null) {
          throw new TypeError("Failed to construct 'Blob': The provided value cannot be converted to a sequence.");
        }
        if (typeof blobParts[Symbol.iterator] !== "function") {
          throw new TypeError("Failed to construct 'Blob': The object must have a callable @@iterator property.");
        }
        if (typeof options !== "object" && typeof options !== "function") {
          throw new TypeError("Failed to construct 'Blob': parameter 2 cannot convert to dictionary.");
        }
        if (options === null) options = {};
        const encoder = new TextEncoder();
        for (const element of blobParts) {
          let part;
          if (ArrayBuffer.isView(element)) {
            part = new Uint8Array(element.buffer.slice(element.byteOffset, element.byteOffset + element.byteLength));
          } else if (element instanceof ArrayBuffer) {
            part = new Uint8Array(element.slice(0));
          } else if (element instanceof Blob) {
            part = element;
          } else {
            part = encoder.encode(`${element}`);
          }
          this.#size += ArrayBuffer.isView(part) ? part.byteLength : part.size;
          this.#parts.push(part);
        }
        this.#endings = `${options.endings === void 0 ? "transparent" : options.endings}`;
        const type = options.type === void 0 ? "" : String(options.type);
        this.#type = /^[\x20-\x7E]*$/.test(type) ? type : "";
      }
      /**
       * The Blob interface's size property returns the
       * size of the Blob in bytes.
       */
      get size() {
        return this.#size;
      }
      /**
       * The type property of a Blob object returns the MIME type of the file.
       */
      get type() {
        return this.#type;
      }
      /**
       * The text() method in the Blob interface returns a Promise
       * that resolves with a string containing the contents of
       * the blob, interpreted as UTF-8.
       *
       * @return {Promise<string>}
       */
      async text() {
        const decoder = new TextDecoder();
        let str = "";
        for await (const part of toIterator(this.#parts, false)) {
          str += decoder.decode(part, { stream: true });
        }
        str += decoder.decode();
        return str;
      }
      /**
       * The arrayBuffer() method in the Blob interface returns a
       * Promise that resolves with the contents of the blob as
       * binary data contained in an ArrayBuffer.
       *
       * @return {Promise<ArrayBuffer>}
       */
      async arrayBuffer() {
        const data = new Uint8Array(this.size);
        let offset = 0;
        for await (const chunk of toIterator(this.#parts, false)) {
          data.set(chunk, offset);
          offset += chunk.length;
        }
        return data.buffer;
      }
      stream() {
        const it = toIterator(this.#parts, true);
        return new globalThis.ReadableStream({
          // @ts-ignore
          type: "bytes",
          async pull(ctrl) {
            const chunk = await it.next();
            chunk.done ? ctrl.close() : ctrl.enqueue(chunk.value);
          },
          async cancel() {
            await it.return();
          }
        });
      }
      /**
       * The Blob interface's slice() method creates and returns a
       * new Blob object which contains data from a subset of the
       * blob on which it's called.
       *
       * @param {number} [start]
       * @param {number} [end]
       * @param {string} [type]
       */
      slice(start = 0, end = this.size, type = "") {
        const { size } = this;
        let relativeStart = start < 0 ? Math.max(size + start, 0) : Math.min(start, size);
        let relativeEnd = end < 0 ? Math.max(size + end, 0) : Math.min(end, size);
        const span = Math.max(relativeEnd - relativeStart, 0);
        const parts = this.#parts;
        const blobParts = [];
        let added = 0;
        for (const part of parts) {
          if (added >= span) {
            break;
          }
          const size2 = ArrayBuffer.isView(part) ? part.byteLength : part.size;
          if (relativeStart && size2 <= relativeStart) {
            relativeStart -= size2;
            relativeEnd -= size2;
          } else {
            let chunk;
            if (ArrayBuffer.isView(part)) {
              chunk = part.subarray(relativeStart, Math.min(size2, relativeEnd));
              added += chunk.byteLength;
            } else {
              chunk = part.slice(relativeStart, Math.min(size2, relativeEnd));
              added += chunk.size;
            }
            relativeEnd -= size2;
            blobParts.push(chunk);
            relativeStart = 0;
          }
        }
        const blob = new Blob([], { type: String(type).toLowerCase() });
        blob.#size = span;
        blob.#parts = blobParts;
        return blob;
      }
      get [Symbol.toStringTag]() {
        return "Blob";
      }
      static [Symbol.hasInstance](object) {
        return object && typeof object === "object" && typeof object.constructor === "function" && (typeof object.stream === "function" || typeof object.arrayBuffer === "function") && /^(Blob|File)$/.test(object[Symbol.toStringTag]);
      }
    };
    Object.defineProperties(_Blob.prototype, {
      size: { enumerable: true },
      type: { enumerable: true },
      slice: { enumerable: true }
    });
    Blob2 = _Blob;
    fetch_blob_default = Blob2;
  }
});

// node_modules/fetch-blob/file.js
var _File, File2, file_default;
var init_file = __esm({
  "node_modules/fetch-blob/file.js"() {
    init_fetch_blob();
    _File = class File extends fetch_blob_default {
      #lastModified = 0;
      #name = "";
      /**
       * @param {*[]} fileBits
       * @param {string} fileName
       * @param {{lastModified?: number, type?: string}} options
       */
      // @ts-ignore
      constructor(fileBits, fileName, options = {}) {
        if (arguments.length < 2) {
          throw new TypeError(`Failed to construct 'File': 2 arguments required, but only ${arguments.length} present.`);
        }
        super(fileBits, options);
        if (options === null) options = {};
        const lastModified = options.lastModified === void 0 ? Date.now() : Number(options.lastModified);
        if (!Number.isNaN(lastModified)) {
          this.#lastModified = lastModified;
        }
        this.#name = String(fileName);
      }
      get name() {
        return this.#name;
      }
      get lastModified() {
        return this.#lastModified;
      }
      get [Symbol.toStringTag]() {
        return "File";
      }
      static [Symbol.hasInstance](object) {
        return !!object && object instanceof fetch_blob_default && /^(File)$/.test(object[Symbol.toStringTag]);
      }
    };
    File2 = _File;
    file_default = File2;
  }
});

// node_modules/formdata-polyfill/esm.min.js
function formDataToBlob(F2, B = fetch_blob_default) {
  var b = `${r()}${r()}`.replace(/\./g, "").slice(-28).padStart(32, "-"), c = [], p = `--${b}\r
Content-Disposition: form-data; name="`;
  F2.forEach((v, n) => typeof v == "string" ? c.push(p + e(n) + `"\r
\r
${v.replace(/\r(?!\n)|(?<!\r)\n/g, "\r\n")}\r
`) : c.push(p + e(n) + `"; filename="${e(v.name, 1)}"\r
Content-Type: ${v.type || "application/octet-stream"}\r
\r
`, v, "\r\n"));
  c.push(`--${b}--`);
  return new B(c, { type: "multipart/form-data; boundary=" + b });
}
var t, i, h, r, m, f, e, x, FormData;
var init_esm_min = __esm({
  "node_modules/formdata-polyfill/esm.min.js"() {
    init_fetch_blob();
    init_file();
    ({ toStringTag: t, iterator: i, hasInstance: h } = Symbol);
    r = Math.random;
    m = "append,set,get,getAll,delete,keys,values,entries,forEach,constructor".split(",");
    f = (a, b, c) => (a += "", /^(Blob|File)$/.test(b && b[t]) ? [(c = c !== void 0 ? c + "" : b[t] == "File" ? b.name : "blob", a), b.name !== c || b[t] == "blob" ? new file_default([b], c, b) : b] : [a, b + ""]);
    e = (c, f3) => (f3 ? c : c.replace(/\r?\n|\r/g, "\r\n")).replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22");
    x = (n, a, e2) => {
      if (a.length < e2) {
        throw new TypeError(`Failed to execute '${n}' on 'FormData': ${e2} arguments required, but only ${a.length} present.`);
      }
    };
    FormData = class FormData2 {
      #d = [];
      constructor(...a) {
        if (a.length) throw new TypeError(`Failed to construct 'FormData': parameter 1 is not of type 'HTMLFormElement'.`);
      }
      get [t]() {
        return "FormData";
      }
      [i]() {
        return this.entries();
      }
      static [h](o) {
        return o && typeof o === "object" && o[t] === "FormData" && !m.some((m2) => typeof o[m2] != "function");
      }
      append(...a) {
        x("append", arguments, 2);
        this.#d.push(f(...a));
      }
      delete(a) {
        x("delete", arguments, 1);
        a += "";
        this.#d = this.#d.filter(([b]) => b !== a);
      }
      get(a) {
        x("get", arguments, 1);
        a += "";
        for (var b = this.#d, l = b.length, c = 0; c < l; c++) if (b[c][0] === a) return b[c][1];
        return null;
      }
      getAll(a, b) {
        x("getAll", arguments, 1);
        b = [];
        a += "";
        this.#d.forEach((c) => c[0] === a && b.push(c[1]));
        return b;
      }
      has(a) {
        x("has", arguments, 1);
        a += "";
        return this.#d.some((b) => b[0] === a);
      }
      forEach(a, b) {
        x("forEach", arguments, 1);
        for (var [c, d] of this) a.call(b, d, c, this);
      }
      set(...a) {
        x("set", arguments, 2);
        var b = [], c = true;
        a = f(...a);
        this.#d.forEach((d) => {
          d[0] === a[0] ? c && (c = !b.push(a)) : b.push(d);
        });
        c && b.push(a);
        this.#d = b;
      }
      *entries() {
        yield* this.#d;
      }
      *keys() {
        for (var [a] of this) yield a;
      }
      *values() {
        for (var [, a] of this) yield a;
      }
    };
  }
});

// node_modules/node-domexception/index.js
var require_node_domexception = __commonJS({
  "node_modules/node-domexception/index.js"(exports2, module2) {
    if (!globalThis.DOMException) {
      try {
        const { MessageChannel } = require("worker_threads"), port = new MessageChannel().port1, ab = new ArrayBuffer();
        port.postMessage(ab, [ab, ab]);
      } catch (err) {
        err.constructor.name === "DOMException" && (globalThis.DOMException = err.constructor);
      }
    }
    module2.exports = globalThis.DOMException;
  }
});

// node_modules/fetch-blob/from.js
var import_node_fs, import_node_domexception, stat;
var init_from = __esm({
  "node_modules/fetch-blob/from.js"() {
    import_node_fs = require("node:fs");
    import_node_domexception = __toESM(require_node_domexception(), 1);
    init_file();
    init_fetch_blob();
    ({ stat } = import_node_fs.promises);
  }
});

// node_modules/node-fetch/src/utils/multipart-parser.js
var multipart_parser_exports = {};
__export(multipart_parser_exports, {
  toFormData: () => toFormData
});
function _fileName(headerValue) {
  const m2 = headerValue.match(/\bfilename=("(.*?)"|([^()<>@,;:\\"/[\]?={}\s\t]+))($|;\s)/i);
  if (!m2) {
    return;
  }
  const match = m2[2] || m2[3] || "";
  let filename = match.slice(match.lastIndexOf("\\") + 1);
  filename = filename.replace(/%22/g, '"');
  filename = filename.replace(/&#(\d{4});/g, (m3, code) => {
    return String.fromCharCode(code);
  });
  return filename;
}
async function toFormData(Body2, ct) {
  if (!/multipart/i.test(ct)) {
    throw new TypeError("Failed to fetch");
  }
  const m2 = ct.match(/boundary=(?:"([^"]+)"|([^;]+))/i);
  if (!m2) {
    throw new TypeError("no or bad content-type header, no multipart boundary");
  }
  const parser = new MultipartParser(m2[1] || m2[2]);
  let headerField;
  let headerValue;
  let entryValue;
  let entryName;
  let contentType;
  let filename;
  const entryChunks = [];
  const formData = new FormData();
  const onPartData = (ui8a) => {
    entryValue += decoder.decode(ui8a, { stream: true });
  };
  const appendToFile = (ui8a) => {
    entryChunks.push(ui8a);
  };
  const appendFileToFormData = () => {
    const file2 = new file_default(entryChunks, filename, { type: contentType });
    formData.append(entryName, file2);
  };
  const appendEntryToFormData = () => {
    formData.append(entryName, entryValue);
  };
  const decoder = new TextDecoder("utf-8");
  decoder.decode();
  parser.onPartBegin = function() {
    parser.onPartData = onPartData;
    parser.onPartEnd = appendEntryToFormData;
    headerField = "";
    headerValue = "";
    entryValue = "";
    entryName = "";
    contentType = "";
    filename = null;
    entryChunks.length = 0;
  };
  parser.onHeaderField = function(ui8a) {
    headerField += decoder.decode(ui8a, { stream: true });
  };
  parser.onHeaderValue = function(ui8a) {
    headerValue += decoder.decode(ui8a, { stream: true });
  };
  parser.onHeaderEnd = function() {
    headerValue += decoder.decode();
    headerField = headerField.toLowerCase();
    if (headerField === "content-disposition") {
      const m3 = headerValue.match(/\bname=("([^"]*)"|([^()<>@,;:\\"/[\]?={}\s\t]+))/i);
      if (m3) {
        entryName = m3[2] || m3[3] || "";
      }
      filename = _fileName(headerValue);
      if (filename) {
        parser.onPartData = appendToFile;
        parser.onPartEnd = appendFileToFormData;
      }
    } else if (headerField === "content-type") {
      contentType = headerValue;
    }
    headerValue = "";
    headerField = "";
  };
  for await (const chunk of Body2) {
    parser.write(chunk);
  }
  parser.end();
  return formData;
}
var s, S, f2, F, LF, CR, SPACE, HYPHEN, COLON, A, Z, lower, noop, MultipartParser;
var init_multipart_parser = __esm({
  "node_modules/node-fetch/src/utils/multipart-parser.js"() {
    init_from();
    init_esm_min();
    s = 0;
    S = {
      START_BOUNDARY: s++,
      HEADER_FIELD_START: s++,
      HEADER_FIELD: s++,
      HEADER_VALUE_START: s++,
      HEADER_VALUE: s++,
      HEADER_VALUE_ALMOST_DONE: s++,
      HEADERS_ALMOST_DONE: s++,
      PART_DATA_START: s++,
      PART_DATA: s++,
      END: s++
    };
    f2 = 1;
    F = {
      PART_BOUNDARY: f2,
      LAST_BOUNDARY: f2 *= 2
    };
    LF = 10;
    CR = 13;
    SPACE = 32;
    HYPHEN = 45;
    COLON = 58;
    A = 97;
    Z = 122;
    lower = (c) => c | 32;
    noop = () => {
    };
    MultipartParser = class {
      /**
       * @param {string} boundary
       */
      constructor(boundary) {
        this.index = 0;
        this.flags = 0;
        this.onHeaderEnd = noop;
        this.onHeaderField = noop;
        this.onHeadersEnd = noop;
        this.onHeaderValue = noop;
        this.onPartBegin = noop;
        this.onPartData = noop;
        this.onPartEnd = noop;
        this.boundaryChars = {};
        boundary = "\r\n--" + boundary;
        const ui8a = new Uint8Array(boundary.length);
        for (let i2 = 0; i2 < boundary.length; i2++) {
          ui8a[i2] = boundary.charCodeAt(i2);
          this.boundaryChars[ui8a[i2]] = true;
        }
        this.boundary = ui8a;
        this.lookbehind = new Uint8Array(this.boundary.length + 8);
        this.state = S.START_BOUNDARY;
      }
      /**
       * @param {Uint8Array} data
       */
      write(data) {
        let i2 = 0;
        const length_ = data.length;
        let previousIndex = this.index;
        let { lookbehind, boundary, boundaryChars, index, state, flags } = this;
        const boundaryLength = this.boundary.length;
        const boundaryEnd = boundaryLength - 1;
        const bufferLength = data.length;
        let c;
        let cl;
        const mark = (name) => {
          this[name + "Mark"] = i2;
        };
        const clear = (name) => {
          delete this[name + "Mark"];
        };
        const callback = (callbackSymbol, start, end, ui8a) => {
          if (start === void 0 || start !== end) {
            this[callbackSymbol](ui8a && ui8a.subarray(start, end));
          }
        };
        const dataCallback = (name, clear2) => {
          const markSymbol = name + "Mark";
          if (!(markSymbol in this)) {
            return;
          }
          if (clear2) {
            callback(name, this[markSymbol], i2, data);
            delete this[markSymbol];
          } else {
            callback(name, this[markSymbol], data.length, data);
            this[markSymbol] = 0;
          }
        };
        for (i2 = 0; i2 < length_; i2++) {
          c = data[i2];
          switch (state) {
            case S.START_BOUNDARY:
              if (index === boundary.length - 2) {
                if (c === HYPHEN) {
                  flags |= F.LAST_BOUNDARY;
                } else if (c !== CR) {
                  return;
                }
                index++;
                break;
              } else if (index - 1 === boundary.length - 2) {
                if (flags & F.LAST_BOUNDARY && c === HYPHEN) {
                  state = S.END;
                  flags = 0;
                } else if (!(flags & F.LAST_BOUNDARY) && c === LF) {
                  index = 0;
                  callback("onPartBegin");
                  state = S.HEADER_FIELD_START;
                } else {
                  return;
                }
                break;
              }
              if (c !== boundary[index + 2]) {
                index = -2;
              }
              if (c === boundary[index + 2]) {
                index++;
              }
              break;
            case S.HEADER_FIELD_START:
              state = S.HEADER_FIELD;
              mark("onHeaderField");
              index = 0;
            // falls through
            case S.HEADER_FIELD:
              if (c === CR) {
                clear("onHeaderField");
                state = S.HEADERS_ALMOST_DONE;
                break;
              }
              index++;
              if (c === HYPHEN) {
                break;
              }
              if (c === COLON) {
                if (index === 1) {
                  return;
                }
                dataCallback("onHeaderField", true);
                state = S.HEADER_VALUE_START;
                break;
              }
              cl = lower(c);
              if (cl < A || cl > Z) {
                return;
              }
              break;
            case S.HEADER_VALUE_START:
              if (c === SPACE) {
                break;
              }
              mark("onHeaderValue");
              state = S.HEADER_VALUE;
            // falls through
            case S.HEADER_VALUE:
              if (c === CR) {
                dataCallback("onHeaderValue", true);
                callback("onHeaderEnd");
                state = S.HEADER_VALUE_ALMOST_DONE;
              }
              break;
            case S.HEADER_VALUE_ALMOST_DONE:
              if (c !== LF) {
                return;
              }
              state = S.HEADER_FIELD_START;
              break;
            case S.HEADERS_ALMOST_DONE:
              if (c !== LF) {
                return;
              }
              callback("onHeadersEnd");
              state = S.PART_DATA_START;
              break;
            case S.PART_DATA_START:
              state = S.PART_DATA;
              mark("onPartData");
            // falls through
            case S.PART_DATA:
              previousIndex = index;
              if (index === 0) {
                i2 += boundaryEnd;
                while (i2 < bufferLength && !(data[i2] in boundaryChars)) {
                  i2 += boundaryLength;
                }
                i2 -= boundaryEnd;
                c = data[i2];
              }
              if (index < boundary.length) {
                if (boundary[index] === c) {
                  if (index === 0) {
                    dataCallback("onPartData", true);
                  }
                  index++;
                } else {
                  index = 0;
                }
              } else if (index === boundary.length) {
                index++;
                if (c === CR) {
                  flags |= F.PART_BOUNDARY;
                } else if (c === HYPHEN) {
                  flags |= F.LAST_BOUNDARY;
                } else {
                  index = 0;
                }
              } else if (index - 1 === boundary.length) {
                if (flags & F.PART_BOUNDARY) {
                  index = 0;
                  if (c === LF) {
                    flags &= ~F.PART_BOUNDARY;
                    callback("onPartEnd");
                    callback("onPartBegin");
                    state = S.HEADER_FIELD_START;
                    break;
                  }
                } else if (flags & F.LAST_BOUNDARY) {
                  if (c === HYPHEN) {
                    callback("onPartEnd");
                    state = S.END;
                    flags = 0;
                  } else {
                    index = 0;
                  }
                } else {
                  index = 0;
                }
              }
              if (index > 0) {
                lookbehind[index - 1] = c;
              } else if (previousIndex > 0) {
                const _lookbehind = new Uint8Array(lookbehind.buffer, lookbehind.byteOffset, lookbehind.byteLength);
                callback("onPartData", 0, previousIndex, _lookbehind);
                previousIndex = 0;
                mark("onPartData");
                i2--;
              }
              break;
            case S.END:
              break;
            default:
              throw new Error(`Unexpected state entered: ${state}`);
          }
        }
        dataCallback("onHeaderField");
        dataCallback("onHeaderValue");
        dataCallback("onPartData");
        this.index = index;
        this.state = state;
        this.flags = flags;
      }
      end() {
        if (this.state === S.HEADER_FIELD_START && this.index === 0 || this.state === S.PART_DATA && this.index === this.boundary.length) {
          this.onPartEnd();
        } else if (this.state !== S.END) {
          throw new Error("MultipartParser.end(): stream ended unexpectedly");
        }
      }
    };
  }
});

// node_modules/dotenv/package.json
var require_package = __commonJS({
  "node_modules/dotenv/package.json"(exports2, module2) {
    module2.exports = {
      name: "dotenv",
      version: "16.4.7",
      description: "Loads environment variables from .env file",
      main: "lib/main.js",
      types: "lib/main.d.ts",
      exports: {
        ".": {
          types: "./lib/main.d.ts",
          require: "./lib/main.js",
          default: "./lib/main.js"
        },
        "./config": "./config.js",
        "./config.js": "./config.js",
        "./lib/env-options": "./lib/env-options.js",
        "./lib/env-options.js": "./lib/env-options.js",
        "./lib/cli-options": "./lib/cli-options.js",
        "./lib/cli-options.js": "./lib/cli-options.js",
        "./package.json": "./package.json"
      },
      scripts: {
        "dts-check": "tsc --project tests/types/tsconfig.json",
        lint: "standard",
        pretest: "npm run lint && npm run dts-check",
        test: "tap run --allow-empty-coverage --disable-coverage --timeout=60000",
        "test:coverage": "tap run --show-full-coverage --timeout=60000 --coverage-report=lcov",
        prerelease: "npm test",
        release: "standard-version"
      },
      repository: {
        type: "git",
        url: "git://github.com/motdotla/dotenv.git"
      },
      funding: "https://dotenvx.com",
      keywords: [
        "dotenv",
        "env",
        ".env",
        "environment",
        "variables",
        "config",
        "settings"
      ],
      readmeFilename: "README.md",
      license: "BSD-2-Clause",
      devDependencies: {
        "@types/node": "^18.11.3",
        decache: "^4.6.2",
        sinon: "^14.0.1",
        standard: "^17.0.0",
        "standard-version": "^9.5.0",
        tap: "^19.2.0",
        typescript: "^4.8.4"
      },
      engines: {
        node: ">=12"
      },
      browser: {
        fs: false
      }
    };
  }
});

// node_modules/dotenv/lib/main.js
var require_main = __commonJS({
  "node_modules/dotenv/lib/main.js"(exports2, module2) {
    var fs3 = require("fs");
    var path = require("path");
    var os = require("os");
    var crypto3 = require("crypto");
    var packageJson = require_package();
    var version = packageJson.version;
    var LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
    function parse(src) {
      const obj = {};
      let lines = src.toString();
      lines = lines.replace(/\r\n?/mg, "\n");
      let match;
      while ((match = LINE.exec(lines)) != null) {
        const key = match[1];
        let value = match[2] || "";
        value = value.trim();
        const maybeQuote = value[0];
        value = value.replace(/^(['"`])([\s\S]*)\1$/mg, "$2");
        if (maybeQuote === '"') {
          value = value.replace(/\\n/g, "\n");
          value = value.replace(/\\r/g, "\r");
        }
        obj[key] = value;
      }
      return obj;
    }
    function _parseVault(options) {
      const vaultPath = _vaultPath(options);
      const result = DotenvModule.configDotenv({ path: vaultPath });
      if (!result.parsed) {
        const err = new Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`);
        err.code = "MISSING_DATA";
        throw err;
      }
      const keys = _dotenvKey(options).split(",");
      const length = keys.length;
      let decrypted;
      for (let i2 = 0; i2 < length; i2++) {
        try {
          const key = keys[i2].trim();
          const attrs = _instructions(result, key);
          decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key);
          break;
        } catch (error) {
          if (i2 + 1 >= length) {
            throw error;
          }
        }
      }
      return DotenvModule.parse(decrypted);
    }
    function _log(message) {
      console.log(`[dotenv@${version}][INFO] ${message}`);
    }
    function _warn(message) {
      console.log(`[dotenv@${version}][WARN] ${message}`);
    }
    function _debug(message) {
      console.log(`[dotenv@${version}][DEBUG] ${message}`);
    }
    function _dotenvKey(options) {
      if (options && options.DOTENV_KEY && options.DOTENV_KEY.length > 0) {
        return options.DOTENV_KEY;
      }
      if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) {
        return process.env.DOTENV_KEY;
      }
      return "";
    }
    function _instructions(result, dotenvKey) {
      let uri;
      try {
        uri = new URL(dotenvKey);
      } catch (error) {
        if (error.code === "ERR_INVALID_URL") {
          const err = new Error("INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development");
          err.code = "INVALID_DOTENV_KEY";
          throw err;
        }
        throw error;
      }
      const key = uri.password;
      if (!key) {
        const err = new Error("INVALID_DOTENV_KEY: Missing key part");
        err.code = "INVALID_DOTENV_KEY";
        throw err;
      }
      const environment = uri.searchParams.get("environment");
      if (!environment) {
        const err = new Error("INVALID_DOTENV_KEY: Missing environment part");
        err.code = "INVALID_DOTENV_KEY";
        throw err;
      }
      const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`;
      const ciphertext = result.parsed[environmentKey];
      if (!ciphertext) {
        const err = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`);
        err.code = "NOT_FOUND_DOTENV_ENVIRONMENT";
        throw err;
      }
      return { ciphertext, key };
    }
    function _vaultPath(options) {
      let possibleVaultPath = null;
      if (options && options.path && options.path.length > 0) {
        if (Array.isArray(options.path)) {
          for (const filepath of options.path) {
            if (fs3.existsSync(filepath)) {
              possibleVaultPath = filepath.endsWith(".vault") ? filepath : `${filepath}.vault`;
            }
          }
        } else {
          possibleVaultPath = options.path.endsWith(".vault") ? options.path : `${options.path}.vault`;
        }
      } else {
        possibleVaultPath = path.resolve(process.cwd(), ".env.vault");
      }
      if (fs3.existsSync(possibleVaultPath)) {
        return possibleVaultPath;
      }
      return null;
    }
    function _resolveHome(envPath) {
      return envPath[0] === "~" ? path.join(os.homedir(), envPath.slice(1)) : envPath;
    }
    function _configVault(options) {
      _log("Loading env from encrypted .env.vault");
      const parsed = DotenvModule._parseVault(options);
      let processEnv = process.env;
      if (options && options.processEnv != null) {
        processEnv = options.processEnv;
      }
      DotenvModule.populate(processEnv, parsed, options);
      return { parsed };
    }
    function configDotenv(options) {
      const dotenvPath = path.resolve(process.cwd(), ".env");
      let encoding = "utf8";
      const debug = Boolean(options && options.debug);
      if (options && options.encoding) {
        encoding = options.encoding;
      } else {
        if (debug) {
          _debug("No encoding is specified. UTF-8 is used by default");
        }
      }
      let optionPaths = [dotenvPath];
      if (options && options.path) {
        if (!Array.isArray(options.path)) {
          optionPaths = [_resolveHome(options.path)];
        } else {
          optionPaths = [];
          for (const filepath of options.path) {
            optionPaths.push(_resolveHome(filepath));
          }
        }
      }
      let lastError;
      const parsedAll = {};
      for (const path2 of optionPaths) {
        try {
          const parsed = DotenvModule.parse(fs3.readFileSync(path2, { encoding }));
          DotenvModule.populate(parsedAll, parsed, options);
        } catch (e2) {
          if (debug) {
            _debug(`Failed to load ${path2} ${e2.message}`);
          }
          lastError = e2;
        }
      }
      let processEnv = process.env;
      if (options && options.processEnv != null) {
        processEnv = options.processEnv;
      }
      DotenvModule.populate(processEnv, parsedAll, options);
      if (lastError) {
        return { parsed: parsedAll, error: lastError };
      } else {
        return { parsed: parsedAll };
      }
    }
    function config2(options) {
      if (_dotenvKey(options).length === 0) {
        return DotenvModule.configDotenv(options);
      }
      const vaultPath = _vaultPath(options);
      if (!vaultPath) {
        _warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`);
        return DotenvModule.configDotenv(options);
      }
      return DotenvModule._configVault(options);
    }
    function decrypt(encrypted, keyStr) {
      const key = Buffer.from(keyStr.slice(-64), "hex");
      let ciphertext = Buffer.from(encrypted, "base64");
      const nonce = ciphertext.subarray(0, 12);
      const authTag = ciphertext.subarray(-16);
      ciphertext = ciphertext.subarray(12, -16);
      try {
        const aesgcm = crypto3.createDecipheriv("aes-256-gcm", key, nonce);
        aesgcm.setAuthTag(authTag);
        return `${aesgcm.update(ciphertext)}${aesgcm.final()}`;
      } catch (error) {
        const isRange = error instanceof RangeError;
        const invalidKeyLength = error.message === "Invalid key length";
        const decryptionFailed = error.message === "Unsupported state or unable to authenticate data";
        if (isRange || invalidKeyLength) {
          const err = new Error("INVALID_DOTENV_KEY: It must be 64 characters long (or more)");
          err.code = "INVALID_DOTENV_KEY";
          throw err;
        } else if (decryptionFailed) {
          const err = new Error("DECRYPTION_FAILED: Please check your DOTENV_KEY");
          err.code = "DECRYPTION_FAILED";
          throw err;
        } else {
          throw error;
        }
      }
    }
    function populate(processEnv, parsed, options = {}) {
      const debug = Boolean(options && options.debug);
      const override = Boolean(options && options.override);
      if (typeof parsed !== "object") {
        const err = new Error("OBJECT_REQUIRED: Please check the processEnv argument being passed to populate");
        err.code = "OBJECT_REQUIRED";
        throw err;
      }
      for (const key of Object.keys(parsed)) {
        if (Object.prototype.hasOwnProperty.call(processEnv, key)) {
          if (override === true) {
            processEnv[key] = parsed[key];
          }
          if (debug) {
            if (override === true) {
              _debug(`"${key}" is already defined and WAS overwritten`);
            } else {
              _debug(`"${key}" is already defined and was NOT overwritten`);
            }
          }
        } else {
          processEnv[key] = parsed[key];
        }
      }
    }
    var DotenvModule = {
      configDotenv,
      _configVault,
      _parseVault,
      config: config2,
      decrypt,
      parse,
      populate
    };
    module2.exports.configDotenv = DotenvModule.configDotenv;
    module2.exports._configVault = DotenvModule._configVault;
    module2.exports._parseVault = DotenvModule._parseVault;
    module2.exports.config = DotenvModule.config;
    module2.exports.decrypt = DotenvModule.decrypt;
    module2.exports.parse = DotenvModule.parse;
    module2.exports.populate = DotenvModule.populate;
    module2.exports = DotenvModule;
  }
});

// node_modules/ws/lib/constants.js
var require_constants = __commonJS({
  "node_modules/ws/lib/constants.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      BINARY_TYPES: ["nodebuffer", "arraybuffer", "fragments"],
      GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
      kStatusCode: Symbol("status-code"),
      kWebSocket: Symbol("websocket"),
      EMPTY_BUFFER: Buffer.alloc(0),
      NOOP: () => {
      }
    };
  }
});

// node_modules/ws/lib/buffer-util.js
var require_buffer_util = __commonJS({
  "node_modules/ws/lib/buffer-util.js"(exports2, module2) {
    "use strict";
    var { EMPTY_BUFFER } = require_constants();
    function concat(list, totalLength) {
      if (list.length === 0) return EMPTY_BUFFER;
      if (list.length === 1) return list[0];
      const target = Buffer.allocUnsafe(totalLength);
      let offset = 0;
      for (let i2 = 0; i2 < list.length; i2++) {
        const buf = list[i2];
        target.set(buf, offset);
        offset += buf.length;
      }
      if (offset < totalLength) return target.slice(0, offset);
      return target;
    }
    function _mask(source, mask, output, offset, length) {
      for (let i2 = 0; i2 < length; i2++) {
        output[offset + i2] = source[i2] ^ mask[i2 & 3];
      }
    }
    function _unmask(buffer, mask) {
      const length = buffer.length;
      for (let i2 = 0; i2 < length; i2++) {
        buffer[i2] ^= mask[i2 & 3];
      }
    }
    function toArrayBuffer(buf) {
      if (buf.byteLength === buf.buffer.byteLength) {
        return buf.buffer;
      }
      return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
    }
    function toBuffer(data) {
      toBuffer.readOnly = true;
      if (Buffer.isBuffer(data)) return data;
      let buf;
      if (data instanceof ArrayBuffer) {
        buf = Buffer.from(data);
      } else if (ArrayBuffer.isView(data)) {
        buf = Buffer.from(data.buffer, data.byteOffset, data.byteLength);
      } else {
        buf = Buffer.from(data);
        toBuffer.readOnly = false;
      }
      return buf;
    }
    try {
      const bufferUtil = require("bufferutil");
      const bu = bufferUtil.BufferUtil || bufferUtil;
      module2.exports = {
        concat,
        mask(source, mask, output, offset, length) {
          if (length < 48) _mask(source, mask, output, offset, length);
          else bu.mask(source, mask, output, offset, length);
        },
        toArrayBuffer,
        toBuffer,
        unmask(buffer, mask) {
          if (buffer.length < 32) _unmask(buffer, mask);
          else bu.unmask(buffer, mask);
        }
      };
    } catch (e2) {
      module2.exports = {
        concat,
        mask: _mask,
        toArrayBuffer,
        toBuffer,
        unmask: _unmask
      };
    }
  }
});

// node_modules/ws/lib/limiter.js
var require_limiter = __commonJS({
  "node_modules/ws/lib/limiter.js"(exports2, module2) {
    "use strict";
    var kDone = Symbol("kDone");
    var kRun = Symbol("kRun");
    var Limiter = class {
      /**
       * Creates a new `Limiter`.
       *
       * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed
       *     to run concurrently
       */
      constructor(concurrency) {
        this[kDone] = () => {
          this.pending--;
          this[kRun]();
        };
        this.concurrency = concurrency || Infinity;
        this.jobs = [];
        this.pending = 0;
      }
      /**
       * Adds a job to the queue.
       *
       * @param {Function} job The job to run
       * @public
       */
      add(job) {
        this.jobs.push(job);
        this[kRun]();
      }
      /**
       * Removes a job from the queue and runs it if possible.
       *
       * @private
       */
      [kRun]() {
        if (this.pending === this.concurrency) return;
        if (this.jobs.length) {
          const job = this.jobs.shift();
          this.pending++;
          job(this[kDone]);
        }
      }
    };
    module2.exports = Limiter;
  }
});

// node_modules/ws/lib/permessage-deflate.js
var require_permessage_deflate = __commonJS({
  "node_modules/ws/lib/permessage-deflate.js"(exports2, module2) {
    "use strict";
    var zlib2 = require("zlib");
    var bufferUtil = require_buffer_util();
    var Limiter = require_limiter();
    var { kStatusCode, NOOP } = require_constants();
    var TRAILER = Buffer.from([0, 0, 255, 255]);
    var kPerMessageDeflate = Symbol("permessage-deflate");
    var kTotalLength = Symbol("total-length");
    var kCallback = Symbol("callback");
    var kBuffers = Symbol("buffers");
    var kError = Symbol("error");
    var zlibLimiter;
    var PerMessageDeflate = class {
      /**
       * Creates a PerMessageDeflate instance.
       *
       * @param {Object} [options] Configuration options
       * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept
       *     disabling of server context takeover
       * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/
       *     acknowledge disabling of client context takeover
       * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the
       *     use of a custom server window size
       * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support
       *     for, or request, a custom client window size
       * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on
       *     deflate
       * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on
       *     inflate
       * @param {Number} [options.threshold=1024] Size (in bytes) below which
       *     messages should not be compressed
       * @param {Number} [options.concurrencyLimit=10] The number of concurrent
       *     calls to zlib
       * @param {Boolean} [isServer=false] Create the instance in either server or
       *     client mode
       * @param {Number} [maxPayload=0] The maximum allowed message length
       */
      constructor(options, isServer, maxPayload) {
        this._maxPayload = maxPayload | 0;
        this._options = options || {};
        this._threshold = this._options.threshold !== void 0 ? this._options.threshold : 1024;
        this._isServer = !!isServer;
        this._deflate = null;
        this._inflate = null;
        this.params = null;
        if (!zlibLimiter) {
          const concurrency = this._options.concurrencyLimit !== void 0 ? this._options.concurrencyLimit : 10;
          zlibLimiter = new Limiter(concurrency);
        }
      }
      /**
       * @type {String}
       */
      static get extensionName() {
        return "permessage-deflate";
      }
      /**
       * Create an extension negotiation offer.
       *
       * @return {Object} Extension parameters
       * @public
       */
      offer() {
        const params = {};
        if (this._options.serverNoContextTakeover) {
          params.server_no_context_takeover = true;
        }
        if (this._options.clientNoContextTakeover) {
          params.client_no_context_takeover = true;
        }
        if (this._options.serverMaxWindowBits) {
          params.server_max_window_bits = this._options.serverMaxWindowBits;
        }
        if (this._options.clientMaxWindowBits) {
          params.client_max_window_bits = this._options.clientMaxWindowBits;
        } else if (this._options.clientMaxWindowBits == null) {
          params.client_max_window_bits = true;
        }
        return params;
      }
      /**
       * Accept an extension negotiation offer/response.
       *
       * @param {Array} configurations The extension negotiation offers/reponse
       * @return {Object} Accepted configuration
       * @public
       */
      accept(configurations) {
        configurations = this.normalizeParams(configurations);
        this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
        return this.params;
      }
      /**
       * Releases all resources used by the extension.
       *
       * @public
       */
      cleanup() {
        if (this._inflate) {
          this._inflate.close();
          this._inflate = null;
        }
        if (this._deflate) {
          const callback = this._deflate[kCallback];
          this._deflate.close();
          this._deflate = null;
          if (callback) {
            callback(
              new Error(
                "The deflate stream was closed while data was being processed"
              )
            );
          }
        }
      }
      /**
       *  Accept an extension negotiation offer.
       *
       * @param {Array} offers The extension negotiation offers
       * @return {Object} Accepted configuration
       * @private
       */
      acceptAsServer(offers) {
        const opts = this._options;
        const accepted = offers.find((params) => {
          if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === "number" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === "number" && !params.client_max_window_bits) {
            return false;
          }
          return true;
        });
        if (!accepted) {
          throw new Error("None of the extension offers can be accepted");
        }
        if (opts.serverNoContextTakeover) {
          accepted.server_no_context_takeover = true;
        }
        if (opts.clientNoContextTakeover) {
          accepted.client_no_context_takeover = true;
        }
        if (typeof opts.serverMaxWindowBits === "number") {
          accepted.server_max_window_bits = opts.serverMaxWindowBits;
        }
        if (typeof opts.clientMaxWindowBits === "number") {
          accepted.client_max_window_bits = opts.clientMaxWindowBits;
        } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
          delete accepted.client_max_window_bits;
        }
        return accepted;
      }
      /**
       * Accept the extension negotiation response.
       *
       * @param {Array} response The extension negotiation response
       * @return {Object} Accepted configuration
       * @private
       */
      acceptAsClient(response) {
        const params = response[0];
        if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {
          throw new Error('Unexpected parameter "client_no_context_takeover"');
        }
        if (!params.client_max_window_bits) {
          if (typeof this._options.clientMaxWindowBits === "number") {
            params.client_max_window_bits = this._options.clientMaxWindowBits;
          }
        } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === "number" && params.client_max_window_bits > this._options.clientMaxWindowBits) {
          throw new Error(
            'Unexpected or invalid parameter "client_max_window_bits"'
          );
        }
        return params;
      }
      /**
       * Normalize parameters.
       *
       * @param {Array} configurations The extension negotiation offers/reponse
       * @return {Array} The offers/response with normalized parameters
       * @private
       */
      normalizeParams(configurations) {
        configurations.forEach((params) => {
          Object.keys(params).forEach((key) => {
            let value = params[key];
            if (value.length > 1) {
              throw new Error(`Parameter "${key}" must have only a single value`);
            }
            value = value[0];
            if (key === "client_max_window_bits") {
              if (value !== true) {
                const num = +value;
                if (!Number.isInteger(num) || num < 8 || num > 15) {
                  throw new TypeError(
                    `Invalid value for parameter "${key}": ${value}`
                  );
                }
                value = num;
              } else if (!this._isServer) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
            } else if (key === "server_max_window_bits") {
              const num = +value;
              if (!Number.isInteger(num) || num < 8 || num > 15) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
              value = num;
            } else if (key === "client_no_context_takeover" || key === "server_no_context_takeover") {
              if (value !== true) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
            } else {
              throw new Error(`Unknown parameter "${key}"`);
            }
            params[key] = value;
          });
        });
        return configurations;
      }
      /**
       * Decompress data. Concurrency limited.
       *
       * @param {Buffer} data Compressed data
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @public
       */
      decompress(data, fin, callback) {
        zlibLimiter.add((done) => {
          this._decompress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      /**
       * Compress data. Concurrency limited.
       *
       * @param {Buffer} data Data to compress
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @public
       */
      compress(data, fin, callback) {
        zlibLimiter.add((done) => {
          this._compress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      /**
       * Decompress data.
       *
       * @param {Buffer} data Compressed data
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @private
       */
      _decompress(data, fin, callback) {
        const endpoint = this._isServer ? "client" : "server";
        if (!this._inflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib2.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._inflate = zlib2.createInflateRaw({
            ...this._options.zlibInflateOptions,
            windowBits
          });
          this._inflate[kPerMessageDeflate] = this;
          this._inflate[kTotalLength] = 0;
          this._inflate[kBuffers] = [];
          this._inflate.on("error", inflateOnError);
          this._inflate.on("data", inflateOnData);
        }
        this._inflate[kCallback] = callback;
        this._inflate.write(data);
        if (fin) this._inflate.write(TRAILER);
        this._inflate.flush(() => {
          const err = this._inflate[kError];
          if (err) {
            this._inflate.close();
            this._inflate = null;
            callback(err);
            return;
          }
          const data2 = bufferUtil.concat(
            this._inflate[kBuffers],
            this._inflate[kTotalLength]
          );
          if (this._inflate._readableState.endEmitted) {
            this._inflate.close();
            this._inflate = null;
          } else {
            this._inflate[kTotalLength] = 0;
            this._inflate[kBuffers] = [];
            if (fin && this.params[`${endpoint}_no_context_takeover`]) {
              this._inflate.reset();
            }
          }
          callback(null, data2);
        });
      }
      /**
       * Compress data.
       *
       * @param {Buffer} data Data to compress
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @private
       */
      _compress(data, fin, callback) {
        const endpoint = this._isServer ? "server" : "client";
        if (!this._deflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib2.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._deflate = zlib2.createDeflateRaw({
            ...this._options.zlibDeflateOptions,
            windowBits
          });
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          this._deflate.on("error", NOOP);
          this._deflate.on("data", deflateOnData);
        }
        this._deflate[kCallback] = callback;
        this._deflate.write(data);
        this._deflate.flush(zlib2.Z_SYNC_FLUSH, () => {
          if (!this._deflate) {
            return;
          }
          let data2 = bufferUtil.concat(
            this._deflate[kBuffers],
            this._deflate[kTotalLength]
          );
          if (fin) data2 = data2.slice(0, data2.length - 4);
          this._deflate[kCallback] = null;
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          if (fin && this.params[`${endpoint}_no_context_takeover`]) {
            this._deflate.reset();
          }
          callback(null, data2);
        });
      }
    };
    module2.exports = PerMessageDeflate;
    function deflateOnData(chunk) {
      this[kBuffers].push(chunk);
      this[kTotalLength] += chunk.length;
    }
    function inflateOnData(chunk) {
      this[kTotalLength] += chunk.length;
      if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
        this[kBuffers].push(chunk);
        return;
      }
      this[kError] = new RangeError("Max payload size exceeded");
      this[kError].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH";
      this[kError][kStatusCode] = 1009;
      this.removeListener("data", inflateOnData);
      this.reset();
    }
    function inflateOnError(err) {
      this[kPerMessageDeflate]._inflate = null;
      err[kStatusCode] = 1007;
      this[kCallback](err);
    }
  }
});

// node_modules/ws/lib/validation.js
var require_validation = __commonJS({
  "node_modules/ws/lib/validation.js"(exports2, module2) {
    "use strict";
    function isValidStatusCode(code) {
      return code >= 1e3 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3e3 && code <= 4999;
    }
    function _isValidUTF8(buf) {
      const len = buf.length;
      let i2 = 0;
      while (i2 < len) {
        if ((buf[i2] & 128) === 0) {
          i2++;
        } else if ((buf[i2] & 224) === 192) {
          if (i2 + 1 === len || (buf[i2 + 1] & 192) !== 128 || (buf[i2] & 254) === 192) {
            return false;
          }
          i2 += 2;
        } else if ((buf[i2] & 240) === 224) {
          if (i2 + 2 >= len || (buf[i2 + 1] & 192) !== 128 || (buf[i2 + 2] & 192) !== 128 || buf[i2] === 224 && (buf[i2 + 1] & 224) === 128 || // Overlong
          buf[i2] === 237 && (buf[i2 + 1] & 224) === 160) {
            return false;
          }
          i2 += 3;
        } else if ((buf[i2] & 248) === 240) {
          if (i2 + 3 >= len || (buf[i2 + 1] & 192) !== 128 || (buf[i2 + 2] & 192) !== 128 || (buf[i2 + 3] & 192) !== 128 || buf[i2] === 240 && (buf[i2 + 1] & 240) === 128 || // Overlong
          buf[i2] === 244 && buf[i2 + 1] > 143 || buf[i2] > 244) {
            return false;
          }
          i2 += 4;
        } else {
          return false;
        }
      }
      return true;
    }
    try {
      let isValidUTF8 = require("utf-8-validate");
      if (typeof isValidUTF8 === "object") {
        isValidUTF8 = isValidUTF8.Validation.isValidUTF8;
      }
      module2.exports = {
        isValidStatusCode,
        isValidUTF8(buf) {
          return buf.length < 150 ? _isValidUTF8(buf) : isValidUTF8(buf);
        }
      };
    } catch (e2) {
      module2.exports = {
        isValidStatusCode,
        isValidUTF8: _isValidUTF8
      };
    }
  }
});

// node_modules/ws/lib/receiver.js
var require_receiver = __commonJS({
  "node_modules/ws/lib/receiver.js"(exports2, module2) {
    "use strict";
    var { Writable } = require("stream");
    var PerMessageDeflate = require_permessage_deflate();
    var {
      BINARY_TYPES,
      EMPTY_BUFFER,
      kStatusCode,
      kWebSocket
    } = require_constants();
    var { concat, toArrayBuffer, unmask } = require_buffer_util();
    var { isValidStatusCode, isValidUTF8 } = require_validation();
    var GET_INFO = 0;
    var GET_PAYLOAD_LENGTH_16 = 1;
    var GET_PAYLOAD_LENGTH_64 = 2;
    var GET_MASK = 3;
    var GET_DATA = 4;
    var INFLATING = 5;
    var Receiver = class extends Writable {
      /**
       * Creates a Receiver instance.
       *
       * @param {String} [binaryType=nodebuffer] The type for binary data
       * @param {Object} [extensions] An object containing the negotiated extensions
       * @param {Boolean} [isServer=false] Specifies whether to operate in client or
       *     server mode
       * @param {Number} [maxPayload=0] The maximum allowed message length
       */
      constructor(binaryType, extensions, isServer, maxPayload) {
        super();
        this._binaryType = binaryType || BINARY_TYPES[0];
        this[kWebSocket] = void 0;
        this._extensions = extensions || {};
        this._isServer = !!isServer;
        this._maxPayload = maxPayload | 0;
        this._bufferedBytes = 0;
        this._buffers = [];
        this._compressed = false;
        this._payloadLength = 0;
        this._mask = void 0;
        this._fragmented = 0;
        this._masked = false;
        this._fin = false;
        this._opcode = 0;
        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragments = [];
        this._state = GET_INFO;
        this._loop = false;
      }
      /**
       * Implements `Writable.prototype._write()`.
       *
       * @param {Buffer} chunk The chunk of data to write
       * @param {String} encoding The character encoding of `chunk`
       * @param {Function} cb Callback
       * @private
       */
      _write(chunk, encoding, cb) {
        if (this._opcode === 8 && this._state == GET_INFO) return cb();
        this._bufferedBytes += chunk.length;
        this._buffers.push(chunk);
        this.startLoop(cb);
      }
      /**
       * Consumes `n` bytes from the buffered data.
       *
       * @param {Number} n The number of bytes to consume
       * @return {Buffer} The consumed bytes
       * @private
       */
      consume(n) {
        this._bufferedBytes -= n;
        if (n === this._buffers[0].length) return this._buffers.shift();
        if (n < this._buffers[0].length) {
          const buf = this._buffers[0];
          this._buffers[0] = buf.slice(n);
          return buf.slice(0, n);
        }
        const dst = Buffer.allocUnsafe(n);
        do {
          const buf = this._buffers[0];
          const offset = dst.length - n;
          if (n >= buf.length) {
            dst.set(this._buffers.shift(), offset);
          } else {
            dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
            this._buffers[0] = buf.slice(n);
          }
          n -= buf.length;
        } while (n > 0);
        return dst;
      }
      /**
       * Starts the parsing loop.
       *
       * @param {Function} cb Callback
       * @private
       */
      startLoop(cb) {
        let err;
        this._loop = true;
        do {
          switch (this._state) {
            case GET_INFO:
              err = this.getInfo();
              break;
            case GET_PAYLOAD_LENGTH_16:
              err = this.getPayloadLength16();
              break;
            case GET_PAYLOAD_LENGTH_64:
              err = this.getPayloadLength64();
              break;
            case GET_MASK:
              this.getMask();
              break;
            case GET_DATA:
              err = this.getData(cb);
              break;
            default:
              this._loop = false;
              return;
          }
        } while (this._loop);
        cb(err);
      }
      /**
       * Reads the first two bytes of a frame.
       *
       * @return {(RangeError|undefined)} A possible error
       * @private
       */
      getInfo() {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        const buf = this.consume(2);
        if ((buf[0] & 48) !== 0) {
          this._loop = false;
          return error(
            RangeError,
            "RSV2 and RSV3 must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_RSV_2_3"
          );
        }
        const compressed = (buf[0] & 64) === 64;
        if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
          this._loop = false;
          return error(
            RangeError,
            "RSV1 must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_RSV_1"
          );
        }
        this._fin = (buf[0] & 128) === 128;
        this._opcode = buf[0] & 15;
        this._payloadLength = buf[1] & 127;
        if (this._opcode === 0) {
          if (compressed) {
            this._loop = false;
            return error(
              RangeError,
              "RSV1 must be clear",
              true,
              1002,
              "WS_ERR_UNEXPECTED_RSV_1"
            );
          }
          if (!this._fragmented) {
            this._loop = false;
            return error(
              RangeError,
              "invalid opcode 0",
              true,
              1002,
              "WS_ERR_INVALID_OPCODE"
            );
          }
          this._opcode = this._fragmented;
        } else if (this._opcode === 1 || this._opcode === 2) {
          if (this._fragmented) {
            this._loop = false;
            return error(
              RangeError,
              `invalid opcode ${this._opcode}`,
              true,
              1002,
              "WS_ERR_INVALID_OPCODE"
            );
          }
          this._compressed = compressed;
        } else if (this._opcode > 7 && this._opcode < 11) {
          if (!this._fin) {
            this._loop = false;
            return error(
              RangeError,
              "FIN must be set",
              true,
              1002,
              "WS_ERR_EXPECTED_FIN"
            );
          }
          if (compressed) {
            this._loop = false;
            return error(
              RangeError,
              "RSV1 must be clear",
              true,
              1002,
              "WS_ERR_UNEXPECTED_RSV_1"
            );
          }
          if (this._payloadLength > 125) {
            this._loop = false;
            return error(
              RangeError,
              `invalid payload length ${this._payloadLength}`,
              true,
              1002,
              "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH"
            );
          }
        } else {
          this._loop = false;
          return error(
            RangeError,
            `invalid opcode ${this._opcode}`,
            true,
            1002,
            "WS_ERR_INVALID_OPCODE"
          );
        }
        if (!this._fin && !this._fragmented) this._fragmented = this._opcode;
        this._masked = (buf[1] & 128) === 128;
        if (this._isServer) {
          if (!this._masked) {
            this._loop = false;
            return error(
              RangeError,
              "MASK must be set",
              true,
              1002,
              "WS_ERR_EXPECTED_MASK"
            );
          }
        } else if (this._masked) {
          this._loop = false;
          return error(
            RangeError,
            "MASK must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_MASK"
          );
        }
        if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;
        else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;
        else return this.haveLength();
      }
      /**
       * Gets extended payload length (7+16).
       *
       * @return {(RangeError|undefined)} A possible error
       * @private
       */
      getPayloadLength16() {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        this._payloadLength = this.consume(2).readUInt16BE(0);
        return this.haveLength();
      }
      /**
       * Gets extended payload length (7+64).
       *
       * @return {(RangeError|undefined)} A possible error
       * @private
       */
      getPayloadLength64() {
        if (this._bufferedBytes < 8) {
          this._loop = false;
          return;
        }
        const buf = this.consume(8);
        const num = buf.readUInt32BE(0);
        if (num > Math.pow(2, 53 - 32) - 1) {
          this._loop = false;
          return error(
            RangeError,
            "Unsupported WebSocket frame: payload length > 2^53 - 1",
            false,
            1009,
            "WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH"
          );
        }
        this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
        return this.haveLength();
      }
      /**
       * Payload length has been read.
       *
       * @return {(RangeError|undefined)} A possible error
       * @private
       */
      haveLength() {
        if (this._payloadLength && this._opcode < 8) {
          this._totalPayloadLength += this._payloadLength;
          if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
            this._loop = false;
            return error(
              RangeError,
              "Max payload size exceeded",
              false,
              1009,
              "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
            );
          }
        }
        if (this._masked) this._state = GET_MASK;
        else this._state = GET_DATA;
      }
      /**
       * Reads mask bytes.
       *
       * @private
       */
      getMask() {
        if (this._bufferedBytes < 4) {
          this._loop = false;
          return;
        }
        this._mask = this.consume(4);
        this._state = GET_DATA;
      }
      /**
       * Reads data bytes.
       *
       * @param {Function} cb Callback
       * @return {(Error|RangeError|undefined)} A possible error
       * @private
       */
      getData(cb) {
        let data = EMPTY_BUFFER;
        if (this._payloadLength) {
          if (this._bufferedBytes < this._payloadLength) {
            this._loop = false;
            return;
          }
          data = this.consume(this._payloadLength);
          if (this._masked) unmask(data, this._mask);
        }
        if (this._opcode > 7) return this.controlMessage(data);
        if (this._compressed) {
          this._state = INFLATING;
          this.decompress(data, cb);
          return;
        }
        if (data.length) {
          this._messageLength = this._totalPayloadLength;
          this._fragments.push(data);
        }
        return this.dataMessage();
      }
      /**
       * Decompresses data.
       *
       * @param {Buffer} data Compressed data
       * @param {Function} cb Callback
       * @private
       */
      decompress(data, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        perMessageDeflate.decompress(data, this._fin, (err, buf) => {
          if (err) return cb(err);
          if (buf.length) {
            this._messageLength += buf.length;
            if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
              return cb(
                error(
                  RangeError,
                  "Max payload size exceeded",
                  false,
                  1009,
                  "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
                )
              );
            }
            this._fragments.push(buf);
          }
          const er = this.dataMessage();
          if (er) return cb(er);
          this.startLoop(cb);
        });
      }
      /**
       * Handles a data message.
       *
       * @return {(Error|undefined)} A possible error
       * @private
       */
      dataMessage() {
        if (this._fin) {
          const messageLength = this._messageLength;
          const fragments = this._fragments;
          this._totalPayloadLength = 0;
          this._messageLength = 0;
          this._fragmented = 0;
          this._fragments = [];
          if (this._opcode === 2) {
            let data;
            if (this._binaryType === "nodebuffer") {
              data = concat(fragments, messageLength);
            } else if (this._binaryType === "arraybuffer") {
              data = toArrayBuffer(concat(fragments, messageLength));
            } else {
              data = fragments;
            }
            this.emit("message", data);
          } else {
            const buf = concat(fragments, messageLength);
            if (!isValidUTF8(buf)) {
              this._loop = false;
              return error(
                Error,
                "invalid UTF-8 sequence",
                true,
                1007,
                "WS_ERR_INVALID_UTF8"
              );
            }
            this.emit("message", buf.toString());
          }
        }
        this._state = GET_INFO;
      }
      /**
       * Handles a control message.
       *
       * @param {Buffer} data Data to handle
       * @return {(Error|RangeError|undefined)} A possible error
       * @private
       */
      controlMessage(data) {
        if (this._opcode === 8) {
          this._loop = false;
          if (data.length === 0) {
            this.emit("conclude", 1005, "");
            this.end();
          } else if (data.length === 1) {
            return error(
              RangeError,
              "invalid payload length 1",
              true,
              1002,
              "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH"
            );
          } else {
            const code = data.readUInt16BE(0);
            if (!isValidStatusCode(code)) {
              return error(
                RangeError,
                `invalid status code ${code}`,
                true,
                1002,
                "WS_ERR_INVALID_CLOSE_CODE"
              );
            }
            const buf = data.slice(2);
            if (!isValidUTF8(buf)) {
              return error(
                Error,
                "invalid UTF-8 sequence",
                true,
                1007,
                "WS_ERR_INVALID_UTF8"
              );
            }
            this.emit("conclude", code, buf.toString());
            this.end();
          }
        } else if (this._opcode === 9) {
          this.emit("ping", data);
        } else {
          this.emit("pong", data);
        }
        this._state = GET_INFO;
      }
    };
    module2.exports = Receiver;
    function error(ErrorCtor, message, prefix, statusCode, errorCode) {
      const err = new ErrorCtor(
        prefix ? `Invalid WebSocket frame: ${message}` : message
      );
      Error.captureStackTrace(err, error);
      err.code = errorCode;
      err[kStatusCode] = statusCode;
      return err;
    }
  }
});

// node_modules/ws/lib/sender.js
var require_sender = __commonJS({
  "node_modules/ws/lib/sender.js"(exports2, module2) {
    "use strict";
    var net = require("net");
    var tls = require("tls");
    var { randomFillSync } = require("crypto");
    var PerMessageDeflate = require_permessage_deflate();
    var { EMPTY_BUFFER } = require_constants();
    var { isValidStatusCode } = require_validation();
    var { mask: applyMask, toBuffer } = require_buffer_util();
    var mask = Buffer.alloc(4);
    var Sender = class _Sender {
      /**
       * Creates a Sender instance.
       *
       * @param {(net.Socket|tls.Socket)} socket The connection socket
       * @param {Object} [extensions] An object containing the negotiated extensions
       */
      constructor(socket, extensions) {
        this._extensions = extensions || {};
        this._socket = socket;
        this._firstFragment = true;
        this._compress = false;
        this._bufferedBytes = 0;
        this._deflating = false;
        this._queue = [];
      }
      /**
       * Frames a piece of data according to the HyBi WebSocket protocol.
       *
       * @param {Buffer} data The data to frame
       * @param {Object} options Options object
       * @param {Number} options.opcode The opcode
       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
       *     modified
       * @param {Boolean} [options.fin=false] Specifies whether or not to set the
       *     FIN bit
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
       *     RSV1 bit
       * @return {Buffer[]} The framed data as a list of `Buffer` instances
       * @public
       */
      static frame(data, options) {
        const merge = options.mask && options.readOnly;
        let offset = options.mask ? 6 : 2;
        let payloadLength = data.length;
        if (data.length >= 65536) {
          offset += 8;
          payloadLength = 127;
        } else if (data.length > 125) {
          offset += 2;
          payloadLength = 126;
        }
        const target = Buffer.allocUnsafe(merge ? data.length + offset : offset);
        target[0] = options.fin ? options.opcode | 128 : options.opcode;
        if (options.rsv1) target[0] |= 64;
        target[1] = payloadLength;
        if (payloadLength === 126) {
          target.writeUInt16BE(data.length, 2);
        } else if (payloadLength === 127) {
          target.writeUInt32BE(0, 2);
          target.writeUInt32BE(data.length, 6);
        }
        if (!options.mask) return [target, data];
        randomFillSync(mask, 0, 4);
        target[1] |= 128;
        target[offset - 4] = mask[0];
        target[offset - 3] = mask[1];
        target[offset - 2] = mask[2];
        target[offset - 1] = mask[3];
        if (merge) {
          applyMask(data, mask, target, offset, data.length);
          return [target];
        }
        applyMask(data, mask, data, 0, data.length);
        return [target, data];
      }
      /**
       * Sends a close message to the other peer.
       *
       * @param {Number} [code] The status code component of the body
       * @param {String} [data] The message component of the body
       * @param {Boolean} [mask=false] Specifies whether or not to mask the message
       * @param {Function} [cb] Callback
       * @public
       */
      close(code, data, mask2, cb) {
        let buf;
        if (code === void 0) {
          buf = EMPTY_BUFFER;
        } else if (typeof code !== "number" || !isValidStatusCode(code)) {
          throw new TypeError("First argument must be a valid error code number");
        } else if (data === void 0 || data === "") {
          buf = Buffer.allocUnsafe(2);
          buf.writeUInt16BE(code, 0);
        } else {
          const length = Buffer.byteLength(data);
          if (length > 123) {
            throw new RangeError("The message must not be greater than 123 bytes");
          }
          buf = Buffer.allocUnsafe(2 + length);
          buf.writeUInt16BE(code, 0);
          buf.write(data, 2);
        }
        if (this._deflating) {
          this.enqueue([this.doClose, buf, mask2, cb]);
        } else {
          this.doClose(buf, mask2, cb);
        }
      }
      /**
       * Frames and sends a close message.
       *
       * @param {Buffer} data The message to send
       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback
       * @private
       */
      doClose(data, mask2, cb) {
        this.sendFrame(
          _Sender.frame(data, {
            fin: true,
            rsv1: false,
            opcode: 8,
            mask: mask2,
            readOnly: false
          }),
          cb
        );
      }
      /**
       * Sends a ping message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback
       * @public
       */
      ping(data, mask2, cb) {
        const buf = toBuffer(data);
        if (buf.length > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        if (this._deflating) {
          this.enqueue([this.doPing, buf, mask2, toBuffer.readOnly, cb]);
        } else {
          this.doPing(buf, mask2, toBuffer.readOnly, cb);
        }
      }
      /**
       * Frames and sends a ping message.
       *
       * @param {Buffer} data The message to send
       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
       * @param {Boolean} [readOnly=false] Specifies whether `data` can be modified
       * @param {Function} [cb] Callback
       * @private
       */
      doPing(data, mask2, readOnly, cb) {
        this.sendFrame(
          _Sender.frame(data, {
            fin: true,
            rsv1: false,
            opcode: 9,
            mask: mask2,
            readOnly
          }),
          cb
        );
      }
      /**
       * Sends a pong message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback
       * @public
       */
      pong(data, mask2, cb) {
        const buf = toBuffer(data);
        if (buf.length > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        if (this._deflating) {
          this.enqueue([this.doPong, buf, mask2, toBuffer.readOnly, cb]);
        } else {
          this.doPong(buf, mask2, toBuffer.readOnly, cb);
        }
      }
      /**
       * Frames and sends a pong message.
       *
       * @param {Buffer} data The message to send
       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
       * @param {Boolean} [readOnly=false] Specifies whether `data` can be modified
       * @param {Function} [cb] Callback
       * @private
       */
      doPong(data, mask2, readOnly, cb) {
        this.sendFrame(
          _Sender.frame(data, {
            fin: true,
            rsv1: false,
            opcode: 10,
            mask: mask2,
            readOnly
          }),
          cb
        );
      }
      /**
       * Sends a data message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Object} options Options object
       * @param {Boolean} [options.compress=false] Specifies whether or not to
       *     compress `data`
       * @param {Boolean} [options.binary=false] Specifies whether `data` is binary
       *     or text
       * @param {Boolean} [options.fin=false] Specifies whether the fragment is the
       *     last one
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Function} [cb] Callback
       * @public
       */
      send(data, options, cb) {
        const buf = toBuffer(data);
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        let opcode = options.binary ? 2 : 1;
        let rsv1 = options.compress;
        if (this._firstFragment) {
          this._firstFragment = false;
          if (rsv1 && perMessageDeflate) {
            rsv1 = buf.length >= perMessageDeflate._threshold;
          }
          this._compress = rsv1;
        } else {
          rsv1 = false;
          opcode = 0;
        }
        if (options.fin) this._firstFragment = true;
        if (perMessageDeflate) {
          const opts = {
            fin: options.fin,
            rsv1,
            opcode,
            mask: options.mask,
            readOnly: toBuffer.readOnly
          };
          if (this._deflating) {
            this.enqueue([this.dispatch, buf, this._compress, opts, cb]);
          } else {
            this.dispatch(buf, this._compress, opts, cb);
          }
        } else {
          this.sendFrame(
            _Sender.frame(buf, {
              fin: options.fin,
              rsv1: false,
              opcode,
              mask: options.mask,
              readOnly: toBuffer.readOnly
            }),
            cb
          );
        }
      }
      /**
       * Dispatches a data message.
       *
       * @param {Buffer} data The message to send
       * @param {Boolean} [compress=false] Specifies whether or not to compress
       *     `data`
       * @param {Object} options Options object
       * @param {Number} options.opcode The opcode
       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
       *     modified
       * @param {Boolean} [options.fin=false] Specifies whether or not to set the
       *     FIN bit
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
       *     RSV1 bit
       * @param {Function} [cb] Callback
       * @private
       */
      dispatch(data, compress, options, cb) {
        if (!compress) {
          this.sendFrame(_Sender.frame(data, options), cb);
          return;
        }
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        this._bufferedBytes += data.length;
        this._deflating = true;
        perMessageDeflate.compress(data, options.fin, (_, buf) => {
          if (this._socket.destroyed) {
            const err = new Error(
              "The socket was closed while data was being compressed"
            );
            if (typeof cb === "function") cb(err);
            for (let i2 = 0; i2 < this._queue.length; i2++) {
              const callback = this._queue[i2][4];
              if (typeof callback === "function") callback(err);
            }
            return;
          }
          this._bufferedBytes -= data.length;
          this._deflating = false;
          options.readOnly = false;
          this.sendFrame(_Sender.frame(buf, options), cb);
          this.dequeue();
        });
      }
      /**
       * Executes queued send operations.
       *
       * @private
       */
      dequeue() {
        while (!this._deflating && this._queue.length) {
          const params = this._queue.shift();
          this._bufferedBytes -= params[1].length;
          Reflect.apply(params[0], this, params.slice(1));
        }
      }
      /**
       * Enqueues a send operation.
       *
       * @param {Array} params Send operation parameters.
       * @private
       */
      enqueue(params) {
        this._bufferedBytes += params[1].length;
        this._queue.push(params);
      }
      /**
       * Sends a frame.
       *
       * @param {Buffer[]} list The frame to send
       * @param {Function} [cb] Callback
       * @private
       */
      sendFrame(list, cb) {
        if (list.length === 2) {
          this._socket.cork();
          this._socket.write(list[0]);
          this._socket.write(list[1], cb);
          this._socket.uncork();
        } else {
          this._socket.write(list[0], cb);
        }
      }
    };
    module2.exports = Sender;
  }
});

// node_modules/ws/lib/event-target.js
var require_event_target = __commonJS({
  "node_modules/ws/lib/event-target.js"(exports2, module2) {
    "use strict";
    var Event = class {
      /**
       * Create a new `Event`.
       *
       * @param {String} type The name of the event
       * @param {Object} target A reference to the target to which the event was
       *     dispatched
       */
      constructor(type, target) {
        this.target = target;
        this.type = type;
      }
    };
    var MessageEvent = class extends Event {
      /**
       * Create a new `MessageEvent`.
       *
       * @param {(String|Buffer|ArrayBuffer|Buffer[])} data The received data
       * @param {WebSocket} target A reference to the target to which the event was
       *     dispatched
       */
      constructor(data, target) {
        super("message", target);
        this.data = data;
      }
    };
    var CloseEvent = class extends Event {
      /**
       * Create a new `CloseEvent`.
       *
       * @param {Number} code The status code explaining why the connection is being
       *     closed
       * @param {String} reason A human-readable string explaining why the
       *     connection is closing
       * @param {WebSocket} target A reference to the target to which the event was
       *     dispatched
       */
      constructor(code, reason, target) {
        super("close", target);
        this.wasClean = target._closeFrameReceived && target._closeFrameSent;
        this.reason = reason;
        this.code = code;
      }
    };
    var OpenEvent = class extends Event {
      /**
       * Create a new `OpenEvent`.
       *
       * @param {WebSocket} target A reference to the target to which the event was
       *     dispatched
       */
      constructor(target) {
        super("open", target);
      }
    };
    var ErrorEvent = class extends Event {
      /**
       * Create a new `ErrorEvent`.
       *
       * @param {Object} error The error that generated this event
       * @param {WebSocket} target A reference to the target to which the event was
       *     dispatched
       */
      constructor(error, target) {
        super("error", target);
        this.message = error.message;
        this.error = error;
      }
    };
    var EventTarget = {
      /**
       * Register an event listener.
       *
       * @param {String} type A string representing the event type to listen for
       * @param {Function} listener The listener to add
       * @param {Object} [options] An options object specifies characteristics about
       *     the event listener
       * @param {Boolean} [options.once=false] A `Boolean`` indicating that the
       *     listener should be invoked at most once after being added. If `true`,
       *     the listener would be automatically removed when invoked.
       * @public
       */
      addEventListener(type, listener, options) {
        if (typeof listener !== "function") return;
        function onMessage(data) {
          listener.call(this, new MessageEvent(data, this));
        }
        function onClose(code, message) {
          listener.call(this, new CloseEvent(code, message, this));
        }
        function onError(error) {
          listener.call(this, new ErrorEvent(error, this));
        }
        function onOpen() {
          listener.call(this, new OpenEvent(this));
        }
        const method = options && options.once ? "once" : "on";
        if (type === "message") {
          onMessage._listener = listener;
          this[method](type, onMessage);
        } else if (type === "close") {
          onClose._listener = listener;
          this[method](type, onClose);
        } else if (type === "error") {
          onError._listener = listener;
          this[method](type, onError);
        } else if (type === "open") {
          onOpen._listener = listener;
          this[method](type, onOpen);
        } else {
          this[method](type, listener);
        }
      },
      /**
       * Remove an event listener.
       *
       * @param {String} type A string representing the event type to remove
       * @param {Function} listener The listener to remove
       * @public
       */
      removeEventListener(type, listener) {
        const listeners = this.listeners(type);
        for (let i2 = 0; i2 < listeners.length; i2++) {
          if (listeners[i2] === listener || listeners[i2]._listener === listener) {
            this.removeListener(type, listeners[i2]);
          }
        }
      }
    };
    module2.exports = EventTarget;
  }
});

// node_modules/ws/lib/extension.js
var require_extension = __commonJS({
  "node_modules/ws/lib/extension.js"(exports2, module2) {
    "use strict";
    var tokenChars = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // 0 - 15
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // 16 - 31
      0,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      1,
      1,
      0,
      1,
      1,
      0,
      // 32 - 47
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      // 48 - 63
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      // 64 - 79
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      1,
      1,
      // 80 - 95
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      // 96 - 111
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      1,
      0,
      1,
      0
      // 112 - 127
    ];
    function push(dest, name, elem) {
      if (dest[name] === void 0) dest[name] = [elem];
      else dest[name].push(elem);
    }
    function parse(header) {
      const offers = /* @__PURE__ */ Object.create(null);
      if (header === void 0 || header === "") return offers;
      let params = /* @__PURE__ */ Object.create(null);
      let mustUnescape = false;
      let isEscaping = false;
      let inQuotes = false;
      let extensionName;
      let paramName;
      let start = -1;
      let end = -1;
      let i2 = 0;
      for (; i2 < header.length; i2++) {
        const code = header.charCodeAt(i2);
        if (extensionName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start === -1) start = i2;
          } else if (code === 32 || code === 9) {
            if (end === -1 && start !== -1) end = i2;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i2}`);
            }
            if (end === -1) end = i2;
            const name = header.slice(start, end);
            if (code === 44) {
              push(offers, name, params);
              params = /* @__PURE__ */ Object.create(null);
            } else {
              extensionName = name;
            }
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i2}`);
          }
        } else if (paramName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start === -1) start = i2;
          } else if (code === 32 || code === 9) {
            if (end === -1 && start !== -1) end = i2;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i2}`);
            }
            if (end === -1) end = i2;
            push(params, header.slice(start, end), true);
            if (code === 44) {
              push(offers, extensionName, params);
              params = /* @__PURE__ */ Object.create(null);
              extensionName = void 0;
            }
            start = end = -1;
          } else if (code === 61 && start !== -1 && end === -1) {
            paramName = header.slice(start, i2);
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i2}`);
          }
        } else {
          if (isEscaping) {
            if (tokenChars[code] !== 1) {
              throw new SyntaxError(`Unexpected character at index ${i2}`);
            }
            if (start === -1) start = i2;
            else if (!mustUnescape) mustUnescape = true;
            isEscaping = false;
          } else if (inQuotes) {
            if (tokenChars[code] === 1) {
              if (start === -1) start = i2;
            } else if (code === 34 && start !== -1) {
              inQuotes = false;
              end = i2;
            } else if (code === 92) {
              isEscaping = true;
            } else {
              throw new SyntaxError(`Unexpected character at index ${i2}`);
            }
          } else if (code === 34 && header.charCodeAt(i2 - 1) === 61) {
            inQuotes = true;
          } else if (end === -1 && tokenChars[code] === 1) {
            if (start === -1) start = i2;
          } else if (start !== -1 && (code === 32 || code === 9)) {
            if (end === -1) end = i2;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i2}`);
            }
            if (end === -1) end = i2;
            let value = header.slice(start, end);
            if (mustUnescape) {
              value = value.replace(/\\/g, "");
              mustUnescape = false;
            }
            push(params, paramName, value);
            if (code === 44) {
              push(offers, extensionName, params);
              params = /* @__PURE__ */ Object.create(null);
              extensionName = void 0;
            }
            paramName = void 0;
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i2}`);
          }
        }
      }
      if (start === -1 || inQuotes) {
        throw new SyntaxError("Unexpected end of input");
      }
      if (end === -1) end = i2;
      const token = header.slice(start, end);
      if (extensionName === void 0) {
        push(offers, token, params);
      } else {
        if (paramName === void 0) {
          push(params, token, true);
        } else if (mustUnescape) {
          push(params, paramName, token.replace(/\\/g, ""));
        } else {
          push(params, paramName, token);
        }
        push(offers, extensionName, params);
      }
      return offers;
    }
    function format(extensions) {
      return Object.keys(extensions).map((extension) => {
        let configurations = extensions[extension];
        if (!Array.isArray(configurations)) configurations = [configurations];
        return configurations.map((params) => {
          return [extension].concat(
            Object.keys(params).map((k) => {
              let values = params[k];
              if (!Array.isArray(values)) values = [values];
              return values.map((v) => v === true ? k : `${k}=${v}`).join("; ");
            })
          ).join("; ");
        }).join(", ");
      }).join(", ");
    }
    module2.exports = { format, parse };
  }
});

// node_modules/ws/lib/websocket.js
var require_websocket = __commonJS({
  "node_modules/ws/lib/websocket.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events");
    var https2 = require("https");
    var http3 = require("http");
    var net = require("net");
    var tls = require("tls");
    var { randomBytes, createHash } = require("crypto");
    var { Readable } = require("stream");
    var { URL: URL2 } = require("url");
    var PerMessageDeflate = require_permessage_deflate();
    var Receiver = require_receiver();
    var Sender = require_sender();
    var {
      BINARY_TYPES,
      EMPTY_BUFFER,
      GUID,
      kStatusCode,
      kWebSocket,
      NOOP
    } = require_constants();
    var { addEventListener, removeEventListener } = require_event_target();
    var { format, parse } = require_extension();
    var { toBuffer } = require_buffer_util();
    var readyStates = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"];
    var protocolVersions = [8, 13];
    var closeTimeout = 30 * 1e3;
    var WebSocket2 = class _WebSocket extends EventEmitter {
      /**
       * Create a new `WebSocket`.
       *
       * @param {(String|URL)} address The URL to which to connect
       * @param {(String|String[])} [protocols] The subprotocols
       * @param {Object} [options] Connection options
       */
      constructor(address, protocols, options) {
        super();
        this._binaryType = BINARY_TYPES[0];
        this._closeCode = 1006;
        this._closeFrameReceived = false;
        this._closeFrameSent = false;
        this._closeMessage = "";
        this._closeTimer = null;
        this._extensions = {};
        this._protocol = "";
        this._readyState = _WebSocket.CONNECTING;
        this._receiver = null;
        this._sender = null;
        this._socket = null;
        if (address !== null) {
          this._bufferedAmount = 0;
          this._isServer = false;
          this._redirects = 0;
          if (Array.isArray(protocols)) {
            protocols = protocols.join(", ");
          } else if (typeof protocols === "object" && protocols !== null) {
            options = protocols;
            protocols = void 0;
          }
          initAsClient(this, address, protocols, options);
        } else {
          this._isServer = true;
        }
      }
      /**
       * This deviates from the WHATWG interface since ws doesn't support the
       * required default "blob" type (instead we define a custom "nodebuffer"
       * type).
       *
       * @type {String}
       */
      get binaryType() {
        return this._binaryType;
      }
      set binaryType(type) {
        if (!BINARY_TYPES.includes(type)) return;
        this._binaryType = type;
        if (this._receiver) this._receiver._binaryType = type;
      }
      /**
       * @type {Number}
       */
      get bufferedAmount() {
        if (!this._socket) return this._bufferedAmount;
        return this._socket._writableState.length + this._sender._bufferedBytes;
      }
      /**
       * @type {String}
       */
      get extensions() {
        return Object.keys(this._extensions).join();
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onclose() {
        return void 0;
      }
      /* istanbul ignore next */
      set onclose(listener) {
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onerror() {
        return void 0;
      }
      /* istanbul ignore next */
      set onerror(listener) {
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onopen() {
        return void 0;
      }
      /* istanbul ignore next */
      set onopen(listener) {
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onmessage() {
        return void 0;
      }
      /* istanbul ignore next */
      set onmessage(listener) {
      }
      /**
       * @type {String}
       */
      get protocol() {
        return this._protocol;
      }
      /**
       * @type {Number}
       */
      get readyState() {
        return this._readyState;
      }
      /**
       * @type {String}
       */
      get url() {
        return this._url;
      }
      /**
       * Set up the socket and the internal resources.
       *
       * @param {(net.Socket|tls.Socket)} socket The network socket between the
       *     server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Number} [maxPayload=0] The maximum allowed message size
       * @private
       */
      setSocket(socket, head, maxPayload) {
        const receiver = new Receiver(
          this.binaryType,
          this._extensions,
          this._isServer,
          maxPayload
        );
        this._sender = new Sender(socket, this._extensions);
        this._receiver = receiver;
        this._socket = socket;
        receiver[kWebSocket] = this;
        socket[kWebSocket] = this;
        receiver.on("conclude", receiverOnConclude);
        receiver.on("drain", receiverOnDrain);
        receiver.on("error", receiverOnError);
        receiver.on("message", receiverOnMessage);
        receiver.on("ping", receiverOnPing);
        receiver.on("pong", receiverOnPong);
        socket.setTimeout(0);
        socket.setNoDelay();
        if (head.length > 0) socket.unshift(head);
        socket.on("close", socketOnClose);
        socket.on("data", socketOnData);
        socket.on("end", socketOnEnd);
        socket.on("error", socketOnError);
        this._readyState = _WebSocket.OPEN;
        this.emit("open");
      }
      /**
       * Emit the `'close'` event.
       *
       * @private
       */
      emitClose() {
        if (!this._socket) {
          this._readyState = _WebSocket.CLOSED;
          this.emit("close", this._closeCode, this._closeMessage);
          return;
        }
        if (this._extensions[PerMessageDeflate.extensionName]) {
          this._extensions[PerMessageDeflate.extensionName].cleanup();
        }
        this._receiver.removeAllListeners();
        this._readyState = _WebSocket.CLOSED;
        this.emit("close", this._closeCode, this._closeMessage);
      }
      /**
       * Start a closing handshake.
       *
       *          +----------+   +-----------+   +----------+
       *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
       *    |     +----------+   +-----------+   +----------+     |
       *          +----------+   +-----------+         |
       * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
       *          +----------+   +-----------+   |
       *    |           |                        |   +---+        |
       *                +------------------------+-->|fin| - - - -
       *    |         +---+                      |   +---+
       *     - - - - -|fin|<---------------------+
       *              +---+
       *
       * @param {Number} [code] Status code explaining why the connection is closing
       * @param {String} [data] A string explaining why the connection is closing
       * @public
       */
      close(code, data) {
        if (this.readyState === _WebSocket.CLOSED) return;
        if (this.readyState === _WebSocket.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          return abortHandshake(this, this._req, msg);
        }
        if (this.readyState === _WebSocket.CLOSING) {
          if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {
            this._socket.end();
          }
          return;
        }
        this._readyState = _WebSocket.CLOSING;
        this._sender.close(code, data, !this._isServer, (err) => {
          if (err) return;
          this._closeFrameSent = true;
          if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {
            this._socket.end();
          }
        });
        this._closeTimer = setTimeout(
          this._socket.destroy.bind(this._socket),
          closeTimeout
        );
      }
      /**
       * Send a ping.
       *
       * @param {*} [data] The data to send
       * @param {Boolean} [mask] Indicates whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when the ping is sent
       * @public
       */
      ping(data, mask, cb) {
        if (this.readyState === _WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data === "number") data = data.toString();
        if (this.readyState !== _WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask === void 0) mask = !this._isServer;
        this._sender.ping(data || EMPTY_BUFFER, mask, cb);
      }
      /**
       * Send a pong.
       *
       * @param {*} [data] The data to send
       * @param {Boolean} [mask] Indicates whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when the pong is sent
       * @public
       */
      pong(data, mask, cb) {
        if (this.readyState === _WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data === "number") data = data.toString();
        if (this.readyState !== _WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask === void 0) mask = !this._isServer;
        this._sender.pong(data || EMPTY_BUFFER, mask, cb);
      }
      /**
       * Send a data message.
       *
       * @param {*} data The message to send
       * @param {Object} [options] Options object
       * @param {Boolean} [options.compress] Specifies whether or not to compress
       *     `data`
       * @param {Boolean} [options.binary] Specifies whether `data` is binary or
       *     text
       * @param {Boolean} [options.fin=true] Specifies whether the fragment is the
       *     last one
       * @param {Boolean} [options.mask] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when data is written out
       * @public
       */
      send(data, options, cb) {
        if (this.readyState === _WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof options === "function") {
          cb = options;
          options = {};
        }
        if (typeof data === "number") data = data.toString();
        if (this.readyState !== _WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        const opts = {
          binary: typeof data !== "string",
          mask: !this._isServer,
          compress: true,
          fin: true,
          ...options
        };
        if (!this._extensions[PerMessageDeflate.extensionName]) {
          opts.compress = false;
        }
        this._sender.send(data || EMPTY_BUFFER, opts, cb);
      }
      /**
       * Forcibly close the connection.
       *
       * @public
       */
      terminate() {
        if (this.readyState === _WebSocket.CLOSED) return;
        if (this.readyState === _WebSocket.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          return abortHandshake(this, this._req, msg);
        }
        if (this._socket) {
          this._readyState = _WebSocket.CLOSING;
          this._socket.destroy();
        }
      }
    };
    Object.defineProperty(WebSocket2, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket2.prototype, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket2, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket2.prototype, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket2, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket2.prototype, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket2, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    Object.defineProperty(WebSocket2.prototype, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    [
      "binaryType",
      "bufferedAmount",
      "extensions",
      "protocol",
      "readyState",
      "url"
    ].forEach((property) => {
      Object.defineProperty(WebSocket2.prototype, property, { enumerable: true });
    });
    ["open", "error", "close", "message"].forEach((method) => {
      Object.defineProperty(WebSocket2.prototype, `on${method}`, {
        enumerable: true,
        get() {
          const listeners = this.listeners(method);
          for (let i2 = 0; i2 < listeners.length; i2++) {
            if (listeners[i2]._listener) return listeners[i2]._listener;
          }
          return void 0;
        },
        set(listener) {
          const listeners = this.listeners(method);
          for (let i2 = 0; i2 < listeners.length; i2++) {
            if (listeners[i2]._listener) this.removeListener(method, listeners[i2]);
          }
          this.addEventListener(method, listener);
        }
      });
    });
    WebSocket2.prototype.addEventListener = addEventListener;
    WebSocket2.prototype.removeEventListener = removeEventListener;
    module2.exports = WebSocket2;
    function initAsClient(websocket, address, protocols, options) {
      const opts = {
        protocolVersion: protocolVersions[1],
        maxPayload: 100 * 1024 * 1024,
        perMessageDeflate: true,
        followRedirects: false,
        maxRedirects: 10,
        ...options,
        createConnection: void 0,
        socketPath: void 0,
        hostname: void 0,
        protocol: void 0,
        timeout: void 0,
        method: void 0,
        host: void 0,
        path: void 0,
        port: void 0
      };
      if (!protocolVersions.includes(opts.protocolVersion)) {
        throw new RangeError(
          `Unsupported protocol version: ${opts.protocolVersion} (supported versions: ${protocolVersions.join(", ")})`
        );
      }
      let parsedUrl;
      if (address instanceof URL2) {
        parsedUrl = address;
        websocket._url = address.href;
      } else {
        parsedUrl = new URL2(address);
        websocket._url = address;
      }
      const isUnixSocket = parsedUrl.protocol === "ws+unix:";
      if (!parsedUrl.host && (!isUnixSocket || !parsedUrl.pathname)) {
        const err = new Error(`Invalid URL: ${websocket.url}`);
        if (websocket._redirects === 0) {
          throw err;
        } else {
          emitErrorAndClose(websocket, err);
          return;
        }
      }
      const isSecure = parsedUrl.protocol === "wss:" || parsedUrl.protocol === "https:";
      const defaultPort = isSecure ? 443 : 80;
      const key = randomBytes(16).toString("base64");
      const get = isSecure ? https2.get : http3.get;
      let perMessageDeflate;
      opts.createConnection = isSecure ? tlsConnect : netConnect;
      opts.defaultPort = opts.defaultPort || defaultPort;
      opts.port = parsedUrl.port || defaultPort;
      opts.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
      opts.headers = {
        "Sec-WebSocket-Version": opts.protocolVersion,
        "Sec-WebSocket-Key": key,
        Connection: "Upgrade",
        Upgrade: "websocket",
        ...opts.headers
      };
      opts.path = parsedUrl.pathname + parsedUrl.search;
      opts.timeout = opts.handshakeTimeout;
      if (opts.perMessageDeflate) {
        perMessageDeflate = new PerMessageDeflate(
          opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},
          false,
          opts.maxPayload
        );
        opts.headers["Sec-WebSocket-Extensions"] = format({
          [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
        });
      }
      if (protocols) {
        opts.headers["Sec-WebSocket-Protocol"] = protocols;
      }
      if (opts.origin) {
        if (opts.protocolVersion < 13) {
          opts.headers["Sec-WebSocket-Origin"] = opts.origin;
        } else {
          opts.headers.Origin = opts.origin;
        }
      }
      if (parsedUrl.username || parsedUrl.password) {
        opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
      }
      if (isUnixSocket) {
        const parts = opts.path.split(":");
        opts.socketPath = parts[0];
        opts.path = parts[1];
      }
      if (opts.followRedirects) {
        if (websocket._redirects === 0) {
          websocket._originalUnixSocket = isUnixSocket;
          websocket._originalSecure = isSecure;
          websocket._originalHostOrSocketPath = isUnixSocket ? opts.socketPath : parsedUrl.host;
          const headers = options && options.headers;
          options = { ...options, headers: {} };
          if (headers) {
            for (const [key2, value] of Object.entries(headers)) {
              options.headers[key2.toLowerCase()] = value;
            }
          }
        } else {
          const isSameHost = isUnixSocket ? websocket._originalUnixSocket ? opts.socketPath === websocket._originalHostOrSocketPath : false : websocket._originalUnixSocket ? false : parsedUrl.host === websocket._originalHostOrSocketPath;
          if (!isSameHost || websocket._originalSecure && !isSecure) {
            delete opts.headers.authorization;
            delete opts.headers.cookie;
            if (!isSameHost) delete opts.headers.host;
            opts.auth = void 0;
          }
        }
        if (opts.auth && !options.headers.authorization) {
          options.headers.authorization = "Basic " + Buffer.from(opts.auth).toString("base64");
        }
      }
      let req = websocket._req = get(opts);
      if (opts.timeout) {
        req.on("timeout", () => {
          abortHandshake(websocket, req, "Opening handshake has timed out");
        });
      }
      req.on("error", (err) => {
        if (req === null || req.aborted) return;
        req = websocket._req = null;
        emitErrorAndClose(websocket, err);
      });
      req.on("response", (res) => {
        const location = res.headers.location;
        const statusCode = res.statusCode;
        if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
          if (++websocket._redirects > opts.maxRedirects) {
            abortHandshake(websocket, req, "Maximum redirects exceeded");
            return;
          }
          req.abort();
          let addr;
          try {
            addr = new URL2(location, address);
          } catch (err) {
            emitErrorAndClose(websocket, err);
            return;
          }
          initAsClient(websocket, addr, protocols, options);
        } else if (!websocket.emit("unexpected-response", req, res)) {
          abortHandshake(
            websocket,
            req,
            `Unexpected server response: ${res.statusCode}`
          );
        }
      });
      req.on("upgrade", (res, socket, head) => {
        websocket.emit("upgrade", res);
        if (websocket.readyState !== WebSocket2.CONNECTING) return;
        req = websocket._req = null;
        const upgrade = res.headers.upgrade;
        if (upgrade === void 0 || upgrade.toLowerCase() !== "websocket") {
          abortHandshake(websocket, socket, "Invalid Upgrade header");
          return;
        }
        const digest = createHash("sha1").update(key + GUID).digest("base64");
        if (res.headers["sec-websocket-accept"] !== digest) {
          abortHandshake(websocket, socket, "Invalid Sec-WebSocket-Accept header");
          return;
        }
        const serverProt = res.headers["sec-websocket-protocol"];
        const protList = (protocols || "").split(/, */);
        let protError;
        if (!protocols && serverProt) {
          protError = "Server sent a subprotocol but none was requested";
        } else if (protocols && !serverProt) {
          protError = "Server sent no subprotocol";
        } else if (serverProt && !protList.includes(serverProt)) {
          protError = "Server sent an invalid subprotocol";
        }
        if (protError) {
          abortHandshake(websocket, socket, protError);
          return;
        }
        if (serverProt) websocket._protocol = serverProt;
        const secWebSocketExtensions = res.headers["sec-websocket-extensions"];
        if (secWebSocketExtensions !== void 0) {
          if (!perMessageDeflate) {
            const message = "Server sent a Sec-WebSocket-Extensions header but no extension was requested";
            abortHandshake(websocket, socket, message);
            return;
          }
          let extensions;
          try {
            extensions = parse(secWebSocketExtensions);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Extensions header";
            abortHandshake(websocket, socket, message);
            return;
          }
          const extensionNames = Object.keys(extensions);
          if (extensionNames.length) {
            if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {
              const message = "Server indicated an extension that was not requested";
              abortHandshake(websocket, socket, message);
              return;
            }
            try {
              perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
            } catch (err) {
              const message = "Invalid Sec-WebSocket-Extensions header";
              abortHandshake(websocket, socket, message);
              return;
            }
            websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
          }
        }
        websocket.setSocket(socket, head, opts.maxPayload);
      });
    }
    function emitErrorAndClose(websocket, err) {
      websocket._readyState = WebSocket2.CLOSING;
      websocket.emit("error", err);
      websocket.emitClose();
    }
    function netConnect(options) {
      options.path = options.socketPath;
      return net.connect(options);
    }
    function tlsConnect(options) {
      options.path = void 0;
      if (!options.servername && options.servername !== "") {
        options.servername = net.isIP(options.host) ? "" : options.host;
      }
      return tls.connect(options);
    }
    function abortHandshake(websocket, stream, message) {
      websocket._readyState = WebSocket2.CLOSING;
      const err = new Error(message);
      Error.captureStackTrace(err, abortHandshake);
      if (stream.setHeader) {
        stream.abort();
        if (stream.socket && !stream.socket.destroyed) {
          stream.socket.destroy();
        }
        stream.once("abort", websocket.emitClose.bind(websocket));
        websocket.emit("error", err);
      } else {
        stream.destroy(err);
        stream.once("error", websocket.emit.bind(websocket, "error"));
        stream.once("close", websocket.emitClose.bind(websocket));
      }
    }
    function sendAfterClose(websocket, data, cb) {
      if (data) {
        const length = toBuffer(data).length;
        if (websocket._socket) websocket._sender._bufferedBytes += length;
        else websocket._bufferedAmount += length;
      }
      if (cb) {
        const err = new Error(
          `WebSocket is not open: readyState ${websocket.readyState} (${readyStates[websocket.readyState]})`
        );
        cb(err);
      }
    }
    function receiverOnConclude(code, reason) {
      const websocket = this[kWebSocket];
      websocket._closeFrameReceived = true;
      websocket._closeMessage = reason;
      websocket._closeCode = code;
      if (websocket._socket[kWebSocket] === void 0) return;
      websocket._socket.removeListener("data", socketOnData);
      process.nextTick(resume, websocket._socket);
      if (code === 1005) websocket.close();
      else websocket.close(code, reason);
    }
    function receiverOnDrain() {
      this[kWebSocket]._socket.resume();
    }
    function receiverOnError(err) {
      const websocket = this[kWebSocket];
      if (websocket._socket[kWebSocket] !== void 0) {
        websocket._socket.removeListener("data", socketOnData);
        process.nextTick(resume, websocket._socket);
        websocket.close(err[kStatusCode]);
      }
      websocket.emit("error", err);
    }
    function receiverOnFinish() {
      this[kWebSocket].emitClose();
    }
    function receiverOnMessage(data) {
      this[kWebSocket].emit("message", data);
    }
    function receiverOnPing(data) {
      const websocket = this[kWebSocket];
      websocket.pong(data, !websocket._isServer, NOOP);
      websocket.emit("ping", data);
    }
    function receiverOnPong(data) {
      this[kWebSocket].emit("pong", data);
    }
    function resume(stream) {
      stream.resume();
    }
    function socketOnClose() {
      const websocket = this[kWebSocket];
      this.removeListener("close", socketOnClose);
      this.removeListener("data", socketOnData);
      this.removeListener("end", socketOnEnd);
      websocket._readyState = WebSocket2.CLOSING;
      let chunk;
      if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && (chunk = websocket._socket.read()) !== null) {
        websocket._receiver.write(chunk);
      }
      websocket._receiver.end();
      this[kWebSocket] = void 0;
      clearTimeout(websocket._closeTimer);
      if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {
        websocket.emitClose();
      } else {
        websocket._receiver.on("error", receiverOnFinish);
        websocket._receiver.on("finish", receiverOnFinish);
      }
    }
    function socketOnData(chunk) {
      if (!this[kWebSocket]._receiver.write(chunk)) {
        this.pause();
      }
    }
    function socketOnEnd() {
      const websocket = this[kWebSocket];
      websocket._readyState = WebSocket2.CLOSING;
      websocket._receiver.end();
      this.end();
    }
    function socketOnError() {
      const websocket = this[kWebSocket];
      this.removeListener("error", socketOnError);
      this.on("error", NOOP);
      if (websocket) {
        websocket._readyState = WebSocket2.CLOSING;
        this.destroy();
      }
    }
  }
});

// node_modules/ws/lib/stream.js
var require_stream = __commonJS({
  "node_modules/ws/lib/stream.js"(exports2, module2) {
    "use strict";
    var { Duplex } = require("stream");
    function emitClose(stream) {
      stream.emit("close");
    }
    function duplexOnEnd() {
      if (!this.destroyed && this._writableState.finished) {
        this.destroy();
      }
    }
    function duplexOnError(err) {
      this.removeListener("error", duplexOnError);
      this.destroy();
      if (this.listenerCount("error") === 0) {
        this.emit("error", err);
      }
    }
    function createWebSocketStream(ws, options) {
      let resumeOnReceiverDrain = true;
      let terminateOnDestroy = true;
      function receiverOnDrain() {
        if (resumeOnReceiverDrain) ws._socket.resume();
      }
      if (ws.readyState === ws.CONNECTING) {
        ws.once("open", function open() {
          ws._receiver.removeAllListeners("drain");
          ws._receiver.on("drain", receiverOnDrain);
        });
      } else {
        ws._receiver.removeAllListeners("drain");
        ws._receiver.on("drain", receiverOnDrain);
      }
      const duplex = new Duplex({
        ...options,
        autoDestroy: false,
        emitClose: false,
        objectMode: false,
        writableObjectMode: false
      });
      ws.on("message", function message(msg) {
        if (!duplex.push(msg)) {
          resumeOnReceiverDrain = false;
          ws._socket.pause();
        }
      });
      ws.once("error", function error(err) {
        if (duplex.destroyed) return;
        terminateOnDestroy = false;
        duplex.destroy(err);
      });
      ws.once("close", function close() {
        if (duplex.destroyed) return;
        duplex.push(null);
      });
      duplex._destroy = function(err, callback) {
        if (ws.readyState === ws.CLOSED) {
          callback(err);
          process.nextTick(emitClose, duplex);
          return;
        }
        let called = false;
        ws.once("error", function error(err2) {
          called = true;
          callback(err2);
        });
        ws.once("close", function close() {
          if (!called) callback(err);
          process.nextTick(emitClose, duplex);
        });
        if (terminateOnDestroy) ws.terminate();
      };
      duplex._final = function(callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once("open", function open() {
            duplex._final(callback);
          });
          return;
        }
        if (ws._socket === null) return;
        if (ws._socket._writableState.finished) {
          callback();
          if (duplex._readableState.endEmitted) duplex.destroy();
        } else {
          ws._socket.once("finish", function finish() {
            callback();
          });
          ws.close();
        }
      };
      duplex._read = function() {
        if ((ws.readyState === ws.OPEN || ws.readyState === ws.CLOSING) && !resumeOnReceiverDrain) {
          resumeOnReceiverDrain = true;
          if (!ws._receiver._writableState.needDrain) ws._socket.resume();
        }
      };
      duplex._write = function(chunk, encoding, callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once("open", function open() {
            duplex._write(chunk, encoding, callback);
          });
          return;
        }
        ws.send(chunk, callback);
      };
      duplex.on("end", duplexOnEnd);
      duplex.on("error", duplexOnError);
      return duplex;
    }
    module2.exports = createWebSocketStream;
  }
});

// node_modules/ws/lib/websocket-server.js
var require_websocket_server = __commonJS({
  "node_modules/ws/lib/websocket-server.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events");
    var http3 = require("http");
    var https2 = require("https");
    var net = require("net");
    var tls = require("tls");
    var { createHash } = require("crypto");
    var PerMessageDeflate = require_permessage_deflate();
    var WebSocket2 = require_websocket();
    var { format, parse } = require_extension();
    var { GUID, kWebSocket } = require_constants();
    var keyRegex = /^[+/0-9A-Za-z]{22}==$/;
    var RUNNING = 0;
    var CLOSING = 1;
    var CLOSED = 2;
    var WebSocketServer = class extends EventEmitter {
      /**
       * Create a `WebSocketServer` instance.
       *
       * @param {Object} options Configuration options
       * @param {Number} [options.backlog=511] The maximum length of the queue of
       *     pending connections
       * @param {Boolean} [options.clientTracking=true] Specifies whether or not to
       *     track clients
       * @param {Function} [options.handleProtocols] A hook to handle protocols
       * @param {String} [options.host] The hostname where to bind the server
       * @param {Number} [options.maxPayload=104857600] The maximum allowed message
       *     size
       * @param {Boolean} [options.noServer=false] Enable no server mode
       * @param {String} [options.path] Accept only connections matching this path
       * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable
       *     permessage-deflate
       * @param {Number} [options.port] The port where to bind the server
       * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S
       *     server to use
       * @param {Function} [options.verifyClient] A hook to reject connections
       * @param {Function} [callback] A listener for the `listening` event
       */
      constructor(options, callback) {
        super();
        options = {
          maxPayload: 100 * 1024 * 1024,
          perMessageDeflate: false,
          handleProtocols: null,
          clientTracking: true,
          verifyClient: null,
          noServer: false,
          backlog: null,
          // use default (511 as implemented in net.js)
          server: null,
          host: null,
          path: null,
          port: null,
          ...options
        };
        if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) {
          throw new TypeError(
            'One and only one of the "port", "server", or "noServer" options must be specified'
          );
        }
        if (options.port != null) {
          this._server = http3.createServer((req, res) => {
            const body = http3.STATUS_CODES[426];
            res.writeHead(426, {
              "Content-Length": body.length,
              "Content-Type": "text/plain"
            });
            res.end(body);
          });
          this._server.listen(
            options.port,
            options.host,
            options.backlog,
            callback
          );
        } else if (options.server) {
          this._server = options.server;
        }
        if (this._server) {
          const emitConnection = this.emit.bind(this, "connection");
          this._removeListeners = addListeners(this._server, {
            listening: this.emit.bind(this, "listening"),
            error: this.emit.bind(this, "error"),
            upgrade: (req, socket, head) => {
              this.handleUpgrade(req, socket, head, emitConnection);
            }
          });
        }
        if (options.perMessageDeflate === true) options.perMessageDeflate = {};
        if (options.clientTracking) this.clients = /* @__PURE__ */ new Set();
        this.options = options;
        this._state = RUNNING;
      }
      /**
       * Returns the bound address, the address family name, and port of the server
       * as reported by the operating system if listening on an IP socket.
       * If the server is listening on a pipe or UNIX domain socket, the name is
       * returned as a string.
       *
       * @return {(Object|String|null)} The address of the server
       * @public
       */
      address() {
        if (this.options.noServer) {
          throw new Error('The server is operating in "noServer" mode');
        }
        if (!this._server) return null;
        return this._server.address();
      }
      /**
       * Close the server.
       *
       * @param {Function} [cb] Callback
       * @public
       */
      close(cb) {
        if (cb) this.once("close", cb);
        if (this._state === CLOSED) {
          process.nextTick(emitClose, this);
          return;
        }
        if (this._state === CLOSING) return;
        this._state = CLOSING;
        if (this.clients) {
          for (const client of this.clients) client.terminate();
        }
        const server = this._server;
        if (server) {
          this._removeListeners();
          this._removeListeners = this._server = null;
          if (this.options.port != null) {
            server.close(emitClose.bind(void 0, this));
            return;
          }
        }
        process.nextTick(emitClose, this);
      }
      /**
       * See if a given request should be handled by this server instance.
       *
       * @param {http.IncomingMessage} req Request object to inspect
       * @return {Boolean} `true` if the request is valid, else `false`
       * @public
       */
      shouldHandle(req) {
        if (this.options.path) {
          const index = req.url.indexOf("?");
          const pathname = index !== -1 ? req.url.slice(0, index) : req.url;
          if (pathname !== this.options.path) return false;
        }
        return true;
      }
      /**
       * Handle a HTTP Upgrade request.
       *
       * @param {http.IncomingMessage} req The request object
       * @param {(net.Socket|tls.Socket)} socket The network socket between the
       *     server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Function} cb Callback
       * @public
       */
      handleUpgrade(req, socket, head, cb) {
        socket.on("error", socketOnError);
        const key = req.headers["sec-websocket-key"] !== void 0 ? req.headers["sec-websocket-key"].trim() : false;
        const upgrade = req.headers.upgrade;
        const version = +req.headers["sec-websocket-version"];
        const extensions = {};
        if (req.method !== "GET" || upgrade === void 0 || upgrade.toLowerCase() !== "websocket" || !key || !keyRegex.test(key) || version !== 8 && version !== 13 || !this.shouldHandle(req)) {
          return abortHandshake(socket, 400);
        }
        if (this.options.perMessageDeflate) {
          const perMessageDeflate = new PerMessageDeflate(
            this.options.perMessageDeflate,
            true,
            this.options.maxPayload
          );
          try {
            const offers = parse(req.headers["sec-websocket-extensions"]);
            if (offers[PerMessageDeflate.extensionName]) {
              perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
              extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
            }
          } catch (err) {
            return abortHandshake(socket, 400);
          }
        }
        if (this.options.verifyClient) {
          const info = {
            origin: req.headers[`${version === 8 ? "sec-websocket-origin" : "origin"}`],
            secure: !!(req.socket.authorized || req.socket.encrypted),
            req
          };
          if (this.options.verifyClient.length === 2) {
            this.options.verifyClient(info, (verified, code, message, headers) => {
              if (!verified) {
                return abortHandshake(socket, code || 401, message, headers);
              }
              this.completeUpgrade(key, extensions, req, socket, head, cb);
            });
            return;
          }
          if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);
        }
        this.completeUpgrade(key, extensions, req, socket, head, cb);
      }
      /**
       * Upgrade the connection to WebSocket.
       *
       * @param {String} key The value of the `Sec-WebSocket-Key` header
       * @param {Object} extensions The accepted extensions
       * @param {http.IncomingMessage} req The request object
       * @param {(net.Socket|tls.Socket)} socket The network socket between the
       *     server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Function} cb Callback
       * @throws {Error} If called more than once with the same socket
       * @private
       */
      completeUpgrade(key, extensions, req, socket, head, cb) {
        if (!socket.readable || !socket.writable) return socket.destroy();
        if (socket[kWebSocket]) {
          throw new Error(
            "server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration"
          );
        }
        if (this._state > RUNNING) return abortHandshake(socket, 503);
        const digest = createHash("sha1").update(key + GUID).digest("base64");
        const headers = [
          "HTTP/1.1 101 Switching Protocols",
          "Upgrade: websocket",
          "Connection: Upgrade",
          `Sec-WebSocket-Accept: ${digest}`
        ];
        const ws = new WebSocket2(null);
        let protocol = req.headers["sec-websocket-protocol"];
        if (protocol) {
          protocol = protocol.split(",").map(trim);
          if (this.options.handleProtocols) {
            protocol = this.options.handleProtocols(protocol, req);
          } else {
            protocol = protocol[0];
          }
          if (protocol) {
            headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
            ws._protocol = protocol;
          }
        }
        if (extensions[PerMessageDeflate.extensionName]) {
          const params = extensions[PerMessageDeflate.extensionName].params;
          const value = format({
            [PerMessageDeflate.extensionName]: [params]
          });
          headers.push(`Sec-WebSocket-Extensions: ${value}`);
          ws._extensions = extensions;
        }
        this.emit("headers", headers, req);
        socket.write(headers.concat("\r\n").join("\r\n"));
        socket.removeListener("error", socketOnError);
        ws.setSocket(socket, head, this.options.maxPayload);
        if (this.clients) {
          this.clients.add(ws);
          ws.on("close", () => this.clients.delete(ws));
        }
        cb(ws, req);
      }
    };
    module2.exports = WebSocketServer;
    function addListeners(server, map) {
      for (const event of Object.keys(map)) server.on(event, map[event]);
      return function removeListeners() {
        for (const event of Object.keys(map)) {
          server.removeListener(event, map[event]);
        }
      };
    }
    function emitClose(server) {
      server._state = CLOSED;
      server.emit("close");
    }
    function socketOnError() {
      this.destroy();
    }
    function abortHandshake(socket, code, message, headers) {
      if (socket.writable) {
        message = message || http3.STATUS_CODES[code];
        headers = {
          Connection: "close",
          "Content-Type": "text/html",
          "Content-Length": Buffer.byteLength(message),
          ...headers
        };
        socket.write(
          `HTTP/1.1 ${code} ${http3.STATUS_CODES[code]}\r
` + Object.keys(headers).map((h2) => `${h2}: ${headers[h2]}`).join("\r\n") + "\r\n\r\n" + message
        );
      }
      socket.removeListener("error", socketOnError);
      socket.destroy();
    }
    function trim(str) {
      return str.trim();
    }
  }
});

// node_modules/ws/index.js
var require_ws = __commonJS({
  "node_modules/ws/index.js"(exports2, module2) {
    "use strict";
    var WebSocket2 = require_websocket();
    WebSocket2.createWebSocketStream = require_stream();
    WebSocket2.Server = require_websocket_server();
    WebSocket2.Receiver = require_receiver();
    WebSocket2.Sender = require_sender();
    module2.exports = WebSocket2;
  }
});

// node_modules/bignumber.js/bignumber.js
var require_bignumber = __commonJS({
  "node_modules/bignumber.js/bignumber.js"(exports2, module2) {
    (function(globalObject) {
      "use strict";
      var BigNumber, isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = "[BigNumber Error] ", tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ", BASE = 1e14, LOG_BASE = 14, MAX_SAFE_INTEGER = 9007199254740991, POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], SQRT_BASE = 1e7, MAX = 1e9;
      function clone2(configObject) {
        var div, convertBase, parseNumeric, P = BigNumber2.prototype = { constructor: BigNumber2, toString: null, valueOf: null }, ONE = new BigNumber2(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
          prefix: "",
          groupSize: 3,
          secondaryGroupSize: 0,
          groupSeparator: ",",
          decimalSeparator: ".",
          fractionGroupSize: 0,
          fractionGroupSeparator: "\xA0",
          // non-breaking space
          suffix: ""
        }, ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz", alphabetHasNormalDecimalDigits = true;
        function BigNumber2(v, b) {
          var alphabet, c, caseChanged, e2, i2, isNum, len, str, x2 = this;
          if (!(x2 instanceof BigNumber2)) return new BigNumber2(v, b);
          if (b == null) {
            if (v && v._isBigNumber === true) {
              x2.s = v.s;
              if (!v.c || v.e > MAX_EXP) {
                x2.c = x2.e = null;
              } else if (v.e < MIN_EXP) {
                x2.c = [x2.e = 0];
              } else {
                x2.e = v.e;
                x2.c = v.c.slice();
              }
              return;
            }
            if ((isNum = typeof v == "number") && v * 0 == 0) {
              x2.s = 1 / v < 0 ? (v = -v, -1) : 1;
              if (v === ~~v) {
                for (e2 = 0, i2 = v; i2 >= 10; i2 /= 10, e2++) ;
                if (e2 > MAX_EXP) {
                  x2.c = x2.e = null;
                } else {
                  x2.e = e2;
                  x2.c = [v];
                }
                return;
              }
              str = String(v);
            } else {
              if (!isNumeric.test(str = String(v))) return parseNumeric(x2, str, isNum);
              x2.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
            }
            if ((e2 = str.indexOf(".")) > -1) str = str.replace(".", "");
            if ((i2 = str.search(/e/i)) > 0) {
              if (e2 < 0) e2 = i2;
              e2 += +str.slice(i2 + 1);
              str = str.substring(0, i2);
            } else if (e2 < 0) {
              e2 = str.length;
            }
          } else {
            intCheck(b, 2, ALPHABET.length, "Base");
            if (b == 10 && alphabetHasNormalDecimalDigits) {
              x2 = new BigNumber2(v);
              return round(x2, DECIMAL_PLACES + x2.e + 1, ROUNDING_MODE);
            }
            str = String(v);
            if (isNum = typeof v == "number") {
              if (v * 0 != 0) return parseNumeric(x2, str, isNum, b);
              x2.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;
              if (BigNumber2.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) {
                throw Error(tooManyDigits + v);
              }
            } else {
              x2.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
            }
            alphabet = ALPHABET.slice(0, b);
            e2 = i2 = 0;
            for (len = str.length; i2 < len; i2++) {
              if (alphabet.indexOf(c = str.charAt(i2)) < 0) {
                if (c == ".") {
                  if (i2 > e2) {
                    e2 = len;
                    continue;
                  }
                } else if (!caseChanged) {
                  if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
                    caseChanged = true;
                    i2 = -1;
                    e2 = 0;
                    continue;
                  }
                }
                return parseNumeric(x2, String(v), isNum, b);
              }
            }
            isNum = false;
            str = convertBase(str, b, 10, x2.s);
            if ((e2 = str.indexOf(".")) > -1) str = str.replace(".", "");
            else e2 = str.length;
          }
          for (i2 = 0; str.charCodeAt(i2) === 48; i2++) ;
          for (len = str.length; str.charCodeAt(--len) === 48; ) ;
          if (str = str.slice(i2, ++len)) {
            len -= i2;
            if (isNum && BigNumber2.DEBUG && len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
              throw Error(tooManyDigits + x2.s * v);
            }
            if ((e2 = e2 - i2 - 1) > MAX_EXP) {
              x2.c = x2.e = null;
            } else if (e2 < MIN_EXP) {
              x2.c = [x2.e = 0];
            } else {
              x2.e = e2;
              x2.c = [];
              i2 = (e2 + 1) % LOG_BASE;
              if (e2 < 0) i2 += LOG_BASE;
              if (i2 < len) {
                if (i2) x2.c.push(+str.slice(0, i2));
                for (len -= LOG_BASE; i2 < len; ) {
                  x2.c.push(+str.slice(i2, i2 += LOG_BASE));
                }
                i2 = LOG_BASE - (str = str.slice(i2)).length;
              } else {
                i2 -= len;
              }
              for (; i2--; str += "0") ;
              x2.c.push(+str);
            }
          } else {
            x2.c = [x2.e = 0];
          }
        }
        BigNumber2.clone = clone2;
        BigNumber2.ROUND_UP = 0;
        BigNumber2.ROUND_DOWN = 1;
        BigNumber2.ROUND_CEIL = 2;
        BigNumber2.ROUND_FLOOR = 3;
        BigNumber2.ROUND_HALF_UP = 4;
        BigNumber2.ROUND_HALF_DOWN = 5;
        BigNumber2.ROUND_HALF_EVEN = 6;
        BigNumber2.ROUND_HALF_CEIL = 7;
        BigNumber2.ROUND_HALF_FLOOR = 8;
        BigNumber2.EUCLID = 9;
        BigNumber2.config = BigNumber2.set = function(obj) {
          var p, v;
          if (obj != null) {
            if (typeof obj == "object") {
              if (obj.hasOwnProperty(p = "DECIMAL_PLACES")) {
                v = obj[p];
                intCheck(v, 0, MAX, p);
                DECIMAL_PLACES = v;
              }
              if (obj.hasOwnProperty(p = "ROUNDING_MODE")) {
                v = obj[p];
                intCheck(v, 0, 8, p);
                ROUNDING_MODE = v;
              }
              if (obj.hasOwnProperty(p = "EXPONENTIAL_AT")) {
                v = obj[p];
                if (v && v.pop) {
                  intCheck(v[0], -MAX, 0, p);
                  intCheck(v[1], 0, MAX, p);
                  TO_EXP_NEG = v[0];
                  TO_EXP_POS = v[1];
                } else {
                  intCheck(v, -MAX, MAX, p);
                  TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
                }
              }
              if (obj.hasOwnProperty(p = "RANGE")) {
                v = obj[p];
                if (v && v.pop) {
                  intCheck(v[0], -MAX, -1, p);
                  intCheck(v[1], 1, MAX, p);
                  MIN_EXP = v[0];
                  MAX_EXP = v[1];
                } else {
                  intCheck(v, -MAX, MAX, p);
                  if (v) {
                    MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
                  } else {
                    throw Error(bignumberError + p + " cannot be zero: " + v);
                  }
                }
              }
              if (obj.hasOwnProperty(p = "CRYPTO")) {
                v = obj[p];
                if (v === !!v) {
                  if (v) {
                    if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                      CRYPTO = v;
                    } else {
                      CRYPTO = !v;
                      throw Error(bignumberError + "crypto unavailable");
                    }
                  } else {
                    CRYPTO = v;
                  }
                } else {
                  throw Error(bignumberError + p + " not true or false: " + v);
                }
              }
              if (obj.hasOwnProperty(p = "MODULO_MODE")) {
                v = obj[p];
                intCheck(v, 0, 9, p);
                MODULO_MODE = v;
              }
              if (obj.hasOwnProperty(p = "POW_PRECISION")) {
                v = obj[p];
                intCheck(v, 0, MAX, p);
                POW_PRECISION = v;
              }
              if (obj.hasOwnProperty(p = "FORMAT")) {
                v = obj[p];
                if (typeof v == "object") FORMAT = v;
                else throw Error(bignumberError + p + " not an object: " + v);
              }
              if (obj.hasOwnProperty(p = "ALPHABET")) {
                v = obj[p];
                if (typeof v == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
                  alphabetHasNormalDecimalDigits = v.slice(0, 10) == "0123456789";
                  ALPHABET = v;
                } else {
                  throw Error(bignumberError + p + " invalid: " + v);
                }
              }
            } else {
              throw Error(bignumberError + "Object expected: " + obj);
            }
          }
          return {
            DECIMAL_PLACES,
            ROUNDING_MODE,
            EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
            RANGE: [MIN_EXP, MAX_EXP],
            CRYPTO,
            MODULO_MODE,
            POW_PRECISION,
            FORMAT,
            ALPHABET
          };
        };
        BigNumber2.isBigNumber = function(v) {
          if (!v || v._isBigNumber !== true) return false;
          if (!BigNumber2.DEBUG) return true;
          var i2, n, c = v.c, e2 = v.e, s2 = v.s;
          out: if ({}.toString.call(c) == "[object Array]") {
            if ((s2 === 1 || s2 === -1) && e2 >= -MAX && e2 <= MAX && e2 === mathfloor(e2)) {
              if (c[0] === 0) {
                if (e2 === 0 && c.length === 1) return true;
                break out;
              }
              i2 = (e2 + 1) % LOG_BASE;
              if (i2 < 1) i2 += LOG_BASE;
              if (String(c[0]).length == i2) {
                for (i2 = 0; i2 < c.length; i2++) {
                  n = c[i2];
                  if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;
                }
                if (n !== 0) return true;
              }
            }
          } else if (c === null && e2 === null && (s2 === null || s2 === 1 || s2 === -1)) {
            return true;
          }
          throw Error(bignumberError + "Invalid BigNumber: " + v);
        };
        BigNumber2.maximum = BigNumber2.max = function() {
          return maxOrMin(arguments, -1);
        };
        BigNumber2.minimum = BigNumber2.min = function() {
          return maxOrMin(arguments, 1);
        };
        BigNumber2.random = function() {
          var pow2_53 = 9007199254740992;
          var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
            return mathfloor(Math.random() * pow2_53);
          } : function() {
            return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
          };
          return function(dp) {
            var a, b, e2, k, v, i2 = 0, c = [], rand = new BigNumber2(ONE);
            if (dp == null) dp = DECIMAL_PLACES;
            else intCheck(dp, 0, MAX);
            k = mathceil(dp / LOG_BASE);
            if (CRYPTO) {
              if (crypto.getRandomValues) {
                a = crypto.getRandomValues(new Uint32Array(k *= 2));
                for (; i2 < k; ) {
                  v = a[i2] * 131072 + (a[i2 + 1] >>> 11);
                  if (v >= 9e15) {
                    b = crypto.getRandomValues(new Uint32Array(2));
                    a[i2] = b[0];
                    a[i2 + 1] = b[1];
                  } else {
                    c.push(v % 1e14);
                    i2 += 2;
                  }
                }
                i2 = k / 2;
              } else if (crypto.randomBytes) {
                a = crypto.randomBytes(k *= 7);
                for (; i2 < k; ) {
                  v = (a[i2] & 31) * 281474976710656 + a[i2 + 1] * 1099511627776 + a[i2 + 2] * 4294967296 + a[i2 + 3] * 16777216 + (a[i2 + 4] << 16) + (a[i2 + 5] << 8) + a[i2 + 6];
                  if (v >= 9e15) {
                    crypto.randomBytes(7).copy(a, i2);
                  } else {
                    c.push(v % 1e14);
                    i2 += 7;
                  }
                }
                i2 = k / 7;
              } else {
                CRYPTO = false;
                throw Error(bignumberError + "crypto unavailable");
              }
            }
            if (!CRYPTO) {
              for (; i2 < k; ) {
                v = random53bitInt();
                if (v < 9e15) c[i2++] = v % 1e14;
              }
            }
            k = c[--i2];
            dp %= LOG_BASE;
            if (k && dp) {
              v = POWS_TEN[LOG_BASE - dp];
              c[i2] = mathfloor(k / v) * v;
            }
            for (; c[i2] === 0; c.pop(), i2--) ;
            if (i2 < 0) {
              c = [e2 = 0];
            } else {
              for (e2 = -1; c[0] === 0; c.splice(0, 1), e2 -= LOG_BASE) ;
              for (i2 = 1, v = c[0]; v >= 10; v /= 10, i2++) ;
              if (i2 < LOG_BASE) e2 -= LOG_BASE - i2;
            }
            rand.e = e2;
            rand.c = c;
            return rand;
          };
        }();
        BigNumber2.sum = function() {
          var i2 = 1, args = arguments, sum = new BigNumber2(args[0]);
          for (; i2 < args.length; ) sum = sum.plus(args[i2++]);
          return sum;
        };
        convertBase = /* @__PURE__ */ function() {
          var decimal = "0123456789";
          function toBaseOut(str, baseIn, baseOut, alphabet) {
            var j, arr = [0], arrL, i2 = 0, len = str.length;
            for (; i2 < len; ) {
              for (arrL = arr.length; arrL--; arr[arrL] *= baseIn) ;
              arr[0] += alphabet.indexOf(str.charAt(i2++));
              for (j = 0; j < arr.length; j++) {
                if (arr[j] > baseOut - 1) {
                  if (arr[j + 1] == null) arr[j + 1] = 0;
                  arr[j + 1] += arr[j] / baseOut | 0;
                  arr[j] %= baseOut;
                }
              }
            }
            return arr.reverse();
          }
          return function(str, baseIn, baseOut, sign, callerIsToString) {
            var alphabet, d, e2, k, r2, x2, xc, y, i2 = str.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
            if (i2 >= 0) {
              k = POW_PRECISION;
              POW_PRECISION = 0;
              str = str.replace(".", "");
              y = new BigNumber2(baseIn);
              x2 = y.pow(str.length - i2);
              POW_PRECISION = k;
              y.c = toBaseOut(
                toFixedPoint(coeffToString(x2.c), x2.e, "0"),
                10,
                baseOut,
                decimal
              );
              y.e = y.c.length;
            }
            xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET, decimal) : (alphabet = decimal, ALPHABET));
            e2 = k = xc.length;
            for (; xc[--k] == 0; xc.pop()) ;
            if (!xc[0]) return alphabet.charAt(0);
            if (i2 < 0) {
              --e2;
            } else {
              x2.c = xc;
              x2.e = e2;
              x2.s = sign;
              x2 = div(x2, y, dp, rm, baseOut);
              xc = x2.c;
              r2 = x2.r;
              e2 = x2.e;
            }
            d = e2 + dp + 1;
            i2 = xc[d];
            k = baseOut / 2;
            r2 = r2 || d < 0 || xc[d + 1] != null;
            r2 = rm < 4 ? (i2 != null || r2) && (rm == 0 || rm == (x2.s < 0 ? 3 : 2)) : i2 > k || i2 == k && (rm == 4 || r2 || rm == 6 && xc[d - 1] & 1 || rm == (x2.s < 0 ? 8 : 7));
            if (d < 1 || !xc[0]) {
              str = r2 ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
            } else {
              xc.length = d;
              if (r2) {
                for (--baseOut; ++xc[--d] > baseOut; ) {
                  xc[d] = 0;
                  if (!d) {
                    ++e2;
                    xc = [1].concat(xc);
                  }
                }
              }
              for (k = xc.length; !xc[--k]; ) ;
              for (i2 = 0, str = ""; i2 <= k; str += alphabet.charAt(xc[i2++])) ;
              str = toFixedPoint(str, e2, alphabet.charAt(0));
            }
            return str;
          };
        }();
        div = /* @__PURE__ */ function() {
          function multiply(x2, k, base) {
            var m2, temp, xlo, xhi, carry = 0, i2 = x2.length, klo = k % SQRT_BASE, khi = k / SQRT_BASE | 0;
            for (x2 = x2.slice(); i2--; ) {
              xlo = x2[i2] % SQRT_BASE;
              xhi = x2[i2] / SQRT_BASE | 0;
              m2 = khi * xlo + xhi * klo;
              temp = klo * xlo + m2 % SQRT_BASE * SQRT_BASE + carry;
              carry = (temp / base | 0) + (m2 / SQRT_BASE | 0) + khi * xhi;
              x2[i2] = temp % base;
            }
            if (carry) x2 = [carry].concat(x2);
            return x2;
          }
          function compare2(a, b, aL, bL) {
            var i2, cmp;
            if (aL != bL) {
              cmp = aL > bL ? 1 : -1;
            } else {
              for (i2 = cmp = 0; i2 < aL; i2++) {
                if (a[i2] != b[i2]) {
                  cmp = a[i2] > b[i2] ? 1 : -1;
                  break;
                }
              }
            }
            return cmp;
          }
          function subtract(a, b, aL, base) {
            var i2 = 0;
            for (; aL--; ) {
              a[aL] -= i2;
              i2 = a[aL] < b[aL] ? 1 : 0;
              a[aL] = i2 * base + a[aL] - b[aL];
            }
            for (; !a[0] && a.length > 1; a.splice(0, 1)) ;
          }
          return function(x2, y, dp, rm, base) {
            var cmp, e2, i2, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s2 = x2.s == y.s ? 1 : -1, xc = x2.c, yc = y.c;
            if (!xc || !xc[0] || !yc || !yc[0]) {
              return new BigNumber2(
                // Return NaN if either NaN, or both Infinity or 0.
                !x2.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : (
                  // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.
                  xc && xc[0] == 0 || !yc ? s2 * 0 : s2 / 0
                )
              );
            }
            q = new BigNumber2(s2);
            qc = q.c = [];
            e2 = x2.e - y.e;
            s2 = dp + e2 + 1;
            if (!base) {
              base = BASE;
              e2 = bitFloor(x2.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
              s2 = s2 / LOG_BASE | 0;
            }
            for (i2 = 0; yc[i2] == (xc[i2] || 0); i2++) ;
            if (yc[i2] > (xc[i2] || 0)) e2--;
            if (s2 < 0) {
              qc.push(1);
              more = true;
            } else {
              xL = xc.length;
              yL = yc.length;
              i2 = 0;
              s2 += 2;
              n = mathfloor(base / (yc[0] + 1));
              if (n > 1) {
                yc = multiply(yc, n, base);
                xc = multiply(xc, n, base);
                yL = yc.length;
                xL = xc.length;
              }
              xi = yL;
              rem = xc.slice(0, yL);
              remL = rem.length;
              for (; remL < yL; rem[remL++] = 0) ;
              yz = yc.slice();
              yz = [0].concat(yz);
              yc0 = yc[0];
              if (yc[1] >= base / 2) yc0++;
              do {
                n = 0;
                cmp = compare2(yc, rem, yL, remL);
                if (cmp < 0) {
                  rem0 = rem[0];
                  if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);
                  n = mathfloor(rem0 / yc0);
                  if (n > 1) {
                    if (n >= base) n = base - 1;
                    prod = multiply(yc, n, base);
                    prodL = prod.length;
                    remL = rem.length;
                    while (compare2(prod, rem, prodL, remL) == 1) {
                      n--;
                      subtract(prod, yL < prodL ? yz : yc, prodL, base);
                      prodL = prod.length;
                      cmp = 1;
                    }
                  } else {
                    if (n == 0) {
                      cmp = n = 1;
                    }
                    prod = yc.slice();
                    prodL = prod.length;
                  }
                  if (prodL < remL) prod = [0].concat(prod);
                  subtract(rem, prod, remL, base);
                  remL = rem.length;
                  if (cmp == -1) {
                    while (compare2(yc, rem, yL, remL) < 1) {
                      n++;
                      subtract(rem, yL < remL ? yz : yc, remL, base);
                      remL = rem.length;
                    }
                  }
                } else if (cmp === 0) {
                  n++;
                  rem = [0];
                }
                qc[i2++] = n;
                if (rem[0]) {
                  rem[remL++] = xc[xi] || 0;
                } else {
                  rem = [xc[xi]];
                  remL = 1;
                }
              } while ((xi++ < xL || rem[0] != null) && s2--);
              more = rem[0] != null;
              if (!qc[0]) qc.splice(0, 1);
            }
            if (base == BASE) {
              for (i2 = 1, s2 = qc[0]; s2 >= 10; s2 /= 10, i2++) ;
              round(q, dp + (q.e = i2 + e2 * LOG_BASE - 1) + 1, rm, more);
            } else {
              q.e = e2;
              q.r = +more;
            }
            return q;
          };
        }();
        function format(n, i2, rm, id) {
          var c0, e2, ne, len, str;
          if (rm == null) rm = ROUNDING_MODE;
          else intCheck(rm, 0, 8);
          if (!n.c) return n.toString();
          c0 = n.c[0];
          ne = n.e;
          if (i2 == null) {
            str = coeffToString(n.c);
            str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str, ne) : toFixedPoint(str, ne, "0");
          } else {
            n = round(new BigNumber2(n), i2, rm);
            e2 = n.e;
            str = coeffToString(n.c);
            len = str.length;
            if (id == 1 || id == 2 && (i2 <= e2 || e2 <= TO_EXP_NEG)) {
              for (; len < i2; str += "0", len++) ;
              str = toExponential(str, e2);
            } else {
              i2 -= ne;
              str = toFixedPoint(str, e2, "0");
              if (e2 + 1 > len) {
                if (--i2 > 0) for (str += "."; i2--; str += "0") ;
              } else {
                i2 += e2 - len;
                if (i2 > 0) {
                  if (e2 + 1 == len) str += ".";
                  for (; i2--; str += "0") ;
                }
              }
            }
          }
          return n.s < 0 && c0 ? "-" + str : str;
        }
        function maxOrMin(args, n) {
          var k, y, i2 = 1, x2 = new BigNumber2(args[0]);
          for (; i2 < args.length; i2++) {
            y = new BigNumber2(args[i2]);
            if (!y.s || (k = compare(x2, y)) === n || k === 0 && x2.s === n) {
              x2 = y;
            }
          }
          return x2;
        }
        function normalise(n, c, e2) {
          var i2 = 1, j = c.length;
          for (; !c[--j]; c.pop()) ;
          for (j = c[0]; j >= 10; j /= 10, i2++) ;
          if ((e2 = i2 + e2 * LOG_BASE - 1) > MAX_EXP) {
            n.c = n.e = null;
          } else if (e2 < MIN_EXP) {
            n.c = [n.e = 0];
          } else {
            n.e = e2;
            n.c = c;
          }
          return n;
        }
        parseNumeric = /* @__PURE__ */ function() {
          var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
          return function(x2, str, isNum, b) {
            var base, s2 = isNum ? str : str.replace(whitespaceOrPlus, "");
            if (isInfinityOrNaN.test(s2)) {
              x2.s = isNaN(s2) ? null : s2 < 0 ? -1 : 1;
            } else {
              if (!isNum) {
                s2 = s2.replace(basePrefix, function(m2, p1, p2) {
                  base = (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
                  return !b || b == base ? p1 : m2;
                });
                if (b) {
                  base = b;
                  s2 = s2.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
                }
                if (str != s2) return new BigNumber2(s2, base);
              }
              if (BigNumber2.DEBUG) {
                throw Error(bignumberError + "Not a" + (b ? " base " + b : "") + " number: " + str);
              }
              x2.s = null;
            }
            x2.c = x2.e = null;
          };
        }();
        function round(x2, sd, rm, r2) {
          var d, i2, j, k, n, ni, rd, xc = x2.c, pows10 = POWS_TEN;
          if (xc) {
            out: {
              for (d = 1, k = xc[0]; k >= 10; k /= 10, d++) ;
              i2 = sd - d;
              if (i2 < 0) {
                i2 += LOG_BASE;
                j = sd;
                n = xc[ni = 0];
                rd = mathfloor(n / pows10[d - j - 1] % 10);
              } else {
                ni = mathceil((i2 + 1) / LOG_BASE);
                if (ni >= xc.length) {
                  if (r2) {
                    for (; xc.length <= ni; xc.push(0)) ;
                    n = rd = 0;
                    d = 1;
                    i2 %= LOG_BASE;
                    j = i2 - LOG_BASE + 1;
                  } else {
                    break out;
                  }
                } else {
                  n = k = xc[ni];
                  for (d = 1; k >= 10; k /= 10, d++) ;
                  i2 %= LOG_BASE;
                  j = i2 - LOG_BASE + d;
                  rd = j < 0 ? 0 : mathfloor(n / pows10[d - j - 1] % 10);
                }
              }
              r2 = r2 || sd < 0 || // Are there any non-zero digits after the rounding digit?
              // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
              // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
              xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);
              r2 = rm < 4 ? (rd || r2) && (rm == 0 || rm == (x2.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r2 || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
              (i2 > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x2.s < 0 ? 8 : 7));
              if (sd < 1 || !xc[0]) {
                xc.length = 0;
                if (r2) {
                  sd -= x2.e + 1;
                  xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
                  x2.e = -sd || 0;
                } else {
                  xc[0] = x2.e = 0;
                }
                return x2;
              }
              if (i2 == 0) {
                xc.length = ni;
                k = 1;
                ni--;
              } else {
                xc.length = ni + 1;
                k = pows10[LOG_BASE - i2];
                xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
              }
              if (r2) {
                for (; ; ) {
                  if (ni == 0) {
                    for (i2 = 1, j = xc[0]; j >= 10; j /= 10, i2++) ;
                    j = xc[0] += k;
                    for (k = 1; j >= 10; j /= 10, k++) ;
                    if (i2 != k) {
                      x2.e++;
                      if (xc[0] == BASE) xc[0] = 1;
                    }
                    break;
                  } else {
                    xc[ni] += k;
                    if (xc[ni] != BASE) break;
                    xc[ni--] = 0;
                    k = 1;
                  }
                }
              }
              for (i2 = xc.length; xc[--i2] === 0; xc.pop()) ;
            }
            if (x2.e > MAX_EXP) {
              x2.c = x2.e = null;
            } else if (x2.e < MIN_EXP) {
              x2.c = [x2.e = 0];
            }
          }
          return x2;
        }
        function valueOf(n) {
          var str, e2 = n.e;
          if (e2 === null) return n.toString();
          str = coeffToString(n.c);
          str = e2 <= TO_EXP_NEG || e2 >= TO_EXP_POS ? toExponential(str, e2) : toFixedPoint(str, e2, "0");
          return n.s < 0 ? "-" + str : str;
        }
        P.absoluteValue = P.abs = function() {
          var x2 = new BigNumber2(this);
          if (x2.s < 0) x2.s = 1;
          return x2;
        };
        P.comparedTo = function(y, b) {
          return compare(this, new BigNumber2(y, b));
        };
        P.decimalPlaces = P.dp = function(dp, rm) {
          var c, n, v, x2 = this;
          if (dp != null) {
            intCheck(dp, 0, MAX);
            if (rm == null) rm = ROUNDING_MODE;
            else intCheck(rm, 0, 8);
            return round(new BigNumber2(x2), dp + x2.e + 1, rm);
          }
          if (!(c = x2.c)) return null;
          n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
          if (v = c[v]) for (; v % 10 == 0; v /= 10, n--) ;
          if (n < 0) n = 0;
          return n;
        };
        P.dividedBy = P.div = function(y, b) {
          return div(this, new BigNumber2(y, b), DECIMAL_PLACES, ROUNDING_MODE);
        };
        P.dividedToIntegerBy = P.idiv = function(y, b) {
          return div(this, new BigNumber2(y, b), 0, 1);
        };
        P.exponentiatedBy = P.pow = function(n, m2) {
          var half, isModExp, i2, k, more, nIsBig, nIsNeg, nIsOdd, y, x2 = this;
          n = new BigNumber2(n);
          if (n.c && !n.isInteger()) {
            throw Error(bignumberError + "Exponent not an integer: " + valueOf(n));
          }
          if (m2 != null) m2 = new BigNumber2(m2);
          nIsBig = n.e > 14;
          if (!x2.c || !x2.c[0] || x2.c[0] == 1 && !x2.e && x2.c.length == 1 || !n.c || !n.c[0]) {
            y = new BigNumber2(Math.pow(+valueOf(x2), nIsBig ? n.s * (2 - isOdd(n)) : +valueOf(n)));
            return m2 ? y.mod(m2) : y;
          }
          nIsNeg = n.s < 0;
          if (m2) {
            if (m2.c ? !m2.c[0] : !m2.s) return new BigNumber2(NaN);
            isModExp = !nIsNeg && x2.isInteger() && m2.isInteger();
            if (isModExp) x2 = x2.mod(m2);
          } else if (n.e > 9 && (x2.e > 0 || x2.e < -1 || (x2.e == 0 ? x2.c[0] > 1 || nIsBig && x2.c[1] >= 24e7 : x2.c[0] < 8e13 || nIsBig && x2.c[0] <= 9999975e7))) {
            k = x2.s < 0 && isOdd(n) ? -0 : 0;
            if (x2.e > -1) k = 1 / k;
            return new BigNumber2(nIsNeg ? 1 / k : k);
          } else if (POW_PRECISION) {
            k = mathceil(POW_PRECISION / LOG_BASE + 2);
          }
          if (nIsBig) {
            half = new BigNumber2(0.5);
            if (nIsNeg) n.s = 1;
            nIsOdd = isOdd(n);
          } else {
            i2 = Math.abs(+valueOf(n));
            nIsOdd = i2 % 2;
          }
          y = new BigNumber2(ONE);
          for (; ; ) {
            if (nIsOdd) {
              y = y.times(x2);
              if (!y.c) break;
              if (k) {
                if (y.c.length > k) y.c.length = k;
              } else if (isModExp) {
                y = y.mod(m2);
              }
            }
            if (i2) {
              i2 = mathfloor(i2 / 2);
              if (i2 === 0) break;
              nIsOdd = i2 % 2;
            } else {
              n = n.times(half);
              round(n, n.e + 1, 1);
              if (n.e > 14) {
                nIsOdd = isOdd(n);
              } else {
                i2 = +valueOf(n);
                if (i2 === 0) break;
                nIsOdd = i2 % 2;
              }
            }
            x2 = x2.times(x2);
            if (k) {
              if (x2.c && x2.c.length > k) x2.c.length = k;
            } else if (isModExp) {
              x2 = x2.mod(m2);
            }
          }
          if (isModExp) return y;
          if (nIsNeg) y = ONE.div(y);
          return m2 ? y.mod(m2) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
        };
        P.integerValue = function(rm) {
          var n = new BigNumber2(this);
          if (rm == null) rm = ROUNDING_MODE;
          else intCheck(rm, 0, 8);
          return round(n, n.e + 1, rm);
        };
        P.isEqualTo = P.eq = function(y, b) {
          return compare(this, new BigNumber2(y, b)) === 0;
        };
        P.isFinite = function() {
          return !!this.c;
        };
        P.isGreaterThan = P.gt = function(y, b) {
          return compare(this, new BigNumber2(y, b)) > 0;
        };
        P.isGreaterThanOrEqualTo = P.gte = function(y, b) {
          return (b = compare(this, new BigNumber2(y, b))) === 1 || b === 0;
        };
        P.isInteger = function() {
          return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
        };
        P.isLessThan = P.lt = function(y, b) {
          return compare(this, new BigNumber2(y, b)) < 0;
        };
        P.isLessThanOrEqualTo = P.lte = function(y, b) {
          return (b = compare(this, new BigNumber2(y, b))) === -1 || b === 0;
        };
        P.isNaN = function() {
          return !this.s;
        };
        P.isNegative = function() {
          return this.s < 0;
        };
        P.isPositive = function() {
          return this.s > 0;
        };
        P.isZero = function() {
          return !!this.c && this.c[0] == 0;
        };
        P.minus = function(y, b) {
          var i2, j, t2, xLTy, x2 = this, a = x2.s;
          y = new BigNumber2(y, b);
          b = y.s;
          if (!a || !b) return new BigNumber2(NaN);
          if (a != b) {
            y.s = -b;
            return x2.plus(y);
          }
          var xe = x2.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x2.c, yc = y.c;
          if (!xe || !ye) {
            if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber2(yc ? x2 : NaN);
            if (!xc[0] || !yc[0]) {
              return yc[0] ? (y.s = -b, y) : new BigNumber2(xc[0] ? x2 : (
                // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
                ROUNDING_MODE == 3 ? -0 : 0
              ));
            }
          }
          xe = bitFloor(xe);
          ye = bitFloor(ye);
          xc = xc.slice();
          if (a = xe - ye) {
            if (xLTy = a < 0) {
              a = -a;
              t2 = xc;
            } else {
              ye = xe;
              t2 = yc;
            }
            t2.reverse();
            for (b = a; b--; t2.push(0)) ;
            t2.reverse();
          } else {
            j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;
            for (a = b = 0; b < j; b++) {
              if (xc[b] != yc[b]) {
                xLTy = xc[b] < yc[b];
                break;
              }
            }
          }
          if (xLTy) {
            t2 = xc;
            xc = yc;
            yc = t2;
            y.s = -y.s;
          }
          b = (j = yc.length) - (i2 = xc.length);
          if (b > 0) for (; b--; xc[i2++] = 0) ;
          b = BASE - 1;
          for (; j > a; ) {
            if (xc[--j] < yc[j]) {
              for (i2 = j; i2 && !xc[--i2]; xc[i2] = b) ;
              --xc[i2];
              xc[j] += BASE;
            }
            xc[j] -= yc[j];
          }
          for (; xc[0] == 0; xc.splice(0, 1), --ye) ;
          if (!xc[0]) {
            y.s = ROUNDING_MODE == 3 ? -1 : 1;
            y.c = [y.e = 0];
            return y;
          }
          return normalise(y, xc, ye);
        };
        P.modulo = P.mod = function(y, b) {
          var q, s2, x2 = this;
          y = new BigNumber2(y, b);
          if (!x2.c || !y.s || y.c && !y.c[0]) {
            return new BigNumber2(NaN);
          } else if (!y.c || x2.c && !x2.c[0]) {
            return new BigNumber2(x2);
          }
          if (MODULO_MODE == 9) {
            s2 = y.s;
            y.s = 1;
            q = div(x2, y, 0, 3);
            y.s = s2;
            q.s *= s2;
          } else {
            q = div(x2, y, 0, MODULO_MODE);
          }
          y = x2.minus(q.times(y));
          if (!y.c[0] && MODULO_MODE == 1) y.s = x2.s;
          return y;
        };
        P.multipliedBy = P.times = function(y, b) {
          var c, e2, i2, j, k, m2, xcL, xlo, xhi, ycL, ylo, yhi, zc, base, sqrtBase, x2 = this, xc = x2.c, yc = (y = new BigNumber2(y, b)).c;
          if (!xc || !yc || !xc[0] || !yc[0]) {
            if (!x2.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
              y.c = y.e = y.s = null;
            } else {
              y.s *= x2.s;
              if (!xc || !yc) {
                y.c = y.e = null;
              } else {
                y.c = [0];
                y.e = 0;
              }
            }
            return y;
          }
          e2 = bitFloor(x2.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
          y.s *= x2.s;
          xcL = xc.length;
          ycL = yc.length;
          if (xcL < ycL) {
            zc = xc;
            xc = yc;
            yc = zc;
            i2 = xcL;
            xcL = ycL;
            ycL = i2;
          }
          for (i2 = xcL + ycL, zc = []; i2--; zc.push(0)) ;
          base = BASE;
          sqrtBase = SQRT_BASE;
          for (i2 = ycL; --i2 >= 0; ) {
            c = 0;
            ylo = yc[i2] % sqrtBase;
            yhi = yc[i2] / sqrtBase | 0;
            for (k = xcL, j = i2 + k; j > i2; ) {
              xlo = xc[--k] % sqrtBase;
              xhi = xc[k] / sqrtBase | 0;
              m2 = yhi * xlo + xhi * ylo;
              xlo = ylo * xlo + m2 % sqrtBase * sqrtBase + zc[j] + c;
              c = (xlo / base | 0) + (m2 / sqrtBase | 0) + yhi * xhi;
              zc[j--] = xlo % base;
            }
            zc[j] = c;
          }
          if (c) {
            ++e2;
          } else {
            zc.splice(0, 1);
          }
          return normalise(y, zc, e2);
        };
        P.negated = function() {
          var x2 = new BigNumber2(this);
          x2.s = -x2.s || null;
          return x2;
        };
        P.plus = function(y, b) {
          var t2, x2 = this, a = x2.s;
          y = new BigNumber2(y, b);
          b = y.s;
          if (!a || !b) return new BigNumber2(NaN);
          if (a != b) {
            y.s = -b;
            return x2.minus(y);
          }
          var xe = x2.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x2.c, yc = y.c;
          if (!xe || !ye) {
            if (!xc || !yc) return new BigNumber2(a / 0);
            if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber2(xc[0] ? x2 : a * 0);
          }
          xe = bitFloor(xe);
          ye = bitFloor(ye);
          xc = xc.slice();
          if (a = xe - ye) {
            if (a > 0) {
              ye = xe;
              t2 = yc;
            } else {
              a = -a;
              t2 = xc;
            }
            t2.reverse();
            for (; a--; t2.push(0)) ;
            t2.reverse();
          }
          a = xc.length;
          b = yc.length;
          if (a - b < 0) {
            t2 = yc;
            yc = xc;
            xc = t2;
            b = a;
          }
          for (a = 0; b; ) {
            a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
            xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
          }
          if (a) {
            xc = [a].concat(xc);
            ++ye;
          }
          return normalise(y, xc, ye);
        };
        P.precision = P.sd = function(sd, rm) {
          var c, n, v, x2 = this;
          if (sd != null && sd !== !!sd) {
            intCheck(sd, 1, MAX);
            if (rm == null) rm = ROUNDING_MODE;
            else intCheck(rm, 0, 8);
            return round(new BigNumber2(x2), sd, rm);
          }
          if (!(c = x2.c)) return null;
          v = c.length - 1;
          n = v * LOG_BASE + 1;
          if (v = c[v]) {
            for (; v % 10 == 0; v /= 10, n--) ;
            for (v = c[0]; v >= 10; v /= 10, n++) ;
          }
          if (sd && x2.e + 1 > n) n = x2.e + 1;
          return n;
        };
        P.shiftedBy = function(k) {
          intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
          return this.times("1e" + k);
        };
        P.squareRoot = P.sqrt = function() {
          var m2, n, r2, rep, t2, x2 = this, c = x2.c, s2 = x2.s, e2 = x2.e, dp = DECIMAL_PLACES + 4, half = new BigNumber2("0.5");
          if (s2 !== 1 || !c || !c[0]) {
            return new BigNumber2(!s2 || s2 < 0 && (!c || c[0]) ? NaN : c ? x2 : 1 / 0);
          }
          s2 = Math.sqrt(+valueOf(x2));
          if (s2 == 0 || s2 == 1 / 0) {
            n = coeffToString(c);
            if ((n.length + e2) % 2 == 0) n += "0";
            s2 = Math.sqrt(+n);
            e2 = bitFloor((e2 + 1) / 2) - (e2 < 0 || e2 % 2);
            if (s2 == 1 / 0) {
              n = "5e" + e2;
            } else {
              n = s2.toExponential();
              n = n.slice(0, n.indexOf("e") + 1) + e2;
            }
            r2 = new BigNumber2(n);
          } else {
            r2 = new BigNumber2(s2 + "");
          }
          if (r2.c[0]) {
            e2 = r2.e;
            s2 = e2 + dp;
            if (s2 < 3) s2 = 0;
            for (; ; ) {
              t2 = r2;
              r2 = half.times(t2.plus(div(x2, t2, dp, 1)));
              if (coeffToString(t2.c).slice(0, s2) === (n = coeffToString(r2.c)).slice(0, s2)) {
                if (r2.e < e2) --s2;
                n = n.slice(s2 - 3, s2 + 1);
                if (n == "9999" || !rep && n == "4999") {
                  if (!rep) {
                    round(t2, t2.e + DECIMAL_PLACES + 2, 0);
                    if (t2.times(t2).eq(x2)) {
                      r2 = t2;
                      break;
                    }
                  }
                  dp += 4;
                  s2 += 4;
                  rep = 1;
                } else {
                  if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
                    round(r2, r2.e + DECIMAL_PLACES + 2, 1);
                    m2 = !r2.times(r2).eq(x2);
                  }
                  break;
                }
              }
            }
          }
          return round(r2, r2.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m2);
        };
        P.toExponential = function(dp, rm) {
          if (dp != null) {
            intCheck(dp, 0, MAX);
            dp++;
          }
          return format(this, dp, rm, 1);
        };
        P.toFixed = function(dp, rm) {
          if (dp != null) {
            intCheck(dp, 0, MAX);
            dp = dp + this.e + 1;
          }
          return format(this, dp, rm);
        };
        P.toFormat = function(dp, rm, format2) {
          var str, x2 = this;
          if (format2 == null) {
            if (dp != null && rm && typeof rm == "object") {
              format2 = rm;
              rm = null;
            } else if (dp && typeof dp == "object") {
              format2 = dp;
              dp = rm = null;
            } else {
              format2 = FORMAT;
            }
          } else if (typeof format2 != "object") {
            throw Error(bignumberError + "Argument not an object: " + format2);
          }
          str = x2.toFixed(dp, rm);
          if (x2.c) {
            var i2, arr = str.split("."), g1 = +format2.groupSize, g2 = +format2.secondaryGroupSize, groupSeparator = format2.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x2.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
            if (g2) {
              i2 = g1;
              g1 = g2;
              g2 = i2;
              len -= i2;
            }
            if (g1 > 0 && len > 0) {
              i2 = len % g1 || g1;
              intPart = intDigits.substr(0, i2);
              for (; i2 < len; i2 += g1) intPart += groupSeparator + intDigits.substr(i2, g1);
              if (g2 > 0) intPart += groupSeparator + intDigits.slice(i2);
              if (isNeg) intPart = "-" + intPart;
            }
            str = fractionPart ? intPart + (format2.decimalSeparator || "") + ((g2 = +format2.fractionGroupSize) ? fractionPart.replace(
              new RegExp("\\d{" + g2 + "}\\B", "g"),
              "$&" + (format2.fractionGroupSeparator || "")
            ) : fractionPart) : intPart;
          }
          return (format2.prefix || "") + str + (format2.suffix || "");
        };
        P.toFraction = function(md) {
          var d, d0, d1, d2, e2, exp, n, n0, n1, q, r2, s2, x2 = this, xc = x2.c;
          if (md != null) {
            n = new BigNumber2(md);
            if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
              throw Error(bignumberError + "Argument " + (n.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n));
            }
          }
          if (!xc) return new BigNumber2(x2);
          d = new BigNumber2(ONE);
          n1 = d0 = new BigNumber2(ONE);
          d1 = n0 = new BigNumber2(ONE);
          s2 = coeffToString(xc);
          e2 = d.e = s2.length - x2.e - 1;
          d.c[0] = POWS_TEN[(exp = e2 % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
          md = !md || n.comparedTo(d) > 0 ? e2 > 0 ? d : n1 : n;
          exp = MAX_EXP;
          MAX_EXP = 1 / 0;
          n = new BigNumber2(s2);
          n0.c[0] = 0;
          for (; ; ) {
            q = div(n, d, 0, 1);
            d2 = d0.plus(q.times(d1));
            if (d2.comparedTo(md) == 1) break;
            d0 = d1;
            d1 = d2;
            n1 = n0.plus(q.times(d2 = n1));
            n0 = d2;
            d = n.minus(q.times(d2 = d));
            n = d2;
          }
          d2 = div(md.minus(d0), d1, 0, 1);
          n0 = n0.plus(d2.times(n1));
          d0 = d0.plus(d2.times(d1));
          n0.s = n1.s = x2.s;
          e2 = e2 * 2;
          r2 = div(n1, d1, e2, ROUNDING_MODE).minus(x2).abs().comparedTo(
            div(n0, d0, e2, ROUNDING_MODE).minus(x2).abs()
          ) < 1 ? [n1, d1] : [n0, d0];
          MAX_EXP = exp;
          return r2;
        };
        P.toNumber = function() {
          return +valueOf(this);
        };
        P.toPrecision = function(sd, rm) {
          if (sd != null) intCheck(sd, 1, MAX);
          return format(this, sd, rm, 2);
        };
        P.toString = function(b) {
          var str, n = this, s2 = n.s, e2 = n.e;
          if (e2 === null) {
            if (s2) {
              str = "Infinity";
              if (s2 < 0) str = "-" + str;
            } else {
              str = "NaN";
            }
          } else {
            if (b == null) {
              str = e2 <= TO_EXP_NEG || e2 >= TO_EXP_POS ? toExponential(coeffToString(n.c), e2) : toFixedPoint(coeffToString(n.c), e2, "0");
            } else if (b === 10 && alphabetHasNormalDecimalDigits) {
              n = round(new BigNumber2(n), DECIMAL_PLACES + e2 + 1, ROUNDING_MODE);
              str = toFixedPoint(coeffToString(n.c), n.e, "0");
            } else {
              intCheck(b, 2, ALPHABET.length, "Base");
              str = convertBase(toFixedPoint(coeffToString(n.c), e2, "0"), 10, b, s2, true);
            }
            if (s2 < 0 && n.c[0]) str = "-" + str;
          }
          return str;
        };
        P.valueOf = P.toJSON = function() {
          return valueOf(this);
        };
        P._isBigNumber = true;
        if (configObject != null) BigNumber2.set(configObject);
        return BigNumber2;
      }
      function bitFloor(n) {
        var i2 = n | 0;
        return n > 0 || n === i2 ? i2 : i2 - 1;
      }
      function coeffToString(a) {
        var s2, z, i2 = 1, j = a.length, r2 = a[0] + "";
        for (; i2 < j; ) {
          s2 = a[i2++] + "";
          z = LOG_BASE - s2.length;
          for (; z--; s2 = "0" + s2) ;
          r2 += s2;
        }
        for (j = r2.length; r2.charCodeAt(--j) === 48; ) ;
        return r2.slice(0, j + 1 || 1);
      }
      function compare(x2, y) {
        var a, b, xc = x2.c, yc = y.c, i2 = x2.s, j = y.s, k = x2.e, l = y.e;
        if (!i2 || !j) return null;
        a = xc && !xc[0];
        b = yc && !yc[0];
        if (a || b) return a ? b ? 0 : -j : i2;
        if (i2 != j) return i2;
        a = i2 < 0;
        b = k == l;
        if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;
        if (!b) return k > l ^ a ? 1 : -1;
        j = (k = xc.length) < (l = yc.length) ? k : l;
        for (i2 = 0; i2 < j; i2++) if (xc[i2] != yc[i2]) return xc[i2] > yc[i2] ^ a ? 1 : -1;
        return k == l ? 0 : k > l ^ a ? 1 : -1;
      }
      function intCheck(n, min, max, name) {
        if (n < min || n > max || n !== mathfloor(n)) {
          throw Error(bignumberError + (name || "Argument") + (typeof n == "number" ? n < min || n > max ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n));
        }
      }
      function isOdd(n) {
        var k = n.c.length - 1;
        return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
      }
      function toExponential(str, e2) {
        return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e2 < 0 ? "e" : "e+") + e2;
      }
      function toFixedPoint(str, e2, z) {
        var len, zs;
        if (e2 < 0) {
          for (zs = z + "."; ++e2; zs += z) ;
          str = zs + str;
        } else {
          len = str.length;
          if (++e2 > len) {
            for (zs = z, e2 -= len; --e2; zs += z) ;
            str += zs;
          } else if (e2 < len) {
            str = str.slice(0, e2) + "." + str.slice(e2);
          }
        }
        return str;
      }
      BigNumber = clone2();
      BigNumber["default"] = BigNumber.BigNumber = BigNumber;
      if (typeof define == "function" && define.amd) {
        define(function() {
          return BigNumber;
        });
      } else if (typeof module2 != "undefined" && module2.exports) {
        module2.exports = BigNumber;
      } else {
        if (!globalObject) {
          globalObject = typeof self != "undefined" && self ? self : window;
        }
        globalObject.BigNumber = BigNumber;
      }
    })(exports2);
  }
});

// node_modules/json-bigint/lib/stringify.js
var require_stringify = __commonJS({
  "node_modules/json-bigint/lib/stringify.js"(exports2, module2) {
    var BigNumber = require_bignumber();
    var JSON2 = module2.exports;
    (function() {
      "use strict";
      function f3(n) {
        return n < 10 ? "0" + n : n;
      }
      var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, gap, indent, meta = {
        // table of character substitutions
        "\b": "\\b",
        "	": "\\t",
        "\n": "\\n",
        "\f": "\\f",
        "\r": "\\r",
        '"': '\\"',
        "\\": "\\\\"
      }, rep;
      function quote(string) {
        escapable.lastIndex = 0;
        return escapable.test(string) ? '"' + string.replace(escapable, function(a) {
          var c = meta[a];
          return typeof c === "string" ? c : "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
        }) + '"' : '"' + string + '"';
      }
      function str(key, holder) {
        var i2, k, v, length, mind = gap, partial, value = holder[key], isBigNumber = value != null && (value instanceof BigNumber || BigNumber.isBigNumber(value));
        if (value && typeof value === "object" && typeof value.toJSON === "function") {
          value = value.toJSON(key);
        }
        if (typeof rep === "function") {
          value = rep.call(holder, key, value);
        }
        switch (typeof value) {
          case "string":
            if (isBigNumber) {
              return value;
            } else {
              return quote(value);
            }
          case "number":
            return isFinite(value) ? String(value) : "null";
          case "boolean":
          case "null":
          case "bigint":
            return String(value);
          // If the type is 'object', we might be dealing with an object or an array or
          // null.
          case "object":
            if (!value) {
              return "null";
            }
            gap += indent;
            partial = [];
            if (Object.prototype.toString.apply(value) === "[object Array]") {
              length = value.length;
              for (i2 = 0; i2 < length; i2 += 1) {
                partial[i2] = str(i2, value) || "null";
              }
              v = partial.length === 0 ? "[]" : gap ? "[\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "]" : "[" + partial.join(",") + "]";
              gap = mind;
              return v;
            }
            if (rep && typeof rep === "object") {
              length = rep.length;
              for (i2 = 0; i2 < length; i2 += 1) {
                if (typeof rep[i2] === "string") {
                  k = rep[i2];
                  v = str(k, value);
                  if (v) {
                    partial.push(quote(k) + (gap ? ": " : ":") + v);
                  }
                }
              }
            } else {
              Object.keys(value).forEach(function(k2) {
                var v2 = str(k2, value);
                if (v2) {
                  partial.push(quote(k2) + (gap ? ": " : ":") + v2);
                }
              });
            }
            v = partial.length === 0 ? "{}" : gap ? "{\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "}" : "{" + partial.join(",") + "}";
            gap = mind;
            return v;
        }
      }
      if (typeof JSON2.stringify !== "function") {
        JSON2.stringify = function(value, replacer, space) {
          var i2;
          gap = "";
          indent = "";
          if (typeof space === "number") {
            for (i2 = 0; i2 < space; i2 += 1) {
              indent += " ";
            }
          } else if (typeof space === "string") {
            indent = space;
          }
          rep = replacer;
          if (replacer && typeof replacer !== "function" && (typeof replacer !== "object" || typeof replacer.length !== "number")) {
            throw new Error("JSON.stringify");
          }
          return str("", { "": value });
        };
      }
    })();
  }
});

// node_modules/json-bigint/lib/parse.js
var require_parse = __commonJS({
  "node_modules/json-bigint/lib/parse.js"(exports2, module2) {
    var BigNumber = null;
    var suspectProtoRx = /(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])/;
    var suspectConstructorRx = /(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)/;
    var json_parse = function(options) {
      "use strict";
      var _options = {
        strict: false,
        // not being strict means do not generate syntax errors for "duplicate key"
        storeAsString: false,
        // toggles whether the values should be stored as BigNumber (default) or a string
        alwaysParseAsBig: false,
        // toggles whether all numbers should be Big
        useNativeBigInt: false,
        // toggles whether to use native BigInt instead of bignumber.js
        protoAction: "error",
        constructorAction: "error"
      };
      if (options !== void 0 && options !== null) {
        if (options.strict === true) {
          _options.strict = true;
        }
        if (options.storeAsString === true) {
          _options.storeAsString = true;
        }
        _options.alwaysParseAsBig = options.alwaysParseAsBig === true ? options.alwaysParseAsBig : false;
        _options.useNativeBigInt = options.useNativeBigInt === true ? options.useNativeBigInt : false;
        if (typeof options.constructorAction !== "undefined") {
          if (options.constructorAction === "error" || options.constructorAction === "ignore" || options.constructorAction === "preserve") {
            _options.constructorAction = options.constructorAction;
          } else {
            throw new Error(
              `Incorrect value for constructorAction option, must be "error", "ignore" or undefined but passed ${options.constructorAction}`
            );
          }
        }
        if (typeof options.protoAction !== "undefined") {
          if (options.protoAction === "error" || options.protoAction === "ignore" || options.protoAction === "preserve") {
            _options.protoAction = options.protoAction;
          } else {
            throw new Error(
              `Incorrect value for protoAction option, must be "error", "ignore" or undefined but passed ${options.protoAction}`
            );
          }
        }
      }
      var at, ch, escapee = {
        '"': '"',
        "\\": "\\",
        "/": "/",
        b: "\b",
        f: "\f",
        n: "\n",
        r: "\r",
        t: "	"
      }, text, error = function(m2) {
        throw {
          name: "SyntaxError",
          message: m2,
          at,
          text
        };
      }, next = function(c) {
        if (c && c !== ch) {
          error("Expected '" + c + "' instead of '" + ch + "'");
        }
        ch = text.charAt(at);
        at += 1;
        return ch;
      }, number = function() {
        var number2, string2 = "";
        if (ch === "-") {
          string2 = "-";
          next("-");
        }
        while (ch >= "0" && ch <= "9") {
          string2 += ch;
          next();
        }
        if (ch === ".") {
          string2 += ".";
          while (next() && ch >= "0" && ch <= "9") {
            string2 += ch;
          }
        }
        if (ch === "e" || ch === "E") {
          string2 += ch;
          next();
          if (ch === "-" || ch === "+") {
            string2 += ch;
            next();
          }
          while (ch >= "0" && ch <= "9") {
            string2 += ch;
            next();
          }
        }
        number2 = +string2;
        if (!isFinite(number2)) {
          error("Bad number");
        } else {
          if (BigNumber == null) BigNumber = require_bignumber();
          if (string2.length > 15)
            return _options.storeAsString ? string2 : _options.useNativeBigInt ? BigInt(string2) : new BigNumber(string2);
          else
            return !_options.alwaysParseAsBig ? number2 : _options.useNativeBigInt ? BigInt(number2) : new BigNumber(number2);
        }
      }, string = function() {
        var hex, i2, string2 = "", uffff;
        if (ch === '"') {
          var startAt = at;
          while (next()) {
            if (ch === '"') {
              if (at - 1 > startAt) string2 += text.substring(startAt, at - 1);
              next();
              return string2;
            }
            if (ch === "\\") {
              if (at - 1 > startAt) string2 += text.substring(startAt, at - 1);
              next();
              if (ch === "u") {
                uffff = 0;
                for (i2 = 0; i2 < 4; i2 += 1) {
                  hex = parseInt(next(), 16);
                  if (!isFinite(hex)) {
                    break;
                  }
                  uffff = uffff * 16 + hex;
                }
                string2 += String.fromCharCode(uffff);
              } else if (typeof escapee[ch] === "string") {
                string2 += escapee[ch];
              } else {
                break;
              }
              startAt = at;
            }
          }
        }
        error("Bad string");
      }, white = function() {
        while (ch && ch <= " ") {
          next();
        }
      }, word = function() {
        switch (ch) {
          case "t":
            next("t");
            next("r");
            next("u");
            next("e");
            return true;
          case "f":
            next("f");
            next("a");
            next("l");
            next("s");
            next("e");
            return false;
          case "n":
            next("n");
            next("u");
            next("l");
            next("l");
            return null;
        }
        error("Unexpected '" + ch + "'");
      }, value, array = function() {
        var array2 = [];
        if (ch === "[") {
          next("[");
          white();
          if (ch === "]") {
            next("]");
            return array2;
          }
          while (ch) {
            array2.push(value());
            white();
            if (ch === "]") {
              next("]");
              return array2;
            }
            next(",");
            white();
          }
        }
        error("Bad array");
      }, object = function() {
        var key, object2 = /* @__PURE__ */ Object.create(null);
        if (ch === "{") {
          next("{");
          white();
          if (ch === "}") {
            next("}");
            return object2;
          }
          while (ch) {
            key = string();
            white();
            next(":");
            if (_options.strict === true && Object.hasOwnProperty.call(object2, key)) {
              error('Duplicate key "' + key + '"');
            }
            if (suspectProtoRx.test(key) === true) {
              if (_options.protoAction === "error") {
                error("Object contains forbidden prototype property");
              } else if (_options.protoAction === "ignore") {
                value();
              } else {
                object2[key] = value();
              }
            } else if (suspectConstructorRx.test(key) === true) {
              if (_options.constructorAction === "error") {
                error("Object contains forbidden constructor property");
              } else if (_options.constructorAction === "ignore") {
                value();
              } else {
                object2[key] = value();
              }
            } else {
              object2[key] = value();
            }
            white();
            if (ch === "}") {
              next("}");
              return object2;
            }
            next(",");
            white();
          }
        }
        error("Bad object");
      };
      value = function() {
        white();
        switch (ch) {
          case "{":
            return object();
          case "[":
            return array();
          case '"':
            return string();
          case "-":
            return number();
          default:
            return ch >= "0" && ch <= "9" ? number() : word();
        }
      };
      return function(source, reviver) {
        var result;
        text = source + "";
        at = 0;
        ch = " ";
        result = value();
        white();
        if (ch) {
          error("Syntax error");
        }
        return typeof reviver === "function" ? function walk(holder, key) {
          var k, v, value2 = holder[key];
          if (value2 && typeof value2 === "object") {
            Object.keys(value2).forEach(function(k2) {
              v = walk(value2, k2);
              if (v !== void 0) {
                value2[k2] = v;
              } else {
                delete value2[k2];
              }
            });
          }
          return reviver.call(holder, key, value2);
        }({ "": result }, "") : result;
      };
    };
    module2.exports = json_parse;
  }
});

// node_modules/json-bigint/index.js
var require_json_bigint = __commonJS({
  "node_modules/json-bigint/index.js"(exports2, module2) {
    var json_stringify = require_stringify().stringify;
    var json_parse = require_parse();
    module2.exports = function(options) {
      return {
        parse: json_parse(options),
        stringify: json_stringify
      };
    };
    module2.exports.parse = json_parse();
    module2.exports.stringify = json_stringify;
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports2, module2) {
    var s2 = 1e3;
    var m2 = s2 * 60;
    var h2 = m2 * 60;
    var d = h2 * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h2;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m2;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s2;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h2) {
        return Math.round(ms / h2) + "h";
      }
      if (msAbs >= m2) {
        return Math.round(ms / m2) + "m";
      }
      if (msAbs >= s2) {
        return Math.round(ms / s2) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h2) {
        return plural(ms, msAbs, h2, "hour");
      }
      if (msAbs >= m2) {
        return plural(ms, msAbs, m2, "minute");
      }
      if (msAbs >= s2) {
        return plural(ms, msAbs, s2, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports2, module2) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i2 = 0; i2 < namespace.length; i2++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i2);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(" ", ",").split(",").filter(Boolean);
        for (const ns of split) {
          if (ns[0] === "-") {
            createDebug.skips.push(ns.slice(1));
          } else {
            createDebug.names.push(ns);
          }
        }
      }
      function matchesTemplate(search, template) {
        let searchIndex = 0;
        let templateIndex = 0;
        let starIndex = -1;
        let matchIndex = 0;
        while (searchIndex < search.length) {
          if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
            if (template[templateIndex] === "*") {
              starIndex = templateIndex;
              matchIndex = searchIndex;
              templateIndex++;
            } else {
              searchIndex++;
              templateIndex++;
            }
          } else if (starIndex !== -1) {
            templateIndex = starIndex + 1;
            matchIndex++;
            searchIndex = matchIndex;
          } else {
            return false;
          }
        }
        while (templateIndex < template.length && template[templateIndex] === "*") {
          templateIndex++;
        }
        return templateIndex === template.length;
      }
      function disable() {
        const namespaces = [
          ...createDebug.names,
          ...createDebug.skips.map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        for (const skip of createDebug.skips) {
          if (matchesTemplate(name, skip)) {
            return false;
          }
        }
        for (const ns of createDebug.names) {
          if (matchesTemplate(name, ns)) {
            return true;
          }
        }
        return false;
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports2, module2) {
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m2;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m2 = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m2[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r2;
      try {
        r2 = exports2.storage.getItem("debug");
      } catch (error) {
      }
      if (!r2 && typeof process !== "undefined" && "env" in process) {
        r2 = process.env.DEBUG;
      }
      return r2;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "node_modules/has-flag/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (flag, argv = process.argv) => {
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const position = argv.indexOf(prefix + flag);
      const terminatorPosition = argv.indexOf("--");
      return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
    };
  }
});

// node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "node_modules/supports-color/index.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var tty = require("tty");
    var hasFlag = require_has_flag();
    var { env } = process;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
      forceColor = 0;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = 1;
    }
    if ("FORCE_COLOR" in env) {
      if (env.FORCE_COLOR === "true") {
        forceColor = 1;
      } else if (env.FORCE_COLOR === "false") {
        forceColor = 0;
      } else {
        forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
      }
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(haveStream, streamIsTTY) {
      if (forceColor === 0) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (haveStream && !streamIsTTY && forceColor === void 0) {
        return 0;
      }
      const min = forceColor || 0;
      if (env.TERM === "dumb") {
        return min;
      }
      if (process.platform === "win32") {
        const osRelease = os.release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env) {
        const version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      return min;
    }
    function getSupportLevel(stream) {
      const level = supportsColor(stream, stream && stream.isTTY);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: translateLevel(supportsColor(true, tty.isatty(1))),
      stderr: translateLevel(supportsColor(true, tty.isatty(2)))
    };
  }
});

// node_modules/debug/src/node.js
var require_node = __commonJS({
  "node_modules/debug/src/node.js"(exports2, module2) {
    var tty = require("tty");
    var util = require("util");
    exports2.init = init;
    exports2.log = log;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.destroy = util.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports2.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports2.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports2.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports2.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(util.formatWithOptions(exports2.inspectOpts, ...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug) {
      debug.inspectOpts = {};
      const keys = Object.keys(exports2.inspectOpts);
      for (let i2 = 0; i2 < keys.length; i2++) {
        debug.inspectOpts[keys[i2]] = exports2.inspectOpts[keys[i2]];
      }
    }
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
  }
});

// node_modules/debug/src/index.js
var require_src = __commonJS({
  "node_modules/debug/src/index.js"(exports2, module2) {
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser();
    } else {
      module2.exports = require_node();
    }
  }
});

// node_modules/agent-base/dist/helpers.js
var require_helpers = __commonJS({
  "node_modules/agent-base/dist/helpers.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m2, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m2, k);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m2, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m2[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.req = exports2.json = exports2.toBuffer = void 0;
    var http3 = __importStar(require("http"));
    var https2 = __importStar(require("https"));
    async function toBuffer(stream) {
      let length = 0;
      const chunks = [];
      for await (const chunk of stream) {
        length += chunk.length;
        chunks.push(chunk);
      }
      return Buffer.concat(chunks, length);
    }
    exports2.toBuffer = toBuffer;
    async function json(stream) {
      const buf = await toBuffer(stream);
      const str = buf.toString("utf8");
      try {
        return JSON.parse(str);
      } catch (_err) {
        const err = _err;
        err.message += ` (input: ${str})`;
        throw err;
      }
    }
    exports2.json = json;
    function req(url2, opts = {}) {
      const href = typeof url2 === "string" ? url2 : url2.href;
      const req2 = (href.startsWith("https:") ? https2 : http3).request(url2, opts);
      const promise = new Promise((resolve, reject) => {
        req2.once("response", resolve).once("error", reject).end();
      });
      req2.then = promise.then.bind(promise);
      return req2;
    }
    exports2.req = req;
  }
});

// node_modules/agent-base/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/agent-base/dist/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m2, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m2, k);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m2, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m2[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __exportStar = exports2 && exports2.__exportStar || function(m2, exports3) {
      for (var p in m2) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m2, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Agent = void 0;
    var net = __importStar(require("net"));
    var http3 = __importStar(require("http"));
    var https_1 = require("https");
    __exportStar(require_helpers(), exports2);
    var INTERNAL = Symbol("AgentBaseInternalState");
    var Agent = class extends http3.Agent {
      constructor(opts) {
        super(opts);
        this[INTERNAL] = {};
      }
      /**
       * Determine whether this is an `http` or `https` request.
       */
      isSecureEndpoint(options) {
        if (options) {
          if (typeof options.secureEndpoint === "boolean") {
            return options.secureEndpoint;
          }
          if (typeof options.protocol === "string") {
            return options.protocol === "https:";
          }
        }
        const { stack } = new Error();
        if (typeof stack !== "string")
          return false;
        return stack.split("\n").some((l) => l.indexOf("(https.js:") !== -1 || l.indexOf("node:https:") !== -1);
      }
      // In order to support async signatures in `connect()` and Node's native
      // connection pooling in `http.Agent`, the array of sockets for each origin
      // has to be updated synchronously. This is so the length of the array is
      // accurate when `addRequest()` is next called. We achieve this by creating a
      // fake socket and adding it to `sockets[origin]` and incrementing
      // `totalSocketCount`.
      incrementSockets(name) {
        if (this.maxSockets === Infinity && this.maxTotalSockets === Infinity) {
          return null;
        }
        if (!this.sockets[name]) {
          this.sockets[name] = [];
        }
        const fakeSocket = new net.Socket({ writable: false });
        this.sockets[name].push(fakeSocket);
        this.totalSocketCount++;
        return fakeSocket;
      }
      decrementSockets(name, socket) {
        if (!this.sockets[name] || socket === null) {
          return;
        }
        const sockets = this.sockets[name];
        const index = sockets.indexOf(socket);
        if (index !== -1) {
          sockets.splice(index, 1);
          this.totalSocketCount--;
          if (sockets.length === 0) {
            delete this.sockets[name];
          }
        }
      }
      // In order to properly update the socket pool, we need to call `getName()` on
      // the core `https.Agent` if it is a secureEndpoint.
      getName(options) {
        const secureEndpoint = typeof options.secureEndpoint === "boolean" ? options.secureEndpoint : this.isSecureEndpoint(options);
        if (secureEndpoint) {
          return https_1.Agent.prototype.getName.call(this, options);
        }
        return super.getName(options);
      }
      createSocket(req, options, cb) {
        const connectOpts = {
          ...options,
          secureEndpoint: this.isSecureEndpoint(options)
        };
        const name = this.getName(connectOpts);
        const fakeSocket = this.incrementSockets(name);
        Promise.resolve().then(() => this.connect(req, connectOpts)).then((socket) => {
          this.decrementSockets(name, fakeSocket);
          if (socket instanceof http3.Agent) {
            try {
              return socket.addRequest(req, connectOpts);
            } catch (err) {
              return cb(err);
            }
          }
          this[INTERNAL].currentSocket = socket;
          super.createSocket(req, options, cb);
        }, (err) => {
          this.decrementSockets(name, fakeSocket);
          cb(err);
        });
      }
      createConnection() {
        const socket = this[INTERNAL].currentSocket;
        this[INTERNAL].currentSocket = void 0;
        if (!socket) {
          throw new Error("No socket was returned in the `connect()` function");
        }
        return socket;
      }
      get defaultPort() {
        return this[INTERNAL].defaultPort ?? (this.protocol === "https:" ? 443 : 80);
      }
      set defaultPort(v) {
        if (this[INTERNAL]) {
          this[INTERNAL].defaultPort = v;
        }
      }
      get protocol() {
        return this[INTERNAL].protocol ?? (this.isSecureEndpoint() ? "https:" : "http:");
      }
      set protocol(v) {
        if (this[INTERNAL]) {
          this[INTERNAL].protocol = v;
        }
      }
    };
    exports2.Agent = Agent;
  }
});

// node_modules/https-proxy-agent/dist/parse-proxy-response.js
var require_parse_proxy_response = __commonJS({
  "node_modules/https-proxy-agent/dist/parse-proxy-response.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseProxyResponse = void 0;
    var debug_1 = __importDefault(require_src());
    var debug = (0, debug_1.default)("https-proxy-agent:parse-proxy-response");
    function parseProxyResponse(socket) {
      return new Promise((resolve, reject) => {
        let buffersLength = 0;
        const buffers = [];
        function read() {
          const b = socket.read();
          if (b)
            ondata(b);
          else
            socket.once("readable", read);
        }
        function cleanup() {
          socket.removeListener("end", onend);
          socket.removeListener("error", onerror);
          socket.removeListener("readable", read);
        }
        function onend() {
          cleanup();
          debug("onend");
          reject(new Error("Proxy connection ended before receiving CONNECT response"));
        }
        function onerror(err) {
          cleanup();
          debug("onerror %o", err);
          reject(err);
        }
        function ondata(b) {
          buffers.push(b);
          buffersLength += b.length;
          const buffered = Buffer.concat(buffers, buffersLength);
          const endOfHeaders = buffered.indexOf("\r\n\r\n");
          if (endOfHeaders === -1) {
            debug("have not received end of HTTP headers yet...");
            read();
            return;
          }
          const headerParts = buffered.slice(0, endOfHeaders).toString("ascii").split("\r\n");
          const firstLine = headerParts.shift();
          if (!firstLine) {
            socket.destroy();
            return reject(new Error("No header received from proxy CONNECT response"));
          }
          const firstLineParts = firstLine.split(" ");
          const statusCode = +firstLineParts[1];
          const statusText = firstLineParts.slice(2).join(" ");
          const headers = {};
          for (const header of headerParts) {
            if (!header)
              continue;
            const firstColon = header.indexOf(":");
            if (firstColon === -1) {
              socket.destroy();
              return reject(new Error(`Invalid header from proxy CONNECT response: "${header}"`));
            }
            const key = header.slice(0, firstColon).toLowerCase();
            const value = header.slice(firstColon + 1).trimStart();
            const current = headers[key];
            if (typeof current === "string") {
              headers[key] = [current, value];
            } else if (Array.isArray(current)) {
              current.push(value);
            } else {
              headers[key] = value;
            }
          }
          debug("got proxy server response: %o %o", firstLine, headers);
          cleanup();
          resolve({
            connect: {
              statusCode,
              statusText,
              headers
            },
            buffered
          });
        }
        socket.on("error", onerror);
        socket.on("end", onend);
        read();
      });
    }
    exports2.parseProxyResponse = parseProxyResponse;
  }
});

// node_modules/https-proxy-agent/dist/index.js
var require_dist3 = __commonJS({
  "node_modules/https-proxy-agent/dist/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m2, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m2, k);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m2, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m2[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.HttpsProxyAgent = void 0;
    var net = __importStar(require("net"));
    var tls = __importStar(require("tls"));
    var assert_1 = __importDefault(require("assert"));
    var debug_1 = __importDefault(require_src());
    var agent_base_1 = require_dist2();
    var url_1 = require("url");
    var parse_proxy_response_1 = require_parse_proxy_response();
    var debug = (0, debug_1.default)("https-proxy-agent");
    var setServernameFromNonIpHost = (options) => {
      if (options.servername === void 0 && options.host && !net.isIP(options.host)) {
        return {
          ...options,
          servername: options.host
        };
      }
      return options;
    };
    var HttpsProxyAgent2 = class extends agent_base_1.Agent {
      constructor(proxy, opts) {
        super(opts);
        this.options = { path: void 0 };
        this.proxy = typeof proxy === "string" ? new url_1.URL(proxy) : proxy;
        this.proxyHeaders = opts?.headers ?? {};
        debug("Creating new HttpsProxyAgent instance: %o", this.proxy.href);
        const host = (this.proxy.hostname || this.proxy.host).replace(/^\[|\]$/g, "");
        const port = this.proxy.port ? parseInt(this.proxy.port, 10) : this.proxy.protocol === "https:" ? 443 : 80;
        this.connectOpts = {
          // Attempt to negotiate http/1.1 for proxy servers that support http/2
          ALPNProtocols: ["http/1.1"],
          ...opts ? omit(opts, "headers") : null,
          host,
          port
        };
      }
      /**
       * Called when the node-core HTTP client library is creating a
       * new HTTP request.
       */
      async connect(req, opts) {
        const { proxy } = this;
        if (!opts.host) {
          throw new TypeError('No "host" provided');
        }
        let socket;
        if (proxy.protocol === "https:") {
          debug("Creating `tls.Socket`: %o", this.connectOpts);
          socket = tls.connect(setServernameFromNonIpHost(this.connectOpts));
        } else {
          debug("Creating `net.Socket`: %o", this.connectOpts);
          socket = net.connect(this.connectOpts);
        }
        const headers = typeof this.proxyHeaders === "function" ? this.proxyHeaders() : { ...this.proxyHeaders };
        const host = net.isIPv6(opts.host) ? `[${opts.host}]` : opts.host;
        let payload = `CONNECT ${host}:${opts.port} HTTP/1.1\r
`;
        if (proxy.username || proxy.password) {
          const auth = `${decodeURIComponent(proxy.username)}:${decodeURIComponent(proxy.password)}`;
          headers["Proxy-Authorization"] = `Basic ${Buffer.from(auth).toString("base64")}`;
        }
        headers.Host = `${host}:${opts.port}`;
        if (!headers["Proxy-Connection"]) {
          headers["Proxy-Connection"] = this.keepAlive ? "Keep-Alive" : "close";
        }
        for (const name of Object.keys(headers)) {
          payload += `${name}: ${headers[name]}\r
`;
        }
        const proxyResponsePromise = (0, parse_proxy_response_1.parseProxyResponse)(socket);
        socket.write(`${payload}\r
`);
        const { connect, buffered } = await proxyResponsePromise;
        req.emit("proxyConnect", connect);
        this.emit("proxyConnect", connect, req);
        if (connect.statusCode === 200) {
          req.once("socket", resume);
          if (opts.secureEndpoint) {
            debug("Upgrading socket connection to TLS");
            return tls.connect({
              ...omit(setServernameFromNonIpHost(opts), "host", "path", "port"),
              socket
            });
          }
          return socket;
        }
        socket.destroy();
        const fakeSocket = new net.Socket({ writable: false });
        fakeSocket.readable = true;
        req.once("socket", (s2) => {
          debug("Replaying proxy buffer for failed request");
          (0, assert_1.default)(s2.listenerCount("data") > 0);
          s2.push(buffered);
          s2.push(null);
        });
        return fakeSocket;
      }
    };
    HttpsProxyAgent2.protocols = ["http", "https"];
    exports2.HttpsProxyAgent = HttpsProxyAgent2;
    function resume(socket) {
      socket.resume();
    }
    function omit(obj, ...keys) {
      const ret = {};
      let key;
      for (key in obj) {
        if (!keys.includes(key)) {
          ret[key] = obj[key];
        }
      }
      return ret;
    }
  }
});

// node_modules/smart-buffer/build/utils.js
var require_utils = __commonJS({
  "node_modules/smart-buffer/build/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var buffer_1 = require("buffer");
    var ERRORS = {
      INVALID_ENCODING: "Invalid encoding provided. Please specify a valid encoding the internal Node.js Buffer supports.",
      INVALID_SMARTBUFFER_SIZE: "Invalid size provided. Size must be a valid integer greater than zero.",
      INVALID_SMARTBUFFER_BUFFER: "Invalid Buffer provided in SmartBufferOptions.",
      INVALID_SMARTBUFFER_OBJECT: "Invalid SmartBufferOptions object supplied to SmartBuffer constructor or factory methods.",
      INVALID_OFFSET: "An invalid offset value was provided.",
      INVALID_OFFSET_NON_NUMBER: "An invalid offset value was provided. A numeric value is required.",
      INVALID_LENGTH: "An invalid length value was provided.",
      INVALID_LENGTH_NON_NUMBER: "An invalid length value was provived. A numeric value is required.",
      INVALID_TARGET_OFFSET: "Target offset is beyond the bounds of the internal SmartBuffer data.",
      INVALID_TARGET_LENGTH: "Specified length value moves cursor beyong the bounds of the internal SmartBuffer data.",
      INVALID_READ_BEYOND_BOUNDS: "Attempted to read beyond the bounds of the managed data.",
      INVALID_WRITE_BEYOND_BOUNDS: "Attempted to write beyond the bounds of the managed data."
    };
    exports2.ERRORS = ERRORS;
    function checkEncoding(encoding) {
      if (!buffer_1.Buffer.isEncoding(encoding)) {
        throw new Error(ERRORS.INVALID_ENCODING);
      }
    }
    exports2.checkEncoding = checkEncoding;
    function isFiniteInteger(value) {
      return typeof value === "number" && isFinite(value) && isInteger(value);
    }
    exports2.isFiniteInteger = isFiniteInteger;
    function checkOffsetOrLengthValue(value, offset) {
      if (typeof value === "number") {
        if (!isFiniteInteger(value) || value < 0) {
          throw new Error(offset ? ERRORS.INVALID_OFFSET : ERRORS.INVALID_LENGTH);
        }
      } else {
        throw new Error(offset ? ERRORS.INVALID_OFFSET_NON_NUMBER : ERRORS.INVALID_LENGTH_NON_NUMBER);
      }
    }
    function checkLengthValue(length) {
      checkOffsetOrLengthValue(length, false);
    }
    exports2.checkLengthValue = checkLengthValue;
    function checkOffsetValue(offset) {
      checkOffsetOrLengthValue(offset, true);
    }
    exports2.checkOffsetValue = checkOffsetValue;
    function checkTargetOffset(offset, buff) {
      if (offset < 0 || offset > buff.length) {
        throw new Error(ERRORS.INVALID_TARGET_OFFSET);
      }
    }
    exports2.checkTargetOffset = checkTargetOffset;
    function isInteger(value) {
      return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
    }
    function bigIntAndBufferInt64Check(bufferMethod) {
      if (typeof BigInt === "undefined") {
        throw new Error("Platform does not support JS BigInt type.");
      }
      if (typeof buffer_1.Buffer.prototype[bufferMethod] === "undefined") {
        throw new Error(`Platform does not support Buffer.prototype.${bufferMethod}.`);
      }
    }
    exports2.bigIntAndBufferInt64Check = bigIntAndBufferInt64Check;
  }
});

// node_modules/smart-buffer/build/smartbuffer.js
var require_smartbuffer = __commonJS({
  "node_modules/smart-buffer/build/smartbuffer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var utils_1 = require_utils();
    var DEFAULT_SMARTBUFFER_SIZE = 4096;
    var DEFAULT_SMARTBUFFER_ENCODING = "utf8";
    var SmartBuffer = class _SmartBuffer {
      /**
       * Creates a new SmartBuffer instance.
       *
       * @param options { SmartBufferOptions } The SmartBufferOptions to apply to this instance.
       */
      constructor(options) {
        this.length = 0;
        this._encoding = DEFAULT_SMARTBUFFER_ENCODING;
        this._writeOffset = 0;
        this._readOffset = 0;
        if (_SmartBuffer.isSmartBufferOptions(options)) {
          if (options.encoding) {
            utils_1.checkEncoding(options.encoding);
            this._encoding = options.encoding;
          }
          if (options.size) {
            if (utils_1.isFiniteInteger(options.size) && options.size > 0) {
              this._buff = Buffer.allocUnsafe(options.size);
            } else {
              throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_SIZE);
            }
          } else if (options.buff) {
            if (Buffer.isBuffer(options.buff)) {
              this._buff = options.buff;
              this.length = options.buff.length;
            } else {
              throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_BUFFER);
            }
          } else {
            this._buff = Buffer.allocUnsafe(DEFAULT_SMARTBUFFER_SIZE);
          }
        } else {
          if (typeof options !== "undefined") {
            throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_OBJECT);
          }
          this._buff = Buffer.allocUnsafe(DEFAULT_SMARTBUFFER_SIZE);
        }
      }
      /**
       * Creates a new SmartBuffer instance with the provided internal Buffer size and optional encoding.
       *
       * @param size { Number } The size of the internal Buffer.
       * @param encoding { String } The BufferEncoding to use for strings.
       *
       * @return { SmartBuffer }
       */
      static fromSize(size, encoding) {
        return new this({
          size,
          encoding
        });
      }
      /**
       * Creates a new SmartBuffer instance with the provided Buffer and optional encoding.
       *
       * @param buffer { Buffer } The Buffer to use as the internal Buffer value.
       * @param encoding { String } The BufferEncoding to use for strings.
       *
       * @return { SmartBuffer }
       */
      static fromBuffer(buff, encoding) {
        return new this({
          buff,
          encoding
        });
      }
      /**
       * Creates a new SmartBuffer instance with the provided SmartBufferOptions options.
       *
       * @param options { SmartBufferOptions } The options to use when creating the SmartBuffer instance.
       */
      static fromOptions(options) {
        return new this(options);
      }
      /**
       * Type checking function that determines if an object is a SmartBufferOptions object.
       */
      static isSmartBufferOptions(options) {
        const castOptions = options;
        return castOptions && (castOptions.encoding !== void 0 || castOptions.size !== void 0 || castOptions.buff !== void 0);
      }
      // Signed integers
      /**
       * Reads an Int8 value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { Number }
       */
      readInt8(offset) {
        return this._readNumberValue(Buffer.prototype.readInt8, 1, offset);
      }
      /**
       * Reads an Int16BE value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { Number }
       */
      readInt16BE(offset) {
        return this._readNumberValue(Buffer.prototype.readInt16BE, 2, offset);
      }
      /**
       * Reads an Int16LE value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { Number }
       */
      readInt16LE(offset) {
        return this._readNumberValue(Buffer.prototype.readInt16LE, 2, offset);
      }
      /**
       * Reads an Int32BE value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { Number }
       */
      readInt32BE(offset) {
        return this._readNumberValue(Buffer.prototype.readInt32BE, 4, offset);
      }
      /**
       * Reads an Int32LE value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { Number }
       */
      readInt32LE(offset) {
        return this._readNumberValue(Buffer.prototype.readInt32LE, 4, offset);
      }
      /**
       * Reads a BigInt64BE value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { BigInt }
       */
      readBigInt64BE(offset) {
        utils_1.bigIntAndBufferInt64Check("readBigInt64BE");
        return this._readNumberValue(Buffer.prototype.readBigInt64BE, 8, offset);
      }
      /**
       * Reads a BigInt64LE value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { BigInt }
       */
      readBigInt64LE(offset) {
        utils_1.bigIntAndBufferInt64Check("readBigInt64LE");
        return this._readNumberValue(Buffer.prototype.readBigInt64LE, 8, offset);
      }
      /**
       * Writes an Int8 value to the current write position (or at optional offset).
       *
       * @param value { Number } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeInt8(value, offset) {
        this._writeNumberValue(Buffer.prototype.writeInt8, 1, value, offset);
        return this;
      }
      /**
       * Inserts an Int8 value at the given offset value.
       *
       * @param value { Number } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertInt8(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeInt8, 1, value, offset);
      }
      /**
       * Writes an Int16BE value to the current write position (or at optional offset).
       *
       * @param value { Number } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeInt16BE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeInt16BE, 2, value, offset);
      }
      /**
       * Inserts an Int16BE value at the given offset value.
       *
       * @param value { Number } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertInt16BE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeInt16BE, 2, value, offset);
      }
      /**
       * Writes an Int16LE value to the current write position (or at optional offset).
       *
       * @param value { Number } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeInt16LE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeInt16LE, 2, value, offset);
      }
      /**
       * Inserts an Int16LE value at the given offset value.
       *
       * @param value { Number } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertInt16LE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeInt16LE, 2, value, offset);
      }
      /**
       * Writes an Int32BE value to the current write position (or at optional offset).
       *
       * @param value { Number } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeInt32BE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeInt32BE, 4, value, offset);
      }
      /**
       * Inserts an Int32BE value at the given offset value.
       *
       * @param value { Number } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertInt32BE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeInt32BE, 4, value, offset);
      }
      /**
       * Writes an Int32LE value to the current write position (or at optional offset).
       *
       * @param value { Number } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeInt32LE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeInt32LE, 4, value, offset);
      }
      /**
       * Inserts an Int32LE value at the given offset value.
       *
       * @param value { Number } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertInt32LE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeInt32LE, 4, value, offset);
      }
      /**
       * Writes a BigInt64BE value to the current write position (or at optional offset).
       *
       * @param value { BigInt } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeBigInt64BE(value, offset) {
        utils_1.bigIntAndBufferInt64Check("writeBigInt64BE");
        return this._writeNumberValue(Buffer.prototype.writeBigInt64BE, 8, value, offset);
      }
      /**
       * Inserts a BigInt64BE value at the given offset value.
       *
       * @param value { BigInt } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertBigInt64BE(value, offset) {
        utils_1.bigIntAndBufferInt64Check("writeBigInt64BE");
        return this._insertNumberValue(Buffer.prototype.writeBigInt64BE, 8, value, offset);
      }
      /**
       * Writes a BigInt64LE value to the current write position (or at optional offset).
       *
       * @param value { BigInt } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeBigInt64LE(value, offset) {
        utils_1.bigIntAndBufferInt64Check("writeBigInt64LE");
        return this._writeNumberValue(Buffer.prototype.writeBigInt64LE, 8, value, offset);
      }
      /**
       * Inserts a Int64LE value at the given offset value.
       *
       * @param value { BigInt } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertBigInt64LE(value, offset) {
        utils_1.bigIntAndBufferInt64Check("writeBigInt64LE");
        return this._insertNumberValue(Buffer.prototype.writeBigInt64LE, 8, value, offset);
      }
      // Unsigned Integers
      /**
       * Reads an UInt8 value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { Number }
       */
      readUInt8(offset) {
        return this._readNumberValue(Buffer.prototype.readUInt8, 1, offset);
      }
      /**
       * Reads an UInt16BE value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { Number }
       */
      readUInt16BE(offset) {
        return this._readNumberValue(Buffer.prototype.readUInt16BE, 2, offset);
      }
      /**
       * Reads an UInt16LE value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { Number }
       */
      readUInt16LE(offset) {
        return this._readNumberValue(Buffer.prototype.readUInt16LE, 2, offset);
      }
      /**
       * Reads an UInt32BE value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { Number }
       */
      readUInt32BE(offset) {
        return this._readNumberValue(Buffer.prototype.readUInt32BE, 4, offset);
      }
      /**
       * Reads an UInt32LE value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { Number }
       */
      readUInt32LE(offset) {
        return this._readNumberValue(Buffer.prototype.readUInt32LE, 4, offset);
      }
      /**
       * Reads a BigUInt64BE value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { BigInt }
       */
      readBigUInt64BE(offset) {
        utils_1.bigIntAndBufferInt64Check("readBigUInt64BE");
        return this._readNumberValue(Buffer.prototype.readBigUInt64BE, 8, offset);
      }
      /**
       * Reads a BigUInt64LE value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { BigInt }
       */
      readBigUInt64LE(offset) {
        utils_1.bigIntAndBufferInt64Check("readBigUInt64LE");
        return this._readNumberValue(Buffer.prototype.readBigUInt64LE, 8, offset);
      }
      /**
       * Writes an UInt8 value to the current write position (or at optional offset).
       *
       * @param value { Number } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeUInt8(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeUInt8, 1, value, offset);
      }
      /**
       * Inserts an UInt8 value at the given offset value.
       *
       * @param value { Number } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertUInt8(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeUInt8, 1, value, offset);
      }
      /**
       * Writes an UInt16BE value to the current write position (or at optional offset).
       *
       * @param value { Number } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeUInt16BE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeUInt16BE, 2, value, offset);
      }
      /**
       * Inserts an UInt16BE value at the given offset value.
       *
       * @param value { Number } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertUInt16BE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeUInt16BE, 2, value, offset);
      }
      /**
       * Writes an UInt16LE value to the current write position (or at optional offset).
       *
       * @param value { Number } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeUInt16LE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeUInt16LE, 2, value, offset);
      }
      /**
       * Inserts an UInt16LE value at the given offset value.
       *
       * @param value { Number } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertUInt16LE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeUInt16LE, 2, value, offset);
      }
      /**
       * Writes an UInt32BE value to the current write position (or at optional offset).
       *
       * @param value { Number } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeUInt32BE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeUInt32BE, 4, value, offset);
      }
      /**
       * Inserts an UInt32BE value at the given offset value.
       *
       * @param value { Number } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertUInt32BE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeUInt32BE, 4, value, offset);
      }
      /**
       * Writes an UInt32LE value to the current write position (or at optional offset).
       *
       * @param value { Number } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeUInt32LE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeUInt32LE, 4, value, offset);
      }
      /**
       * Inserts an UInt32LE value at the given offset value.
       *
       * @param value { Number } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertUInt32LE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeUInt32LE, 4, value, offset);
      }
      /**
       * Writes a BigUInt64BE value to the current write position (or at optional offset).
       *
       * @param value { Number } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeBigUInt64BE(value, offset) {
        utils_1.bigIntAndBufferInt64Check("writeBigUInt64BE");
        return this._writeNumberValue(Buffer.prototype.writeBigUInt64BE, 8, value, offset);
      }
      /**
       * Inserts a BigUInt64BE value at the given offset value.
       *
       * @param value { Number } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertBigUInt64BE(value, offset) {
        utils_1.bigIntAndBufferInt64Check("writeBigUInt64BE");
        return this._insertNumberValue(Buffer.prototype.writeBigUInt64BE, 8, value, offset);
      }
      /**
       * Writes a BigUInt64LE value to the current write position (or at optional offset).
       *
       * @param value { Number } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeBigUInt64LE(value, offset) {
        utils_1.bigIntAndBufferInt64Check("writeBigUInt64LE");
        return this._writeNumberValue(Buffer.prototype.writeBigUInt64LE, 8, value, offset);
      }
      /**
       * Inserts a BigUInt64LE value at the given offset value.
       *
       * @param value { Number } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertBigUInt64LE(value, offset) {
        utils_1.bigIntAndBufferInt64Check("writeBigUInt64LE");
        return this._insertNumberValue(Buffer.prototype.writeBigUInt64LE, 8, value, offset);
      }
      // Floating Point
      /**
       * Reads an FloatBE value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { Number }
       */
      readFloatBE(offset) {
        return this._readNumberValue(Buffer.prototype.readFloatBE, 4, offset);
      }
      /**
       * Reads an FloatLE value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { Number }
       */
      readFloatLE(offset) {
        return this._readNumberValue(Buffer.prototype.readFloatLE, 4, offset);
      }
      /**
       * Writes a FloatBE value to the current write position (or at optional offset).
       *
       * @param value { Number } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeFloatBE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeFloatBE, 4, value, offset);
      }
      /**
       * Inserts a FloatBE value at the given offset value.
       *
       * @param value { Number } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertFloatBE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeFloatBE, 4, value, offset);
      }
      /**
       * Writes a FloatLE value to the current write position (or at optional offset).
       *
       * @param value { Number } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeFloatLE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeFloatLE, 4, value, offset);
      }
      /**
       * Inserts a FloatLE value at the given offset value.
       *
       * @param value { Number } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertFloatLE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeFloatLE, 4, value, offset);
      }
      // Double Floating Point
      /**
       * Reads an DoublEBE value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { Number }
       */
      readDoubleBE(offset) {
        return this._readNumberValue(Buffer.prototype.readDoubleBE, 8, offset);
      }
      /**
       * Reads an DoubleLE value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { Number }
       */
      readDoubleLE(offset) {
        return this._readNumberValue(Buffer.prototype.readDoubleLE, 8, offset);
      }
      /**
       * Writes a DoubleBE value to the current write position (or at optional offset).
       *
       * @param value { Number } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeDoubleBE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeDoubleBE, 8, value, offset);
      }
      /**
       * Inserts a DoubleBE value at the given offset value.
       *
       * @param value { Number } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertDoubleBE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeDoubleBE, 8, value, offset);
      }
      /**
       * Writes a DoubleLE value to the current write position (or at optional offset).
       *
       * @param value { Number } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeDoubleLE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeDoubleLE, 8, value, offset);
      }
      /**
       * Inserts a DoubleLE value at the given offset value.
       *
       * @param value { Number } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertDoubleLE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeDoubleLE, 8, value, offset);
      }
      // Strings
      /**
       * Reads a String from the current read position.
       *
       * @param arg1 { Number | String } The number of bytes to read as a String, or the BufferEncoding to use for
       *             the string (Defaults to instance level encoding).
       * @param encoding { String } The BufferEncoding to use for the string (Defaults to instance level encoding).
       *
       * @return { String }
       */
      readString(arg1, encoding) {
        let lengthVal;
        if (typeof arg1 === "number") {
          utils_1.checkLengthValue(arg1);
          lengthVal = Math.min(arg1, this.length - this._readOffset);
        } else {
          encoding = arg1;
          lengthVal = this.length - this._readOffset;
        }
        if (typeof encoding !== "undefined") {
          utils_1.checkEncoding(encoding);
        }
        const value = this._buff.slice(this._readOffset, this._readOffset + lengthVal).toString(encoding || this._encoding);
        this._readOffset += lengthVal;
        return value;
      }
      /**
       * Inserts a String
       *
       * @param value { String } The String value to insert.
       * @param offset { Number } The offset to insert the string at.
       * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).
       *
       * @return this
       */
      insertString(value, offset, encoding) {
        utils_1.checkOffsetValue(offset);
        return this._handleString(value, true, offset, encoding);
      }
      /**
       * Writes a String
       *
       * @param value { String } The String value to write.
       * @param arg2 { Number | String } The offset to write the string at, or the BufferEncoding to use.
       * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).
       *
       * @return this
       */
      writeString(value, arg2, encoding) {
        return this._handleString(value, false, arg2, encoding);
      }
      /**
       * Reads a null-terminated String from the current read position.
       *
       * @param encoding { String } The BufferEncoding to use for the string (Defaults to instance level encoding).
       *
       * @return { String }
       */
      readStringNT(encoding) {
        if (typeof encoding !== "undefined") {
          utils_1.checkEncoding(encoding);
        }
        let nullPos = this.length;
        for (let i2 = this._readOffset; i2 < this.length; i2++) {
          if (this._buff[i2] === 0) {
            nullPos = i2;
            break;
          }
        }
        const value = this._buff.slice(this._readOffset, nullPos);
        this._readOffset = nullPos + 1;
        return value.toString(encoding || this._encoding);
      }
      /**
       * Inserts a null-terminated String.
       *
       * @param value { String } The String value to write.
       * @param arg2 { Number | String } The offset to write the string to, or the BufferEncoding to use.
       * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).
       *
       * @return this
       */
      insertStringNT(value, offset, encoding) {
        utils_1.checkOffsetValue(offset);
        this.insertString(value, offset, encoding);
        this.insertUInt8(0, offset + value.length);
        return this;
      }
      /**
       * Writes a null-terminated String.
       *
       * @param value { String } The String value to write.
       * @param arg2 { Number | String } The offset to write the string to, or the BufferEncoding to use.
       * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).
       *
       * @return this
       */
      writeStringNT(value, arg2, encoding) {
        this.writeString(value, arg2, encoding);
        this.writeUInt8(0, typeof arg2 === "number" ? arg2 + value.length : this.writeOffset);
        return this;
      }
      // Buffers
      /**
       * Reads a Buffer from the internal read position.
       *
       * @param length { Number } The length of data to read as a Buffer.
       *
       * @return { Buffer }
       */
      readBuffer(length) {
        if (typeof length !== "undefined") {
          utils_1.checkLengthValue(length);
        }
        const lengthVal = typeof length === "number" ? length : this.length;
        const endPoint = Math.min(this.length, this._readOffset + lengthVal);
        const value = this._buff.slice(this._readOffset, endPoint);
        this._readOffset = endPoint;
        return value;
      }
      /**
       * Writes a Buffer to the current write position.
       *
       * @param value { Buffer } The Buffer to write.
       * @param offset { Number } The offset to write the Buffer to.
       *
       * @return this
       */
      insertBuffer(value, offset) {
        utils_1.checkOffsetValue(offset);
        return this._handleBuffer(value, true, offset);
      }
      /**
       * Writes a Buffer to the current write position.
       *
       * @param value { Buffer } The Buffer to write.
       * @param offset { Number } The offset to write the Buffer to.
       *
       * @return this
       */
      writeBuffer(value, offset) {
        return this._handleBuffer(value, false, offset);
      }
      /**
       * Reads a null-terminated Buffer from the current read poisiton.
       *
       * @return { Buffer }
       */
      readBufferNT() {
        let nullPos = this.length;
        for (let i2 = this._readOffset; i2 < this.length; i2++) {
          if (this._buff[i2] === 0) {
            nullPos = i2;
            break;
          }
        }
        const value = this._buff.slice(this._readOffset, nullPos);
        this._readOffset = nullPos + 1;
        return value;
      }
      /**
       * Inserts a null-terminated Buffer.
       *
       * @param value { Buffer } The Buffer to write.
       * @param offset { Number } The offset to write the Buffer to.
       *
       * @return this
       */
      insertBufferNT(value, offset) {
        utils_1.checkOffsetValue(offset);
        this.insertBuffer(value, offset);
        this.insertUInt8(0, offset + value.length);
        return this;
      }
      /**
       * Writes a null-terminated Buffer.
       *
       * @param value { Buffer } The Buffer to write.
       * @param offset { Number } The offset to write the Buffer to.
       *
       * @return this
       */
      writeBufferNT(value, offset) {
        if (typeof offset !== "undefined") {
          utils_1.checkOffsetValue(offset);
        }
        this.writeBuffer(value, offset);
        this.writeUInt8(0, typeof offset === "number" ? offset + value.length : this._writeOffset);
        return this;
      }
      /**
       * Clears the SmartBuffer instance to its original empty state.
       */
      clear() {
        this._writeOffset = 0;
        this._readOffset = 0;
        this.length = 0;
        return this;
      }
      /**
       * Gets the remaining data left to be read from the SmartBuffer instance.
       *
       * @return { Number }
       */
      remaining() {
        return this.length - this._readOffset;
      }
      /**
       * Gets the current read offset value of the SmartBuffer instance.
       *
       * @return { Number }
       */
      get readOffset() {
        return this._readOffset;
      }
      /**
       * Sets the read offset value of the SmartBuffer instance.
       *
       * @param offset { Number } - The offset value to set.
       */
      set readOffset(offset) {
        utils_1.checkOffsetValue(offset);
        utils_1.checkTargetOffset(offset, this);
        this._readOffset = offset;
      }
      /**
       * Gets the current write offset value of the SmartBuffer instance.
       *
       * @return { Number }
       */
      get writeOffset() {
        return this._writeOffset;
      }
      /**
       * Sets the write offset value of the SmartBuffer instance.
       *
       * @param offset { Number } - The offset value to set.
       */
      set writeOffset(offset) {
        utils_1.checkOffsetValue(offset);
        utils_1.checkTargetOffset(offset, this);
        this._writeOffset = offset;
      }
      /**
       * Gets the currently set string encoding of the SmartBuffer instance.
       *
       * @return { BufferEncoding } The string Buffer encoding currently set.
       */
      get encoding() {
        return this._encoding;
      }
      /**
       * Sets the string encoding of the SmartBuffer instance.
       *
       * @param encoding { BufferEncoding } The string Buffer encoding to set.
       */
      set encoding(encoding) {
        utils_1.checkEncoding(encoding);
        this._encoding = encoding;
      }
      /**
       * Gets the underlying internal Buffer. (This includes unmanaged data in the Buffer)
       *
       * @return { Buffer } The Buffer value.
       */
      get internalBuffer() {
        return this._buff;
      }
      /**
       * Gets the value of the internal managed Buffer (Includes managed data only)
       *
       * @param { Buffer }
       */
      toBuffer() {
        return this._buff.slice(0, this.length);
      }
      /**
       * Gets the String value of the internal managed Buffer
       *
       * @param encoding { String } The BufferEncoding to display the Buffer as (defaults to instance level encoding).
       */
      toString(encoding) {
        const encodingVal = typeof encoding === "string" ? encoding : this._encoding;
        utils_1.checkEncoding(encodingVal);
        return this._buff.toString(encodingVal, 0, this.length);
      }
      /**
       * Destroys the SmartBuffer instance.
       */
      destroy() {
        this.clear();
        return this;
      }
      /**
       * Handles inserting and writing strings.
       *
       * @param value { String } The String value to insert.
       * @param isInsert { Boolean } True if inserting a string, false if writing.
       * @param arg2 { Number | String } The offset to insert the string at, or the BufferEncoding to use.
       * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).
       */
      _handleString(value, isInsert, arg3, encoding) {
        let offsetVal = this._writeOffset;
        let encodingVal = this._encoding;
        if (typeof arg3 === "number") {
          offsetVal = arg3;
        } else if (typeof arg3 === "string") {
          utils_1.checkEncoding(arg3);
          encodingVal = arg3;
        }
        if (typeof encoding === "string") {
          utils_1.checkEncoding(encoding);
          encodingVal = encoding;
        }
        const byteLength = Buffer.byteLength(value, encodingVal);
        if (isInsert) {
          this.ensureInsertable(byteLength, offsetVal);
        } else {
          this._ensureWriteable(byteLength, offsetVal);
        }
        this._buff.write(value, offsetVal, byteLength, encodingVal);
        if (isInsert) {
          this._writeOffset += byteLength;
        } else {
          if (typeof arg3 === "number") {
            this._writeOffset = Math.max(this._writeOffset, offsetVal + byteLength);
          } else {
            this._writeOffset += byteLength;
          }
        }
        return this;
      }
      /**
       * Handles writing or insert of a Buffer.
       *
       * @param value { Buffer } The Buffer to write.
       * @param offset { Number } The offset to write the Buffer to.
       */
      _handleBuffer(value, isInsert, offset) {
        const offsetVal = typeof offset === "number" ? offset : this._writeOffset;
        if (isInsert) {
          this.ensureInsertable(value.length, offsetVal);
        } else {
          this._ensureWriteable(value.length, offsetVal);
        }
        value.copy(this._buff, offsetVal);
        if (isInsert) {
          this._writeOffset += value.length;
        } else {
          if (typeof offset === "number") {
            this._writeOffset = Math.max(this._writeOffset, offsetVal + value.length);
          } else {
            this._writeOffset += value.length;
          }
        }
        return this;
      }
      /**
       * Ensures that the internal Buffer is large enough to read data.
       *
       * @param length { Number } The length of the data that needs to be read.
       * @param offset { Number } The offset of the data that needs to be read.
       */
      ensureReadable(length, offset) {
        let offsetVal = this._readOffset;
        if (typeof offset !== "undefined") {
          utils_1.checkOffsetValue(offset);
          offsetVal = offset;
        }
        if (offsetVal < 0 || offsetVal + length > this.length) {
          throw new Error(utils_1.ERRORS.INVALID_READ_BEYOND_BOUNDS);
        }
      }
      /**
       * Ensures that the internal Buffer is large enough to insert data.
       *
       * @param dataLength { Number } The length of the data that needs to be written.
       * @param offset { Number } The offset of the data to be written.
       */
      ensureInsertable(dataLength, offset) {
        utils_1.checkOffsetValue(offset);
        this._ensureCapacity(this.length + dataLength);
        if (offset < this.length) {
          this._buff.copy(this._buff, offset + dataLength, offset, this._buff.length);
        }
        if (offset + dataLength > this.length) {
          this.length = offset + dataLength;
        } else {
          this.length += dataLength;
        }
      }
      /**
       * Ensures that the internal Buffer is large enough to write data.
       *
       * @param dataLength { Number } The length of the data that needs to be written.
       * @param offset { Number } The offset of the data to be written (defaults to writeOffset).
       */
      _ensureWriteable(dataLength, offset) {
        const offsetVal = typeof offset === "number" ? offset : this._writeOffset;
        this._ensureCapacity(offsetVal + dataLength);
        if (offsetVal + dataLength > this.length) {
          this.length = offsetVal + dataLength;
        }
      }
      /**
       * Ensures that the internal Buffer is large enough to write at least the given amount of data.
       *
       * @param minLength { Number } The minimum length of the data needs to be written.
       */
      _ensureCapacity(minLength) {
        const oldLength = this._buff.length;
        if (minLength > oldLength) {
          let data = this._buff;
          let newLength = oldLength * 3 / 2 + 1;
          if (newLength < minLength) {
            newLength = minLength;
          }
          this._buff = Buffer.allocUnsafe(newLength);
          data.copy(this._buff, 0, 0, oldLength);
        }
      }
      /**
       * Reads a numeric number value using the provided function.
       *
       * @typeparam T { number | bigint } The type of the value to be read
       *
       * @param func { Function(offset: number) => number } The function to read data on the internal Buffer with.
       * @param byteSize { Number } The number of bytes read.
       * @param offset { Number } The offset to read from (optional). When this is not provided, the managed readOffset is used instead.
       *
       * @returns { T } the number value
       */
      _readNumberValue(func, byteSize, offset) {
        this.ensureReadable(byteSize, offset);
        const value = func.call(this._buff, typeof offset === "number" ? offset : this._readOffset);
        if (typeof offset === "undefined") {
          this._readOffset += byteSize;
        }
        return value;
      }
      /**
       * Inserts a numeric number value based on the given offset and value.
       *
       * @typeparam T { number | bigint } The type of the value to be written
       *
       * @param func { Function(offset: T, offset?) => number} The function to write data on the internal Buffer with.
       * @param byteSize { Number } The number of bytes written.
       * @param value { T } The number value to write.
       * @param offset { Number } the offset to write the number at (REQUIRED).
       *
       * @returns SmartBuffer this buffer
       */
      _insertNumberValue(func, byteSize, value, offset) {
        utils_1.checkOffsetValue(offset);
        this.ensureInsertable(byteSize, offset);
        func.call(this._buff, value, offset);
        this._writeOffset += byteSize;
        return this;
      }
      /**
       * Writes a numeric number value based on the given offset and value.
       *
       * @typeparam T { number | bigint } The type of the value to be written
       *
       * @param func { Function(offset: T, offset?) => number} The function to write data on the internal Buffer with.
       * @param byteSize { Number } The number of bytes written.
       * @param value { T } The number value to write.
       * @param offset { Number } the offset to write the number at (REQUIRED).
       *
       * @returns SmartBuffer this buffer
       */
      _writeNumberValue(func, byteSize, value, offset) {
        if (typeof offset === "number") {
          if (offset < 0) {
            throw new Error(utils_1.ERRORS.INVALID_WRITE_BEYOND_BOUNDS);
          }
          utils_1.checkOffsetValue(offset);
        }
        const offsetVal = typeof offset === "number" ? offset : this._writeOffset;
        this._ensureWriteable(byteSize, offsetVal);
        func.call(this._buff, value, offsetVal);
        if (typeof offset === "number") {
          this._writeOffset = Math.max(this._writeOffset, offsetVal + byteSize);
        } else {
          this._writeOffset += byteSize;
        }
        return this;
      }
    };
    exports2.SmartBuffer = SmartBuffer;
  }
});

// node_modules/socks/build/common/constants.js
var require_constants2 = __commonJS({
  "node_modules/socks/build/common/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SOCKS5_NO_ACCEPTABLE_AUTH = exports2.SOCKS5_CUSTOM_AUTH_END = exports2.SOCKS5_CUSTOM_AUTH_START = exports2.SOCKS_INCOMING_PACKET_SIZES = exports2.SocksClientState = exports2.Socks5Response = exports2.Socks5HostType = exports2.Socks5Auth = exports2.Socks4Response = exports2.SocksCommand = exports2.ERRORS = exports2.DEFAULT_TIMEOUT = void 0;
    var DEFAULT_TIMEOUT = 3e4;
    exports2.DEFAULT_TIMEOUT = DEFAULT_TIMEOUT;
    var ERRORS = {
      InvalidSocksCommand: "An invalid SOCKS command was provided. Valid options are connect, bind, and associate.",
      InvalidSocksCommandForOperation: "An invalid SOCKS command was provided. Only a subset of commands are supported for this operation.",
      InvalidSocksCommandChain: "An invalid SOCKS command was provided. Chaining currently only supports the connect command.",
      InvalidSocksClientOptionsDestination: "An invalid destination host was provided.",
      InvalidSocksClientOptionsExistingSocket: "An invalid existing socket was provided. This should be an instance of stream.Duplex.",
      InvalidSocksClientOptionsProxy: "Invalid SOCKS proxy details were provided.",
      InvalidSocksClientOptionsTimeout: "An invalid timeout value was provided. Please enter a value above 0 (in ms).",
      InvalidSocksClientOptionsProxiesLength: "At least two socks proxies must be provided for chaining.",
      InvalidSocksClientOptionsCustomAuthRange: "Custom auth must be a value between 0x80 and 0xFE.",
      InvalidSocksClientOptionsCustomAuthOptions: "When a custom_auth_method is provided, custom_auth_request_handler, custom_auth_response_size, and custom_auth_response_handler must also be provided and valid.",
      NegotiationError: "Negotiation error",
      SocketClosed: "Socket closed",
      ProxyConnectionTimedOut: "Proxy connection timed out",
      InternalError: "SocksClient internal error (this should not happen)",
      InvalidSocks4HandshakeResponse: "Received invalid Socks4 handshake response",
      Socks4ProxyRejectedConnection: "Socks4 Proxy rejected connection",
      InvalidSocks4IncomingConnectionResponse: "Socks4 invalid incoming connection response",
      Socks4ProxyRejectedIncomingBoundConnection: "Socks4 Proxy rejected incoming bound connection",
      InvalidSocks5InitialHandshakeResponse: "Received invalid Socks5 initial handshake response",
      InvalidSocks5IntiailHandshakeSocksVersion: "Received invalid Socks5 initial handshake (invalid socks version)",
      InvalidSocks5InitialHandshakeNoAcceptedAuthType: "Received invalid Socks5 initial handshake (no accepted authentication type)",
      InvalidSocks5InitialHandshakeUnknownAuthType: "Received invalid Socks5 initial handshake (unknown authentication type)",
      Socks5AuthenticationFailed: "Socks5 Authentication failed",
      InvalidSocks5FinalHandshake: "Received invalid Socks5 final handshake response",
      InvalidSocks5FinalHandshakeRejected: "Socks5 proxy rejected connection",
      InvalidSocks5IncomingConnectionResponse: "Received invalid Socks5 incoming connection response",
      Socks5ProxyRejectedIncomingBoundConnection: "Socks5 Proxy rejected incoming bound connection"
    };
    exports2.ERRORS = ERRORS;
    var SOCKS_INCOMING_PACKET_SIZES = {
      Socks5InitialHandshakeResponse: 2,
      Socks5UserPassAuthenticationResponse: 2,
      // Command response + incoming connection (bind)
      Socks5ResponseHeader: 5,
      // We need at least 5 to read the hostname length, then we wait for the address+port information.
      Socks5ResponseIPv4: 10,
      // 4 header + 4 ip + 2 port
      Socks5ResponseIPv6: 22,
      // 4 header + 16 ip + 2 port
      Socks5ResponseHostname: (hostNameLength) => hostNameLength + 7,
      // 4 header + 1 host length + host + 2 port
      // Command response + incoming connection (bind)
      Socks4Response: 8
      // 2 header + 2 port + 4 ip
    };
    exports2.SOCKS_INCOMING_PACKET_SIZES = SOCKS_INCOMING_PACKET_SIZES;
    var SocksCommand;
    (function(SocksCommand2) {
      SocksCommand2[SocksCommand2["connect"] = 1] = "connect";
      SocksCommand2[SocksCommand2["bind"] = 2] = "bind";
      SocksCommand2[SocksCommand2["associate"] = 3] = "associate";
    })(SocksCommand || (exports2.SocksCommand = SocksCommand = {}));
    var Socks4Response;
    (function(Socks4Response2) {
      Socks4Response2[Socks4Response2["Granted"] = 90] = "Granted";
      Socks4Response2[Socks4Response2["Failed"] = 91] = "Failed";
      Socks4Response2[Socks4Response2["Rejected"] = 92] = "Rejected";
      Socks4Response2[Socks4Response2["RejectedIdent"] = 93] = "RejectedIdent";
    })(Socks4Response || (exports2.Socks4Response = Socks4Response = {}));
    var Socks5Auth;
    (function(Socks5Auth2) {
      Socks5Auth2[Socks5Auth2["NoAuth"] = 0] = "NoAuth";
      Socks5Auth2[Socks5Auth2["GSSApi"] = 1] = "GSSApi";
      Socks5Auth2[Socks5Auth2["UserPass"] = 2] = "UserPass";
    })(Socks5Auth || (exports2.Socks5Auth = Socks5Auth = {}));
    var SOCKS5_CUSTOM_AUTH_START = 128;
    exports2.SOCKS5_CUSTOM_AUTH_START = SOCKS5_CUSTOM_AUTH_START;
    var SOCKS5_CUSTOM_AUTH_END = 254;
    exports2.SOCKS5_CUSTOM_AUTH_END = SOCKS5_CUSTOM_AUTH_END;
    var SOCKS5_NO_ACCEPTABLE_AUTH = 255;
    exports2.SOCKS5_NO_ACCEPTABLE_AUTH = SOCKS5_NO_ACCEPTABLE_AUTH;
    var Socks5Response;
    (function(Socks5Response2) {
      Socks5Response2[Socks5Response2["Granted"] = 0] = "Granted";
      Socks5Response2[Socks5Response2["Failure"] = 1] = "Failure";
      Socks5Response2[Socks5Response2["NotAllowed"] = 2] = "NotAllowed";
      Socks5Response2[Socks5Response2["NetworkUnreachable"] = 3] = "NetworkUnreachable";
      Socks5Response2[Socks5Response2["HostUnreachable"] = 4] = "HostUnreachable";
      Socks5Response2[Socks5Response2["ConnectionRefused"] = 5] = "ConnectionRefused";
      Socks5Response2[Socks5Response2["TTLExpired"] = 6] = "TTLExpired";
      Socks5Response2[Socks5Response2["CommandNotSupported"] = 7] = "CommandNotSupported";
      Socks5Response2[Socks5Response2["AddressNotSupported"] = 8] = "AddressNotSupported";
    })(Socks5Response || (exports2.Socks5Response = Socks5Response = {}));
    var Socks5HostType;
    (function(Socks5HostType2) {
      Socks5HostType2[Socks5HostType2["IPv4"] = 1] = "IPv4";
      Socks5HostType2[Socks5HostType2["Hostname"] = 3] = "Hostname";
      Socks5HostType2[Socks5HostType2["IPv6"] = 4] = "IPv6";
    })(Socks5HostType || (exports2.Socks5HostType = Socks5HostType = {}));
    var SocksClientState;
    (function(SocksClientState2) {
      SocksClientState2[SocksClientState2["Created"] = 0] = "Created";
      SocksClientState2[SocksClientState2["Connecting"] = 1] = "Connecting";
      SocksClientState2[SocksClientState2["Connected"] = 2] = "Connected";
      SocksClientState2[SocksClientState2["SentInitialHandshake"] = 3] = "SentInitialHandshake";
      SocksClientState2[SocksClientState2["ReceivedInitialHandshakeResponse"] = 4] = "ReceivedInitialHandshakeResponse";
      SocksClientState2[SocksClientState2["SentAuthentication"] = 5] = "SentAuthentication";
      SocksClientState2[SocksClientState2["ReceivedAuthenticationResponse"] = 6] = "ReceivedAuthenticationResponse";
      SocksClientState2[SocksClientState2["SentFinalHandshake"] = 7] = "SentFinalHandshake";
      SocksClientState2[SocksClientState2["ReceivedFinalResponse"] = 8] = "ReceivedFinalResponse";
      SocksClientState2[SocksClientState2["BoundWaitingForConnection"] = 9] = "BoundWaitingForConnection";
      SocksClientState2[SocksClientState2["Established"] = 10] = "Established";
      SocksClientState2[SocksClientState2["Disconnected"] = 11] = "Disconnected";
      SocksClientState2[SocksClientState2["Error"] = 99] = "Error";
    })(SocksClientState || (exports2.SocksClientState = SocksClientState = {}));
  }
});

// node_modules/socks/build/common/util.js
var require_util = __commonJS({
  "node_modules/socks/build/common/util.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.shuffleArray = exports2.SocksClientError = void 0;
    var SocksClientError = class extends Error {
      constructor(message, options) {
        super(message);
        this.options = options;
      }
    };
    exports2.SocksClientError = SocksClientError;
    function shuffleArray(array) {
      for (let i2 = array.length - 1; i2 > 0; i2--) {
        const j = Math.floor(Math.random() * (i2 + 1));
        [array[i2], array[j]] = [array[j], array[i2]];
      }
    }
    exports2.shuffleArray = shuffleArray;
  }
});

// node_modules/ip-address/dist/common.js
var require_common2 = __commonJS({
  "node_modules/ip-address/dist/common.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isCorrect = exports2.isInSubnet = void 0;
    function isInSubnet(address) {
      if (this.subnetMask < address.subnetMask) {
        return false;
      }
      if (this.mask(address.subnetMask) === address.mask()) {
        return true;
      }
      return false;
    }
    exports2.isInSubnet = isInSubnet;
    function isCorrect(defaultBits) {
      return function() {
        if (this.addressMinusSuffix !== this.correctForm()) {
          return false;
        }
        if (this.subnetMask === defaultBits && !this.parsedSubnet) {
          return true;
        }
        return this.parsedSubnet === String(this.subnetMask);
      };
    }
    exports2.isCorrect = isCorrect;
  }
});

// node_modules/ip-address/dist/v4/constants.js
var require_constants3 = __commonJS({
  "node_modules/ip-address/dist/v4/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RE_SUBNET_STRING = exports2.RE_ADDRESS = exports2.GROUPS = exports2.BITS = void 0;
    exports2.BITS = 32;
    exports2.GROUPS = 4;
    exports2.RE_ADDRESS = /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/g;
    exports2.RE_SUBNET_STRING = /\/\d{1,2}$/;
  }
});

// node_modules/ip-address/dist/address-error.js
var require_address_error = __commonJS({
  "node_modules/ip-address/dist/address-error.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AddressError = void 0;
    var AddressError = class extends Error {
      constructor(message, parseMessage) {
        super(message);
        this.name = "AddressError";
        if (parseMessage !== null) {
          this.parseMessage = parseMessage;
        }
      }
    };
    exports2.AddressError = AddressError;
  }
});

// node_modules/jsbn/index.js
var require_jsbn = __commonJS({
  "node_modules/jsbn/index.js"(exports2, module2) {
    (function() {
      var dbits;
      var canary = 244837814094590;
      var j_lm = (canary & 16777215) == 15715070;
      function BigInteger(a, b, c) {
        if (a != null)
          if ("number" == typeof a) this.fromNumber(a, b, c);
          else if (b == null && "string" != typeof a) this.fromString(a, 256);
          else this.fromString(a, b);
      }
      function nbi() {
        return new BigInteger(null);
      }
      function am1(i2, x2, w, j, c, n) {
        while (--n >= 0) {
          var v = x2 * this[i2++] + w[j] + c;
          c = Math.floor(v / 67108864);
          w[j++] = v & 67108863;
        }
        return c;
      }
      function am2(i2, x2, w, j, c, n) {
        var xl = x2 & 32767, xh = x2 >> 15;
        while (--n >= 0) {
          var l = this[i2] & 32767;
          var h2 = this[i2++] >> 15;
          var m2 = xh * l + h2 * xl;
          l = xl * l + ((m2 & 32767) << 15) + w[j] + (c & 1073741823);
          c = (l >>> 30) + (m2 >>> 15) + xh * h2 + (c >>> 30);
          w[j++] = l & 1073741823;
        }
        return c;
      }
      function am3(i2, x2, w, j, c, n) {
        var xl = x2 & 16383, xh = x2 >> 14;
        while (--n >= 0) {
          var l = this[i2] & 16383;
          var h2 = this[i2++] >> 14;
          var m2 = xh * l + h2 * xl;
          l = xl * l + ((m2 & 16383) << 14) + w[j] + c;
          c = (l >> 28) + (m2 >> 14) + xh * h2;
          w[j++] = l & 268435455;
        }
        return c;
      }
      var inBrowser = typeof navigator !== "undefined";
      if (inBrowser && j_lm && navigator.appName == "Microsoft Internet Explorer") {
        BigInteger.prototype.am = am2;
        dbits = 30;
      } else if (inBrowser && j_lm && navigator.appName != "Netscape") {
        BigInteger.prototype.am = am1;
        dbits = 26;
      } else {
        BigInteger.prototype.am = am3;
        dbits = 28;
      }
      BigInteger.prototype.DB = dbits;
      BigInteger.prototype.DM = (1 << dbits) - 1;
      BigInteger.prototype.DV = 1 << dbits;
      var BI_FP = 52;
      BigInteger.prototype.FV = Math.pow(2, BI_FP);
      BigInteger.prototype.F1 = BI_FP - dbits;
      BigInteger.prototype.F2 = 2 * dbits - BI_FP;
      var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
      var BI_RC = new Array();
      var rr, vv;
      rr = "0".charCodeAt(0);
      for (vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;
      rr = "a".charCodeAt(0);
      for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
      rr = "A".charCodeAt(0);
      for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
      function int2char(n) {
        return BI_RM.charAt(n);
      }
      function intAt(s2, i2) {
        var c = BI_RC[s2.charCodeAt(i2)];
        return c == null ? -1 : c;
      }
      function bnpCopyTo(r2) {
        for (var i2 = this.t - 1; i2 >= 0; --i2) r2[i2] = this[i2];
        r2.t = this.t;
        r2.s = this.s;
      }
      function bnpFromInt(x2) {
        this.t = 1;
        this.s = x2 < 0 ? -1 : 0;
        if (x2 > 0) this[0] = x2;
        else if (x2 < -1) this[0] = x2 + this.DV;
        else this.t = 0;
      }
      function nbv(i2) {
        var r2 = nbi();
        r2.fromInt(i2);
        return r2;
      }
      function bnpFromString(s2, b) {
        var k;
        if (b == 16) k = 4;
        else if (b == 8) k = 3;
        else if (b == 256) k = 8;
        else if (b == 2) k = 1;
        else if (b == 32) k = 5;
        else if (b == 4) k = 2;
        else {
          this.fromRadix(s2, b);
          return;
        }
        this.t = 0;
        this.s = 0;
        var i2 = s2.length, mi = false, sh = 0;
        while (--i2 >= 0) {
          var x2 = k == 8 ? s2[i2] & 255 : intAt(s2, i2);
          if (x2 < 0) {
            if (s2.charAt(i2) == "-") mi = true;
            continue;
          }
          mi = false;
          if (sh == 0)
            this[this.t++] = x2;
          else if (sh + k > this.DB) {
            this[this.t - 1] |= (x2 & (1 << this.DB - sh) - 1) << sh;
            this[this.t++] = x2 >> this.DB - sh;
          } else
            this[this.t - 1] |= x2 << sh;
          sh += k;
          if (sh >= this.DB) sh -= this.DB;
        }
        if (k == 8 && (s2[0] & 128) != 0) {
          this.s = -1;
          if (sh > 0) this[this.t - 1] |= (1 << this.DB - sh) - 1 << sh;
        }
        this.clamp();
        if (mi) BigInteger.ZERO.subTo(this, this);
      }
      function bnpClamp() {
        var c = this.s & this.DM;
        while (this.t > 0 && this[this.t - 1] == c) --this.t;
      }
      function bnToString(b) {
        if (this.s < 0) return "-" + this.negate().toString(b);
        var k;
        if (b == 16) k = 4;
        else if (b == 8) k = 3;
        else if (b == 2) k = 1;
        else if (b == 32) k = 5;
        else if (b == 4) k = 2;
        else return this.toRadix(b);
        var km = (1 << k) - 1, d, m2 = false, r2 = "", i2 = this.t;
        var p = this.DB - i2 * this.DB % k;
        if (i2-- > 0) {
          if (p < this.DB && (d = this[i2] >> p) > 0) {
            m2 = true;
            r2 = int2char(d);
          }
          while (i2 >= 0) {
            if (p < k) {
              d = (this[i2] & (1 << p) - 1) << k - p;
              d |= this[--i2] >> (p += this.DB - k);
            } else {
              d = this[i2] >> (p -= k) & km;
              if (p <= 0) {
                p += this.DB;
                --i2;
              }
            }
            if (d > 0) m2 = true;
            if (m2) r2 += int2char(d);
          }
        }
        return m2 ? r2 : "0";
      }
      function bnNegate() {
        var r2 = nbi();
        BigInteger.ZERO.subTo(this, r2);
        return r2;
      }
      function bnAbs() {
        return this.s < 0 ? this.negate() : this;
      }
      function bnCompareTo(a) {
        var r2 = this.s - a.s;
        if (r2 != 0) return r2;
        var i2 = this.t;
        r2 = i2 - a.t;
        if (r2 != 0) return this.s < 0 ? -r2 : r2;
        while (--i2 >= 0) if ((r2 = this[i2] - a[i2]) != 0) return r2;
        return 0;
      }
      function nbits(x2) {
        var r2 = 1, t3;
        if ((t3 = x2 >>> 16) != 0) {
          x2 = t3;
          r2 += 16;
        }
        if ((t3 = x2 >> 8) != 0) {
          x2 = t3;
          r2 += 8;
        }
        if ((t3 = x2 >> 4) != 0) {
          x2 = t3;
          r2 += 4;
        }
        if ((t3 = x2 >> 2) != 0) {
          x2 = t3;
          r2 += 2;
        }
        if ((t3 = x2 >> 1) != 0) {
          x2 = t3;
          r2 += 1;
        }
        return r2;
      }
      function bnBitLength() {
        if (this.t <= 0) return 0;
        return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ this.s & this.DM);
      }
      function bnpDLShiftTo(n, r2) {
        var i2;
        for (i2 = this.t - 1; i2 >= 0; --i2) r2[i2 + n] = this[i2];
        for (i2 = n - 1; i2 >= 0; --i2) r2[i2] = 0;
        r2.t = this.t + n;
        r2.s = this.s;
      }
      function bnpDRShiftTo(n, r2) {
        for (var i2 = n; i2 < this.t; ++i2) r2[i2 - n] = this[i2];
        r2.t = Math.max(this.t - n, 0);
        r2.s = this.s;
      }
      function bnpLShiftTo(n, r2) {
        var bs = n % this.DB;
        var cbs = this.DB - bs;
        var bm = (1 << cbs) - 1;
        var ds = Math.floor(n / this.DB), c = this.s << bs & this.DM, i2;
        for (i2 = this.t - 1; i2 >= 0; --i2) {
          r2[i2 + ds + 1] = this[i2] >> cbs | c;
          c = (this[i2] & bm) << bs;
        }
        for (i2 = ds - 1; i2 >= 0; --i2) r2[i2] = 0;
        r2[ds] = c;
        r2.t = this.t + ds + 1;
        r2.s = this.s;
        r2.clamp();
      }
      function bnpRShiftTo(n, r2) {
        r2.s = this.s;
        var ds = Math.floor(n / this.DB);
        if (ds >= this.t) {
          r2.t = 0;
          return;
        }
        var bs = n % this.DB;
        var cbs = this.DB - bs;
        var bm = (1 << bs) - 1;
        r2[0] = this[ds] >> bs;
        for (var i2 = ds + 1; i2 < this.t; ++i2) {
          r2[i2 - ds - 1] |= (this[i2] & bm) << cbs;
          r2[i2 - ds] = this[i2] >> bs;
        }
        if (bs > 0) r2[this.t - ds - 1] |= (this.s & bm) << cbs;
        r2.t = this.t - ds;
        r2.clamp();
      }
      function bnpSubTo(a, r2) {
        var i2 = 0, c = 0, m2 = Math.min(a.t, this.t);
        while (i2 < m2) {
          c += this[i2] - a[i2];
          r2[i2++] = c & this.DM;
          c >>= this.DB;
        }
        if (a.t < this.t) {
          c -= a.s;
          while (i2 < this.t) {
            c += this[i2];
            r2[i2++] = c & this.DM;
            c >>= this.DB;
          }
          c += this.s;
        } else {
          c += this.s;
          while (i2 < a.t) {
            c -= a[i2];
            r2[i2++] = c & this.DM;
            c >>= this.DB;
          }
          c -= a.s;
        }
        r2.s = c < 0 ? -1 : 0;
        if (c < -1) r2[i2++] = this.DV + c;
        else if (c > 0) r2[i2++] = c;
        r2.t = i2;
        r2.clamp();
      }
      function bnpMultiplyTo(a, r2) {
        var x2 = this.abs(), y = a.abs();
        var i2 = x2.t;
        r2.t = i2 + y.t;
        while (--i2 >= 0) r2[i2] = 0;
        for (i2 = 0; i2 < y.t; ++i2) r2[i2 + x2.t] = x2.am(0, y[i2], r2, i2, 0, x2.t);
        r2.s = 0;
        r2.clamp();
        if (this.s != a.s) BigInteger.ZERO.subTo(r2, r2);
      }
      function bnpSquareTo(r2) {
        var x2 = this.abs();
        var i2 = r2.t = 2 * x2.t;
        while (--i2 >= 0) r2[i2] = 0;
        for (i2 = 0; i2 < x2.t - 1; ++i2) {
          var c = x2.am(i2, x2[i2], r2, 2 * i2, 0, 1);
          if ((r2[i2 + x2.t] += x2.am(i2 + 1, 2 * x2[i2], r2, 2 * i2 + 1, c, x2.t - i2 - 1)) >= x2.DV) {
            r2[i2 + x2.t] -= x2.DV;
            r2[i2 + x2.t + 1] = 1;
          }
        }
        if (r2.t > 0) r2[r2.t - 1] += x2.am(i2, x2[i2], r2, 2 * i2, 0, 1);
        r2.s = 0;
        r2.clamp();
      }
      function bnpDivRemTo(m2, q, r2) {
        var pm = m2.abs();
        if (pm.t <= 0) return;
        var pt = this.abs();
        if (pt.t < pm.t) {
          if (q != null) q.fromInt(0);
          if (r2 != null) this.copyTo(r2);
          return;
        }
        if (r2 == null) r2 = nbi();
        var y = nbi(), ts = this.s, ms = m2.s;
        var nsh = this.DB - nbits(pm[pm.t - 1]);
        if (nsh > 0) {
          pm.lShiftTo(nsh, y);
          pt.lShiftTo(nsh, r2);
        } else {
          pm.copyTo(y);
          pt.copyTo(r2);
        }
        var ys = y.t;
        var y0 = y[ys - 1];
        if (y0 == 0) return;
        var yt = y0 * (1 << this.F1) + (ys > 1 ? y[ys - 2] >> this.F2 : 0);
        var d1 = this.FV / yt, d2 = (1 << this.F1) / yt, e2 = 1 << this.F2;
        var i2 = r2.t, j = i2 - ys, t3 = q == null ? nbi() : q;
        y.dlShiftTo(j, t3);
        if (r2.compareTo(t3) >= 0) {
          r2[r2.t++] = 1;
          r2.subTo(t3, r2);
        }
        BigInteger.ONE.dlShiftTo(ys, t3);
        t3.subTo(y, y);
        while (y.t < ys) y[y.t++] = 0;
        while (--j >= 0) {
          var qd = r2[--i2] == y0 ? this.DM : Math.floor(r2[i2] * d1 + (r2[i2 - 1] + e2) * d2);
          if ((r2[i2] += y.am(0, qd, r2, j, 0, ys)) < qd) {
            y.dlShiftTo(j, t3);
            r2.subTo(t3, r2);
            while (r2[i2] < --qd) r2.subTo(t3, r2);
          }
        }
        if (q != null) {
          r2.drShiftTo(ys, q);
          if (ts != ms) BigInteger.ZERO.subTo(q, q);
        }
        r2.t = ys;
        r2.clamp();
        if (nsh > 0) r2.rShiftTo(nsh, r2);
        if (ts < 0) BigInteger.ZERO.subTo(r2, r2);
      }
      function bnMod(a) {
        var r2 = nbi();
        this.abs().divRemTo(a, null, r2);
        if (this.s < 0 && r2.compareTo(BigInteger.ZERO) > 0) a.subTo(r2, r2);
        return r2;
      }
      function Classic(m2) {
        this.m = m2;
      }
      function cConvert(x2) {
        if (x2.s < 0 || x2.compareTo(this.m) >= 0) return x2.mod(this.m);
        else return x2;
      }
      function cRevert(x2) {
        return x2;
      }
      function cReduce(x2) {
        x2.divRemTo(this.m, null, x2);
      }
      function cMulTo(x2, y, r2) {
        x2.multiplyTo(y, r2);
        this.reduce(r2);
      }
      function cSqrTo(x2, r2) {
        x2.squareTo(r2);
        this.reduce(r2);
      }
      Classic.prototype.convert = cConvert;
      Classic.prototype.revert = cRevert;
      Classic.prototype.reduce = cReduce;
      Classic.prototype.mulTo = cMulTo;
      Classic.prototype.sqrTo = cSqrTo;
      function bnpInvDigit() {
        if (this.t < 1) return 0;
        var x2 = this[0];
        if ((x2 & 1) == 0) return 0;
        var y = x2 & 3;
        y = y * (2 - (x2 & 15) * y) & 15;
        y = y * (2 - (x2 & 255) * y) & 255;
        y = y * (2 - ((x2 & 65535) * y & 65535)) & 65535;
        y = y * (2 - x2 * y % this.DV) % this.DV;
        return y > 0 ? this.DV - y : -y;
      }
      function Montgomery(m2) {
        this.m = m2;
        this.mp = m2.invDigit();
        this.mpl = this.mp & 32767;
        this.mph = this.mp >> 15;
        this.um = (1 << m2.DB - 15) - 1;
        this.mt2 = 2 * m2.t;
      }
      function montConvert(x2) {
        var r2 = nbi();
        x2.abs().dlShiftTo(this.m.t, r2);
        r2.divRemTo(this.m, null, r2);
        if (x2.s < 0 && r2.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r2, r2);
        return r2;
      }
      function montRevert(x2) {
        var r2 = nbi();
        x2.copyTo(r2);
        this.reduce(r2);
        return r2;
      }
      function montReduce(x2) {
        while (x2.t <= this.mt2)
          x2[x2.t++] = 0;
        for (var i2 = 0; i2 < this.m.t; ++i2) {
          var j = x2[i2] & 32767;
          var u0 = j * this.mpl + ((j * this.mph + (x2[i2] >> 15) * this.mpl & this.um) << 15) & x2.DM;
          j = i2 + this.m.t;
          x2[j] += this.m.am(0, u0, x2, i2, 0, this.m.t);
          while (x2[j] >= x2.DV) {
            x2[j] -= x2.DV;
            x2[++j]++;
          }
        }
        x2.clamp();
        x2.drShiftTo(this.m.t, x2);
        if (x2.compareTo(this.m) >= 0) x2.subTo(this.m, x2);
      }
      function montSqrTo(x2, r2) {
        x2.squareTo(r2);
        this.reduce(r2);
      }
      function montMulTo(x2, y, r2) {
        x2.multiplyTo(y, r2);
        this.reduce(r2);
      }
      Montgomery.prototype.convert = montConvert;
      Montgomery.prototype.revert = montRevert;
      Montgomery.prototype.reduce = montReduce;
      Montgomery.prototype.mulTo = montMulTo;
      Montgomery.prototype.sqrTo = montSqrTo;
      function bnpIsEven() {
        return (this.t > 0 ? this[0] & 1 : this.s) == 0;
      }
      function bnpExp(e2, z2) {
        if (e2 > 4294967295 || e2 < 1) return BigInteger.ONE;
        var r2 = nbi(), r22 = nbi(), g = z2.convert(this), i2 = nbits(e2) - 1;
        g.copyTo(r2);
        while (--i2 >= 0) {
          z2.sqrTo(r2, r22);
          if ((e2 & 1 << i2) > 0) z2.mulTo(r22, g, r2);
          else {
            var t3 = r2;
            r2 = r22;
            r22 = t3;
          }
        }
        return z2.revert(r2);
      }
      function bnModPowInt(e2, m2) {
        var z2;
        if (e2 < 256 || m2.isEven()) z2 = new Classic(m2);
        else z2 = new Montgomery(m2);
        return this.exp(e2, z2);
      }
      BigInteger.prototype.copyTo = bnpCopyTo;
      BigInteger.prototype.fromInt = bnpFromInt;
      BigInteger.prototype.fromString = bnpFromString;
      BigInteger.prototype.clamp = bnpClamp;
      BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
      BigInteger.prototype.drShiftTo = bnpDRShiftTo;
      BigInteger.prototype.lShiftTo = bnpLShiftTo;
      BigInteger.prototype.rShiftTo = bnpRShiftTo;
      BigInteger.prototype.subTo = bnpSubTo;
      BigInteger.prototype.multiplyTo = bnpMultiplyTo;
      BigInteger.prototype.squareTo = bnpSquareTo;
      BigInteger.prototype.divRemTo = bnpDivRemTo;
      BigInteger.prototype.invDigit = bnpInvDigit;
      BigInteger.prototype.isEven = bnpIsEven;
      BigInteger.prototype.exp = bnpExp;
      BigInteger.prototype.toString = bnToString;
      BigInteger.prototype.negate = bnNegate;
      BigInteger.prototype.abs = bnAbs;
      BigInteger.prototype.compareTo = bnCompareTo;
      BigInteger.prototype.bitLength = bnBitLength;
      BigInteger.prototype.mod = bnMod;
      BigInteger.prototype.modPowInt = bnModPowInt;
      BigInteger.ZERO = nbv(0);
      BigInteger.ONE = nbv(1);
      function bnClone() {
        var r2 = nbi();
        this.copyTo(r2);
        return r2;
      }
      function bnIntValue() {
        if (this.s < 0) {
          if (this.t == 1) return this[0] - this.DV;
          else if (this.t == 0) return -1;
        } else if (this.t == 1) return this[0];
        else if (this.t == 0) return 0;
        return (this[1] & (1 << 32 - this.DB) - 1) << this.DB | this[0];
      }
      function bnByteValue() {
        return this.t == 0 ? this.s : this[0] << 24 >> 24;
      }
      function bnShortValue() {
        return this.t == 0 ? this.s : this[0] << 16 >> 16;
      }
      function bnpChunkSize(r2) {
        return Math.floor(Math.LN2 * this.DB / Math.log(r2));
      }
      function bnSigNum() {
        if (this.s < 0) return -1;
        else if (this.t <= 0 || this.t == 1 && this[0] <= 0) return 0;
        else return 1;
      }
      function bnpToRadix(b) {
        if (b == null) b = 10;
        if (this.signum() == 0 || b < 2 || b > 36) return "0";
        var cs = this.chunkSize(b);
        var a = Math.pow(b, cs);
        var d = nbv(a), y = nbi(), z2 = nbi(), r2 = "";
        this.divRemTo(d, y, z2);
        while (y.signum() > 0) {
          r2 = (a + z2.intValue()).toString(b).substr(1) + r2;
          y.divRemTo(d, y, z2);
        }
        return z2.intValue().toString(b) + r2;
      }
      function bnpFromRadix(s2, b) {
        this.fromInt(0);
        if (b == null) b = 10;
        var cs = this.chunkSize(b);
        var d = Math.pow(b, cs), mi = false, j = 0, w = 0;
        for (var i2 = 0; i2 < s2.length; ++i2) {
          var x2 = intAt(s2, i2);
          if (x2 < 0) {
            if (s2.charAt(i2) == "-" && this.signum() == 0) mi = true;
            continue;
          }
          w = b * w + x2;
          if (++j >= cs) {
            this.dMultiply(d);
            this.dAddOffset(w, 0);
            j = 0;
            w = 0;
          }
        }
        if (j > 0) {
          this.dMultiply(Math.pow(b, j));
          this.dAddOffset(w, 0);
        }
        if (mi) BigInteger.ZERO.subTo(this, this);
      }
      function bnpFromNumber(a, b, c) {
        if ("number" == typeof b) {
          if (a < 2) this.fromInt(1);
          else {
            this.fromNumber(a, c);
            if (!this.testBit(a - 1))
              this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);
            if (this.isEven()) this.dAddOffset(1, 0);
            while (!this.isProbablePrime(b)) {
              this.dAddOffset(2, 0);
              if (this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);
            }
          }
        } else {
          var x2 = new Array(), t3 = a & 7;
          x2.length = (a >> 3) + 1;
          b.nextBytes(x2);
          if (t3 > 0) x2[0] &= (1 << t3) - 1;
          else x2[0] = 0;
          this.fromString(x2, 256);
        }
      }
      function bnToByteArray() {
        var i2 = this.t, r2 = new Array();
        r2[0] = this.s;
        var p = this.DB - i2 * this.DB % 8, d, k = 0;
        if (i2-- > 0) {
          if (p < this.DB && (d = this[i2] >> p) != (this.s & this.DM) >> p)
            r2[k++] = d | this.s << this.DB - p;
          while (i2 >= 0) {
            if (p < 8) {
              d = (this[i2] & (1 << p) - 1) << 8 - p;
              d |= this[--i2] >> (p += this.DB - 8);
            } else {
              d = this[i2] >> (p -= 8) & 255;
              if (p <= 0) {
                p += this.DB;
                --i2;
              }
            }
            if ((d & 128) != 0) d |= -256;
            if (k == 0 && (this.s & 128) != (d & 128)) ++k;
            if (k > 0 || d != this.s) r2[k++] = d;
          }
        }
        return r2;
      }
      function bnEquals(a) {
        return this.compareTo(a) == 0;
      }
      function bnMin(a) {
        return this.compareTo(a) < 0 ? this : a;
      }
      function bnMax(a) {
        return this.compareTo(a) > 0 ? this : a;
      }
      function bnpBitwiseTo(a, op, r2) {
        var i2, f3, m2 = Math.min(a.t, this.t);
        for (i2 = 0; i2 < m2; ++i2) r2[i2] = op(this[i2], a[i2]);
        if (a.t < this.t) {
          f3 = a.s & this.DM;
          for (i2 = m2; i2 < this.t; ++i2) r2[i2] = op(this[i2], f3);
          r2.t = this.t;
        } else {
          f3 = this.s & this.DM;
          for (i2 = m2; i2 < a.t; ++i2) r2[i2] = op(f3, a[i2]);
          r2.t = a.t;
        }
        r2.s = op(this.s, a.s);
        r2.clamp();
      }
      function op_and(x2, y) {
        return x2 & y;
      }
      function bnAnd(a) {
        var r2 = nbi();
        this.bitwiseTo(a, op_and, r2);
        return r2;
      }
      function op_or(x2, y) {
        return x2 | y;
      }
      function bnOr(a) {
        var r2 = nbi();
        this.bitwiseTo(a, op_or, r2);
        return r2;
      }
      function op_xor(x2, y) {
        return x2 ^ y;
      }
      function bnXor(a) {
        var r2 = nbi();
        this.bitwiseTo(a, op_xor, r2);
        return r2;
      }
      function op_andnot(x2, y) {
        return x2 & ~y;
      }
      function bnAndNot(a) {
        var r2 = nbi();
        this.bitwiseTo(a, op_andnot, r2);
        return r2;
      }
      function bnNot() {
        var r2 = nbi();
        for (var i2 = 0; i2 < this.t; ++i2) r2[i2] = this.DM & ~this[i2];
        r2.t = this.t;
        r2.s = ~this.s;
        return r2;
      }
      function bnShiftLeft(n) {
        var r2 = nbi();
        if (n < 0) this.rShiftTo(-n, r2);
        else this.lShiftTo(n, r2);
        return r2;
      }
      function bnShiftRight(n) {
        var r2 = nbi();
        if (n < 0) this.lShiftTo(-n, r2);
        else this.rShiftTo(n, r2);
        return r2;
      }
      function lbit(x2) {
        if (x2 == 0) return -1;
        var r2 = 0;
        if ((x2 & 65535) == 0) {
          x2 >>= 16;
          r2 += 16;
        }
        if ((x2 & 255) == 0) {
          x2 >>= 8;
          r2 += 8;
        }
        if ((x2 & 15) == 0) {
          x2 >>= 4;
          r2 += 4;
        }
        if ((x2 & 3) == 0) {
          x2 >>= 2;
          r2 += 2;
        }
        if ((x2 & 1) == 0) ++r2;
        return r2;
      }
      function bnGetLowestSetBit() {
        for (var i2 = 0; i2 < this.t; ++i2)
          if (this[i2] != 0) return i2 * this.DB + lbit(this[i2]);
        if (this.s < 0) return this.t * this.DB;
        return -1;
      }
      function cbit(x2) {
        var r2 = 0;
        while (x2 != 0) {
          x2 &= x2 - 1;
          ++r2;
        }
        return r2;
      }
      function bnBitCount() {
        var r2 = 0, x2 = this.s & this.DM;
        for (var i2 = 0; i2 < this.t; ++i2) r2 += cbit(this[i2] ^ x2);
        return r2;
      }
      function bnTestBit(n) {
        var j = Math.floor(n / this.DB);
        if (j >= this.t) return this.s != 0;
        return (this[j] & 1 << n % this.DB) != 0;
      }
      function bnpChangeBit(n, op) {
        var r2 = BigInteger.ONE.shiftLeft(n);
        this.bitwiseTo(r2, op, r2);
        return r2;
      }
      function bnSetBit(n) {
        return this.changeBit(n, op_or);
      }
      function bnClearBit(n) {
        return this.changeBit(n, op_andnot);
      }
      function bnFlipBit(n) {
        return this.changeBit(n, op_xor);
      }
      function bnpAddTo(a, r2) {
        var i2 = 0, c = 0, m2 = Math.min(a.t, this.t);
        while (i2 < m2) {
          c += this[i2] + a[i2];
          r2[i2++] = c & this.DM;
          c >>= this.DB;
        }
        if (a.t < this.t) {
          c += a.s;
          while (i2 < this.t) {
            c += this[i2];
            r2[i2++] = c & this.DM;
            c >>= this.DB;
          }
          c += this.s;
        } else {
          c += this.s;
          while (i2 < a.t) {
            c += a[i2];
            r2[i2++] = c & this.DM;
            c >>= this.DB;
          }
          c += a.s;
        }
        r2.s = c < 0 ? -1 : 0;
        if (c > 0) r2[i2++] = c;
        else if (c < -1) r2[i2++] = this.DV + c;
        r2.t = i2;
        r2.clamp();
      }
      function bnAdd(a) {
        var r2 = nbi();
        this.addTo(a, r2);
        return r2;
      }
      function bnSubtract(a) {
        var r2 = nbi();
        this.subTo(a, r2);
        return r2;
      }
      function bnMultiply(a) {
        var r2 = nbi();
        this.multiplyTo(a, r2);
        return r2;
      }
      function bnSquare() {
        var r2 = nbi();
        this.squareTo(r2);
        return r2;
      }
      function bnDivide(a) {
        var r2 = nbi();
        this.divRemTo(a, r2, null);
        return r2;
      }
      function bnRemainder(a) {
        var r2 = nbi();
        this.divRemTo(a, null, r2);
        return r2;
      }
      function bnDivideAndRemainder(a) {
        var q = nbi(), r2 = nbi();
        this.divRemTo(a, q, r2);
        return new Array(q, r2);
      }
      function bnpDMultiply(n) {
        this[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
        ++this.t;
        this.clamp();
      }
      function bnpDAddOffset(n, w) {
        if (n == 0) return;
        while (this.t <= w) this[this.t++] = 0;
        this[w] += n;
        while (this[w] >= this.DV) {
          this[w] -= this.DV;
          if (++w >= this.t) this[this.t++] = 0;
          ++this[w];
        }
      }
      function NullExp() {
      }
      function nNop(x2) {
        return x2;
      }
      function nMulTo(x2, y, r2) {
        x2.multiplyTo(y, r2);
      }
      function nSqrTo(x2, r2) {
        x2.squareTo(r2);
      }
      NullExp.prototype.convert = nNop;
      NullExp.prototype.revert = nNop;
      NullExp.prototype.mulTo = nMulTo;
      NullExp.prototype.sqrTo = nSqrTo;
      function bnPow(e2) {
        return this.exp(e2, new NullExp());
      }
      function bnpMultiplyLowerTo(a, n, r2) {
        var i2 = Math.min(this.t + a.t, n);
        r2.s = 0;
        r2.t = i2;
        while (i2 > 0) r2[--i2] = 0;
        var j;
        for (j = r2.t - this.t; i2 < j; ++i2) r2[i2 + this.t] = this.am(0, a[i2], r2, i2, 0, this.t);
        for (j = Math.min(a.t, n); i2 < j; ++i2) this.am(0, a[i2], r2, i2, 0, n - i2);
        r2.clamp();
      }
      function bnpMultiplyUpperTo(a, n, r2) {
        --n;
        var i2 = r2.t = this.t + a.t - n;
        r2.s = 0;
        while (--i2 >= 0) r2[i2] = 0;
        for (i2 = Math.max(n - this.t, 0); i2 < a.t; ++i2)
          r2[this.t + i2 - n] = this.am(n - i2, a[i2], r2, 0, 0, this.t + i2 - n);
        r2.clamp();
        r2.drShiftTo(1, r2);
      }
      function Barrett(m2) {
        this.r2 = nbi();
        this.q3 = nbi();
        BigInteger.ONE.dlShiftTo(2 * m2.t, this.r2);
        this.mu = this.r2.divide(m2);
        this.m = m2;
      }
      function barrettConvert(x2) {
        if (x2.s < 0 || x2.t > 2 * this.m.t) return x2.mod(this.m);
        else if (x2.compareTo(this.m) < 0) return x2;
        else {
          var r2 = nbi();
          x2.copyTo(r2);
          this.reduce(r2);
          return r2;
        }
      }
      function barrettRevert(x2) {
        return x2;
      }
      function barrettReduce(x2) {
        x2.drShiftTo(this.m.t - 1, this.r2);
        if (x2.t > this.m.t + 1) {
          x2.t = this.m.t + 1;
          x2.clamp();
        }
        this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
        this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
        while (x2.compareTo(this.r2) < 0) x2.dAddOffset(1, this.m.t + 1);
        x2.subTo(this.r2, x2);
        while (x2.compareTo(this.m) >= 0) x2.subTo(this.m, x2);
      }
      function barrettSqrTo(x2, r2) {
        x2.squareTo(r2);
        this.reduce(r2);
      }
      function barrettMulTo(x2, y, r2) {
        x2.multiplyTo(y, r2);
        this.reduce(r2);
      }
      Barrett.prototype.convert = barrettConvert;
      Barrett.prototype.revert = barrettRevert;
      Barrett.prototype.reduce = barrettReduce;
      Barrett.prototype.mulTo = barrettMulTo;
      Barrett.prototype.sqrTo = barrettSqrTo;
      function bnModPow(e2, m2) {
        var i2 = e2.bitLength(), k, r2 = nbv(1), z2;
        if (i2 <= 0) return r2;
        else if (i2 < 18) k = 1;
        else if (i2 < 48) k = 3;
        else if (i2 < 144) k = 4;
        else if (i2 < 768) k = 5;
        else k = 6;
        if (i2 < 8)
          z2 = new Classic(m2);
        else if (m2.isEven())
          z2 = new Barrett(m2);
        else
          z2 = new Montgomery(m2);
        var g = new Array(), n = 3, k1 = k - 1, km = (1 << k) - 1;
        g[1] = z2.convert(this);
        if (k > 1) {
          var g2 = nbi();
          z2.sqrTo(g[1], g2);
          while (n <= km) {
            g[n] = nbi();
            z2.mulTo(g2, g[n - 2], g[n]);
            n += 2;
          }
        }
        var j = e2.t - 1, w, is1 = true, r22 = nbi(), t3;
        i2 = nbits(e2[j]) - 1;
        while (j >= 0) {
          if (i2 >= k1) w = e2[j] >> i2 - k1 & km;
          else {
            w = (e2[j] & (1 << i2 + 1) - 1) << k1 - i2;
            if (j > 0) w |= e2[j - 1] >> this.DB + i2 - k1;
          }
          n = k;
          while ((w & 1) == 0) {
            w >>= 1;
            --n;
          }
          if ((i2 -= n) < 0) {
            i2 += this.DB;
            --j;
          }
          if (is1) {
            g[w].copyTo(r2);
            is1 = false;
          } else {
            while (n > 1) {
              z2.sqrTo(r2, r22);
              z2.sqrTo(r22, r2);
              n -= 2;
            }
            if (n > 0) z2.sqrTo(r2, r22);
            else {
              t3 = r2;
              r2 = r22;
              r22 = t3;
            }
            z2.mulTo(r22, g[w], r2);
          }
          while (j >= 0 && (e2[j] & 1 << i2) == 0) {
            z2.sqrTo(r2, r22);
            t3 = r2;
            r2 = r22;
            r22 = t3;
            if (--i2 < 0) {
              i2 = this.DB - 1;
              --j;
            }
          }
        }
        return z2.revert(r2);
      }
      function bnGCD(a) {
        var x2 = this.s < 0 ? this.negate() : this.clone();
        var y = a.s < 0 ? a.negate() : a.clone();
        if (x2.compareTo(y) < 0) {
          var t3 = x2;
          x2 = y;
          y = t3;
        }
        var i2 = x2.getLowestSetBit(), g = y.getLowestSetBit();
        if (g < 0) return x2;
        if (i2 < g) g = i2;
        if (g > 0) {
          x2.rShiftTo(g, x2);
          y.rShiftTo(g, y);
        }
        while (x2.signum() > 0) {
          if ((i2 = x2.getLowestSetBit()) > 0) x2.rShiftTo(i2, x2);
          if ((i2 = y.getLowestSetBit()) > 0) y.rShiftTo(i2, y);
          if (x2.compareTo(y) >= 0) {
            x2.subTo(y, x2);
            x2.rShiftTo(1, x2);
          } else {
            y.subTo(x2, y);
            y.rShiftTo(1, y);
          }
        }
        if (g > 0) y.lShiftTo(g, y);
        return y;
      }
      function bnpModInt(n) {
        if (n <= 0) return 0;
        var d = this.DV % n, r2 = this.s < 0 ? n - 1 : 0;
        if (this.t > 0)
          if (d == 0) r2 = this[0] % n;
          else for (var i2 = this.t - 1; i2 >= 0; --i2) r2 = (d * r2 + this[i2]) % n;
        return r2;
      }
      function bnModInverse(m2) {
        var ac = m2.isEven();
        if (this.isEven() && ac || m2.signum() == 0) return BigInteger.ZERO;
        var u = m2.clone(), v = this.clone();
        var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);
        while (u.signum() != 0) {
          while (u.isEven()) {
            u.rShiftTo(1, u);
            if (ac) {
              if (!a.isEven() || !b.isEven()) {
                a.addTo(this, a);
                b.subTo(m2, b);
              }
              a.rShiftTo(1, a);
            } else if (!b.isEven()) b.subTo(m2, b);
            b.rShiftTo(1, b);
          }
          while (v.isEven()) {
            v.rShiftTo(1, v);
            if (ac) {
              if (!c.isEven() || !d.isEven()) {
                c.addTo(this, c);
                d.subTo(m2, d);
              }
              c.rShiftTo(1, c);
            } else if (!d.isEven()) d.subTo(m2, d);
            d.rShiftTo(1, d);
          }
          if (u.compareTo(v) >= 0) {
            u.subTo(v, u);
            if (ac) a.subTo(c, a);
            b.subTo(d, b);
          } else {
            v.subTo(u, v);
            if (ac) c.subTo(a, c);
            d.subTo(b, d);
          }
        }
        if (v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;
        if (d.compareTo(m2) >= 0) return d.subtract(m2);
        if (d.signum() < 0) d.addTo(m2, d);
        else return d;
        if (d.signum() < 0) return d.add(m2);
        else return d;
      }
      var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];
      var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];
      function bnIsProbablePrime(t3) {
        var i2, x2 = this.abs();
        if (x2.t == 1 && x2[0] <= lowprimes[lowprimes.length - 1]) {
          for (i2 = 0; i2 < lowprimes.length; ++i2)
            if (x2[0] == lowprimes[i2]) return true;
          return false;
        }
        if (x2.isEven()) return false;
        i2 = 1;
        while (i2 < lowprimes.length) {
          var m2 = lowprimes[i2], j = i2 + 1;
          while (j < lowprimes.length && m2 < lplim) m2 *= lowprimes[j++];
          m2 = x2.modInt(m2);
          while (i2 < j) if (m2 % lowprimes[i2++] == 0) return false;
        }
        return x2.millerRabin(t3);
      }
      function bnpMillerRabin(t3) {
        var n1 = this.subtract(BigInteger.ONE);
        var k = n1.getLowestSetBit();
        if (k <= 0) return false;
        var r2 = n1.shiftRight(k);
        t3 = t3 + 1 >> 1;
        if (t3 > lowprimes.length) t3 = lowprimes.length;
        var a = nbi();
        for (var i2 = 0; i2 < t3; ++i2) {
          a.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]);
          var y = a.modPow(r2, this);
          if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
            var j = 1;
            while (j++ < k && y.compareTo(n1) != 0) {
              y = y.modPowInt(2, this);
              if (y.compareTo(BigInteger.ONE) == 0) return false;
            }
            if (y.compareTo(n1) != 0) return false;
          }
        }
        return true;
      }
      BigInteger.prototype.chunkSize = bnpChunkSize;
      BigInteger.prototype.toRadix = bnpToRadix;
      BigInteger.prototype.fromRadix = bnpFromRadix;
      BigInteger.prototype.fromNumber = bnpFromNumber;
      BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
      BigInteger.prototype.changeBit = bnpChangeBit;
      BigInteger.prototype.addTo = bnpAddTo;
      BigInteger.prototype.dMultiply = bnpDMultiply;
      BigInteger.prototype.dAddOffset = bnpDAddOffset;
      BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
      BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
      BigInteger.prototype.modInt = bnpModInt;
      BigInteger.prototype.millerRabin = bnpMillerRabin;
      BigInteger.prototype.clone = bnClone;
      BigInteger.prototype.intValue = bnIntValue;
      BigInteger.prototype.byteValue = bnByteValue;
      BigInteger.prototype.shortValue = bnShortValue;
      BigInteger.prototype.signum = bnSigNum;
      BigInteger.prototype.toByteArray = bnToByteArray;
      BigInteger.prototype.equals = bnEquals;
      BigInteger.prototype.min = bnMin;
      BigInteger.prototype.max = bnMax;
      BigInteger.prototype.and = bnAnd;
      BigInteger.prototype.or = bnOr;
      BigInteger.prototype.xor = bnXor;
      BigInteger.prototype.andNot = bnAndNot;
      BigInteger.prototype.not = bnNot;
      BigInteger.prototype.shiftLeft = bnShiftLeft;
      BigInteger.prototype.shiftRight = bnShiftRight;
      BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
      BigInteger.prototype.bitCount = bnBitCount;
      BigInteger.prototype.testBit = bnTestBit;
      BigInteger.prototype.setBit = bnSetBit;
      BigInteger.prototype.clearBit = bnClearBit;
      BigInteger.prototype.flipBit = bnFlipBit;
      BigInteger.prototype.add = bnAdd;
      BigInteger.prototype.subtract = bnSubtract;
      BigInteger.prototype.multiply = bnMultiply;
      BigInteger.prototype.divide = bnDivide;
      BigInteger.prototype.remainder = bnRemainder;
      BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
      BigInteger.prototype.modPow = bnModPow;
      BigInteger.prototype.modInverse = bnModInverse;
      BigInteger.prototype.pow = bnPow;
      BigInteger.prototype.gcd = bnGCD;
      BigInteger.prototype.isProbablePrime = bnIsProbablePrime;
      BigInteger.prototype.square = bnSquare;
      BigInteger.prototype.Barrett = Barrett;
      var rng_state;
      var rng_pool;
      var rng_pptr;
      function rng_seed_int(x2) {
        rng_pool[rng_pptr++] ^= x2 & 255;
        rng_pool[rng_pptr++] ^= x2 >> 8 & 255;
        rng_pool[rng_pptr++] ^= x2 >> 16 & 255;
        rng_pool[rng_pptr++] ^= x2 >> 24 & 255;
        if (rng_pptr >= rng_psize) rng_pptr -= rng_psize;
      }
      function rng_seed_time() {
        rng_seed_int((/* @__PURE__ */ new Date()).getTime());
      }
      if (rng_pool == null) {
        rng_pool = new Array();
        rng_pptr = 0;
        var t2;
        if (typeof window !== "undefined" && window.crypto) {
          if (window.crypto.getRandomValues) {
            var ua = new Uint8Array(32);
            window.crypto.getRandomValues(ua);
            for (t2 = 0; t2 < 32; ++t2)
              rng_pool[rng_pptr++] = ua[t2];
          } else if (navigator.appName == "Netscape" && navigator.appVersion < "5") {
            var z = window.crypto.random(32);
            for (t2 = 0; t2 < z.length; ++t2)
              rng_pool[rng_pptr++] = z.charCodeAt(t2) & 255;
          }
        }
        while (rng_pptr < rng_psize) {
          t2 = Math.floor(65536 * Math.random());
          rng_pool[rng_pptr++] = t2 >>> 8;
          rng_pool[rng_pptr++] = t2 & 255;
        }
        rng_pptr = 0;
        rng_seed_time();
      }
      function rng_get_byte() {
        if (rng_state == null) {
          rng_seed_time();
          rng_state = prng_newstate();
          rng_state.init(rng_pool);
          for (rng_pptr = 0; rng_pptr < rng_pool.length; ++rng_pptr)
            rng_pool[rng_pptr] = 0;
          rng_pptr = 0;
        }
        return rng_state.next();
      }
      function rng_get_bytes(ba) {
        var i2;
        for (i2 = 0; i2 < ba.length; ++i2) ba[i2] = rng_get_byte();
      }
      function SecureRandom() {
      }
      SecureRandom.prototype.nextBytes = rng_get_bytes;
      function Arcfour() {
        this.i = 0;
        this.j = 0;
        this.S = new Array();
      }
      function ARC4init(key) {
        var i2, j, t3;
        for (i2 = 0; i2 < 256; ++i2)
          this.S[i2] = i2;
        j = 0;
        for (i2 = 0; i2 < 256; ++i2) {
          j = j + this.S[i2] + key[i2 % key.length] & 255;
          t3 = this.S[i2];
          this.S[i2] = this.S[j];
          this.S[j] = t3;
        }
        this.i = 0;
        this.j = 0;
      }
      function ARC4next() {
        var t3;
        this.i = this.i + 1 & 255;
        this.j = this.j + this.S[this.i] & 255;
        t3 = this.S[this.i];
        this.S[this.i] = this.S[this.j];
        this.S[this.j] = t3;
        return this.S[t3 + this.S[this.i] & 255];
      }
      Arcfour.prototype.init = ARC4init;
      Arcfour.prototype.next = ARC4next;
      function prng_newstate() {
        return new Arcfour();
      }
      var rng_psize = 256;
      if (typeof exports2 !== "undefined") {
        exports2 = module2.exports = {
          default: BigInteger,
          BigInteger,
          SecureRandom
        };
      } else {
        this.jsbn = {
          BigInteger,
          SecureRandom
        };
      }
    }).call(exports2);
  }
});

// node_modules/ip-address/node_modules/sprintf-js/src/sprintf.js
var require_sprintf = __commonJS({
  "node_modules/ip-address/node_modules/sprintf-js/src/sprintf.js"(exports2) {
    !function() {
      "use strict";
      var re = {
        not_string: /[^s]/,
        not_bool: /[^t]/,
        not_type: /[^T]/,
        not_primitive: /[^v]/,
        number: /[diefg]/,
        numeric_arg: /[bcdiefguxX]/,
        json: /[j]/,
        not_json: /[^j]/,
        text: /^[^\x25]+/,
        modulo: /^\x25{2}/,
        placeholder: /^\x25(?:([1-9]\d*)\$|\(([^)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijostTuvxX])/,
        key: /^([a-z_][a-z_\d]*)/i,
        key_access: /^\.([a-z_][a-z_\d]*)/i,
        index_access: /^\[(\d+)\]/,
        sign: /^[+-]/
      };
      function sprintf(key) {
        return sprintf_format(sprintf_parse(key), arguments);
      }
      function vsprintf(fmt, argv) {
        return sprintf.apply(null, [fmt].concat(argv || []));
      }
      function sprintf_format(parse_tree, argv) {
        var cursor = 1, tree_length = parse_tree.length, arg, output = "", i2, k, ph, pad, pad_character, pad_length, is_positive, sign;
        for (i2 = 0; i2 < tree_length; i2++) {
          if (typeof parse_tree[i2] === "string") {
            output += parse_tree[i2];
          } else if (typeof parse_tree[i2] === "object") {
            ph = parse_tree[i2];
            if (ph.keys) {
              arg = argv[cursor];
              for (k = 0; k < ph.keys.length; k++) {
                if (arg == void 0) {
                  throw new Error(sprintf('[sprintf] Cannot access property "%s" of undefined value "%s"', ph.keys[k], ph.keys[k - 1]));
                }
                arg = arg[ph.keys[k]];
              }
            } else if (ph.param_no) {
              arg = argv[ph.param_no];
            } else {
              arg = argv[cursor++];
            }
            if (re.not_type.test(ph.type) && re.not_primitive.test(ph.type) && arg instanceof Function) {
              arg = arg();
            }
            if (re.numeric_arg.test(ph.type) && (typeof arg !== "number" && isNaN(arg))) {
              throw new TypeError(sprintf("[sprintf] expecting number but found %T", arg));
            }
            if (re.number.test(ph.type)) {
              is_positive = arg >= 0;
            }
            switch (ph.type) {
              case "b":
                arg = parseInt(arg, 10).toString(2);
                break;
              case "c":
                arg = String.fromCharCode(parseInt(arg, 10));
                break;
              case "d":
              case "i":
                arg = parseInt(arg, 10);
                break;
              case "j":
                arg = JSON.stringify(arg, null, ph.width ? parseInt(ph.width) : 0);
                break;
              case "e":
                arg = ph.precision ? parseFloat(arg).toExponential(ph.precision) : parseFloat(arg).toExponential();
                break;
              case "f":
                arg = ph.precision ? parseFloat(arg).toFixed(ph.precision) : parseFloat(arg);
                break;
              case "g":
                arg = ph.precision ? String(Number(arg.toPrecision(ph.precision))) : parseFloat(arg);
                break;
              case "o":
                arg = (parseInt(arg, 10) >>> 0).toString(8);
                break;
              case "s":
                arg = String(arg);
                arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                break;
              case "t":
                arg = String(!!arg);
                arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                break;
              case "T":
                arg = Object.prototype.toString.call(arg).slice(8, -1).toLowerCase();
                arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                break;
              case "u":
                arg = parseInt(arg, 10) >>> 0;
                break;
              case "v":
                arg = arg.valueOf();
                arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                break;
              case "x":
                arg = (parseInt(arg, 10) >>> 0).toString(16);
                break;
              case "X":
                arg = (parseInt(arg, 10) >>> 0).toString(16).toUpperCase();
                break;
            }
            if (re.json.test(ph.type)) {
              output += arg;
            } else {
              if (re.number.test(ph.type) && (!is_positive || ph.sign)) {
                sign = is_positive ? "+" : "-";
                arg = arg.toString().replace(re.sign, "");
              } else {
                sign = "";
              }
              pad_character = ph.pad_char ? ph.pad_char === "0" ? "0" : ph.pad_char.charAt(1) : " ";
              pad_length = ph.width - (sign + arg).length;
              pad = ph.width ? pad_length > 0 ? pad_character.repeat(pad_length) : "" : "";
              output += ph.align ? sign + arg + pad : pad_character === "0" ? sign + pad + arg : pad + sign + arg;
            }
          }
        }
        return output;
      }
      var sprintf_cache = /* @__PURE__ */ Object.create(null);
      function sprintf_parse(fmt) {
        if (sprintf_cache[fmt]) {
          return sprintf_cache[fmt];
        }
        var _fmt = fmt, match, parse_tree = [], arg_names = 0;
        while (_fmt) {
          if ((match = re.text.exec(_fmt)) !== null) {
            parse_tree.push(match[0]);
          } else if ((match = re.modulo.exec(_fmt)) !== null) {
            parse_tree.push("%");
          } else if ((match = re.placeholder.exec(_fmt)) !== null) {
            if (match[2]) {
              arg_names |= 1;
              var field_list = [], replacement_field = match[2], field_match = [];
              if ((field_match = re.key.exec(replacement_field)) !== null) {
                field_list.push(field_match[1]);
                while ((replacement_field = replacement_field.substring(field_match[0].length)) !== "") {
                  if ((field_match = re.key_access.exec(replacement_field)) !== null) {
                    field_list.push(field_match[1]);
                  } else if ((field_match = re.index_access.exec(replacement_field)) !== null) {
                    field_list.push(field_match[1]);
                  } else {
                    throw new SyntaxError("[sprintf] failed to parse named argument key");
                  }
                }
              } else {
                throw new SyntaxError("[sprintf] failed to parse named argument key");
              }
              match[2] = field_list;
            } else {
              arg_names |= 2;
            }
            if (arg_names === 3) {
              throw new Error("[sprintf] mixing positional and named placeholders is not (yet) supported");
            }
            parse_tree.push(
              {
                placeholder: match[0],
                param_no: match[1],
                keys: match[2],
                sign: match[3],
                pad_char: match[4],
                align: match[5],
                width: match[6],
                precision: match[7],
                type: match[8]
              }
            );
          } else {
            throw new SyntaxError("[sprintf] unexpected placeholder");
          }
          _fmt = _fmt.substring(match[0].length);
        }
        return sprintf_cache[fmt] = parse_tree;
      }
      if (typeof exports2 !== "undefined") {
        exports2["sprintf"] = sprintf;
        exports2["vsprintf"] = vsprintf;
      }
      if (typeof window !== "undefined") {
        window["sprintf"] = sprintf;
        window["vsprintf"] = vsprintf;
        if (typeof define === "function" && define["amd"]) {
          define(function() {
            return {
              "sprintf": sprintf,
              "vsprintf": vsprintf
            };
          });
        }
      }
    }();
  }
});

// node_modules/ip-address/dist/ipv4.js
var require_ipv4 = __commonJS({
  "node_modules/ip-address/dist/ipv4.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m2, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m2, k);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m2, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m2[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Address4 = void 0;
    var common = __importStar(require_common2());
    var constants = __importStar(require_constants3());
    var address_error_1 = require_address_error();
    var jsbn_1 = require_jsbn();
    var sprintf_js_1 = require_sprintf();
    var Address4 = class _Address4 {
      constructor(address) {
        this.groups = constants.GROUPS;
        this.parsedAddress = [];
        this.parsedSubnet = "";
        this.subnet = "/32";
        this.subnetMask = 32;
        this.v4 = true;
        this.isCorrect = common.isCorrect(constants.BITS);
        this.isInSubnet = common.isInSubnet;
        this.address = address;
        const subnet = constants.RE_SUBNET_STRING.exec(address);
        if (subnet) {
          this.parsedSubnet = subnet[0].replace("/", "");
          this.subnetMask = parseInt(this.parsedSubnet, 10);
          this.subnet = `/${this.subnetMask}`;
          if (this.subnetMask < 0 || this.subnetMask > constants.BITS) {
            throw new address_error_1.AddressError("Invalid subnet mask.");
          }
          address = address.replace(constants.RE_SUBNET_STRING, "");
        }
        this.addressMinusSuffix = address;
        this.parsedAddress = this.parse(address);
      }
      static isValid(address) {
        try {
          new _Address4(address);
          return true;
        } catch (e2) {
          return false;
        }
      }
      /*
       * Parses a v4 address
       */
      parse(address) {
        const groups = address.split(".");
        if (!address.match(constants.RE_ADDRESS)) {
          throw new address_error_1.AddressError("Invalid IPv4 address.");
        }
        return groups;
      }
      /**
       * Returns the correct form of an address
       * @memberof Address4
       * @instance
       * @returns {String}
       */
      correctForm() {
        return this.parsedAddress.map((part) => parseInt(part, 10)).join(".");
      }
      /**
       * Converts a hex string to an IPv4 address object
       * @memberof Address4
       * @static
       * @param {string} hex - a hex string to convert
       * @returns {Address4}
       */
      static fromHex(hex) {
        const padded = hex.replace(/:/g, "").padStart(8, "0");
        const groups = [];
        let i2;
        for (i2 = 0; i2 < 8; i2 += 2) {
          const h2 = padded.slice(i2, i2 + 2);
          groups.push(parseInt(h2, 16));
        }
        return new _Address4(groups.join("."));
      }
      /**
       * Converts an integer into a IPv4 address object
       * @memberof Address4
       * @static
       * @param {integer} integer - a number to convert
       * @returns {Address4}
       */
      static fromInteger(integer) {
        return _Address4.fromHex(integer.toString(16));
      }
      /**
       * Return an address from in-addr.arpa form
       * @memberof Address4
       * @static
       * @param {string} arpaFormAddress - an 'in-addr.arpa' form ipv4 address
       * @returns {Adress4}
       * @example
       * var address = Address4.fromArpa(42.2.0.192.in-addr.arpa.)
       * address.correctForm(); // '192.0.2.42'
       */
      static fromArpa(arpaFormAddress) {
        const leader = arpaFormAddress.replace(/(\.in-addr\.arpa)?\.$/, "");
        const address = leader.split(".").reverse().join(".");
        return new _Address4(address);
      }
      /**
       * Converts an IPv4 address object to a hex string
       * @memberof Address4
       * @instance
       * @returns {String}
       */
      toHex() {
        return this.parsedAddress.map((part) => (0, sprintf_js_1.sprintf)("%02x", parseInt(part, 10))).join(":");
      }
      /**
       * Converts an IPv4 address object to an array of bytes
       * @memberof Address4
       * @instance
       * @returns {Array}
       */
      toArray() {
        return this.parsedAddress.map((part) => parseInt(part, 10));
      }
      /**
       * Converts an IPv4 address object to an IPv6 address group
       * @memberof Address4
       * @instance
       * @returns {String}
       */
      toGroup6() {
        const output = [];
        let i2;
        for (i2 = 0; i2 < constants.GROUPS; i2 += 2) {
          const hex = (0, sprintf_js_1.sprintf)("%02x%02x", parseInt(this.parsedAddress[i2], 10), parseInt(this.parsedAddress[i2 + 1], 10));
          output.push((0, sprintf_js_1.sprintf)("%x", parseInt(hex, 16)));
        }
        return output.join(":");
      }
      /**
       * Returns the address as a BigInteger
       * @memberof Address4
       * @instance
       * @returns {BigInteger}
       */
      bigInteger() {
        return new jsbn_1.BigInteger(this.parsedAddress.map((n) => (0, sprintf_js_1.sprintf)("%02x", parseInt(n, 10))).join(""), 16);
      }
      /**
       * Helper function getting start address.
       * @memberof Address4
       * @instance
       * @returns {BigInteger}
       */
      _startAddress() {
        return new jsbn_1.BigInteger(this.mask() + "0".repeat(constants.BITS - this.subnetMask), 2);
      }
      /**
       * The first address in the range given by this address' subnet.
       * Often referred to as the Network Address.
       * @memberof Address4
       * @instance
       * @returns {Address4}
       */
      startAddress() {
        return _Address4.fromBigInteger(this._startAddress());
      }
      /**
       * The first host address in the range given by this address's subnet ie
       * the first address after the Network Address
       * @memberof Address4
       * @instance
       * @returns {Address4}
       */
      startAddressExclusive() {
        const adjust = new jsbn_1.BigInteger("1");
        return _Address4.fromBigInteger(this._startAddress().add(adjust));
      }
      /**
       * Helper function getting end address.
       * @memberof Address4
       * @instance
       * @returns {BigInteger}
       */
      _endAddress() {
        return new jsbn_1.BigInteger(this.mask() + "1".repeat(constants.BITS - this.subnetMask), 2);
      }
      /**
       * The last address in the range given by this address' subnet
       * Often referred to as the Broadcast
       * @memberof Address4
       * @instance
       * @returns {Address4}
       */
      endAddress() {
        return _Address4.fromBigInteger(this._endAddress());
      }
      /**
       * The last host address in the range given by this address's subnet ie
       * the last address prior to the Broadcast Address
       * @memberof Address4
       * @instance
       * @returns {Address4}
       */
      endAddressExclusive() {
        const adjust = new jsbn_1.BigInteger("1");
        return _Address4.fromBigInteger(this._endAddress().subtract(adjust));
      }
      /**
       * Converts a BigInteger to a v4 address object
       * @memberof Address4
       * @static
       * @param {BigInteger} bigInteger - a BigInteger to convert
       * @returns {Address4}
       */
      static fromBigInteger(bigInteger) {
        return _Address4.fromInteger(parseInt(bigInteger.toString(), 10));
      }
      /**
       * Returns the first n bits of the address, defaulting to the
       * subnet mask
       * @memberof Address4
       * @instance
       * @returns {String}
       */
      mask(mask) {
        if (mask === void 0) {
          mask = this.subnetMask;
        }
        return this.getBitsBase2(0, mask);
      }
      /**
       * Returns the bits in the given range as a base-2 string
       * @memberof Address4
       * @instance
       * @returns {string}
       */
      getBitsBase2(start, end) {
        return this.binaryZeroPad().slice(start, end);
      }
      /**
       * Return the reversed ip6.arpa form of the address
       * @memberof Address4
       * @param {Object} options
       * @param {boolean} options.omitSuffix - omit the "in-addr.arpa" suffix
       * @instance
       * @returns {String}
       */
      reverseForm(options) {
        if (!options) {
          options = {};
        }
        const reversed = this.correctForm().split(".").reverse().join(".");
        if (options.omitSuffix) {
          return reversed;
        }
        return (0, sprintf_js_1.sprintf)("%s.in-addr.arpa.", reversed);
      }
      /**
       * Returns true if the given address is a multicast address
       * @memberof Address4
       * @instance
       * @returns {boolean}
       */
      isMulticast() {
        return this.isInSubnet(new _Address4("224.0.0.0/4"));
      }
      /**
       * Returns a zero-padded base-2 string representation of the address
       * @memberof Address4
       * @instance
       * @returns {string}
       */
      binaryZeroPad() {
        return this.bigInteger().toString(2).padStart(constants.BITS, "0");
      }
      /**
       * Groups an IPv4 address for inclusion at the end of an IPv6 address
       * @returns {String}
       */
      groupForV6() {
        const segments = this.parsedAddress;
        return this.address.replace(constants.RE_ADDRESS, (0, sprintf_js_1.sprintf)('<span class="hover-group group-v4 group-6">%s</span>.<span class="hover-group group-v4 group-7">%s</span>', segments.slice(0, 2).join("."), segments.slice(2, 4).join(".")));
      }
    };
    exports2.Address4 = Address4;
  }
});

// node_modules/ip-address/dist/v6/constants.js
var require_constants4 = __commonJS({
  "node_modules/ip-address/dist/v6/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RE_URL_WITH_PORT = exports2.RE_URL = exports2.RE_ZONE_STRING = exports2.RE_SUBNET_STRING = exports2.RE_BAD_ADDRESS = exports2.RE_BAD_CHARACTERS = exports2.TYPES = exports2.SCOPES = exports2.GROUPS = exports2.BITS = void 0;
    exports2.BITS = 128;
    exports2.GROUPS = 8;
    exports2.SCOPES = {
      0: "Reserved",
      1: "Interface local",
      2: "Link local",
      4: "Admin local",
      5: "Site local",
      8: "Organization local",
      14: "Global",
      15: "Reserved"
    };
    exports2.TYPES = {
      "ff01::1/128": "Multicast (All nodes on this interface)",
      "ff01::2/128": "Multicast (All routers on this interface)",
      "ff02::1/128": "Multicast (All nodes on this link)",
      "ff02::2/128": "Multicast (All routers on this link)",
      "ff05::2/128": "Multicast (All routers in this site)",
      "ff02::5/128": "Multicast (OSPFv3 AllSPF routers)",
      "ff02::6/128": "Multicast (OSPFv3 AllDR routers)",
      "ff02::9/128": "Multicast (RIP routers)",
      "ff02::a/128": "Multicast (EIGRP routers)",
      "ff02::d/128": "Multicast (PIM routers)",
      "ff02::16/128": "Multicast (MLDv2 reports)",
      "ff01::fb/128": "Multicast (mDNSv6)",
      "ff02::fb/128": "Multicast (mDNSv6)",
      "ff05::fb/128": "Multicast (mDNSv6)",
      "ff02::1:2/128": "Multicast (All DHCP servers and relay agents on this link)",
      "ff05::1:2/128": "Multicast (All DHCP servers and relay agents in this site)",
      "ff02::1:3/128": "Multicast (All DHCP servers on this link)",
      "ff05::1:3/128": "Multicast (All DHCP servers in this site)",
      "::/128": "Unspecified",
      "::1/128": "Loopback",
      "ff00::/8": "Multicast",
      "fe80::/10": "Link-local unicast"
    };
    exports2.RE_BAD_CHARACTERS = /([^0-9a-f:/%])/gi;
    exports2.RE_BAD_ADDRESS = /([0-9a-f]{5,}|:{3,}|[^:]:$|^:[^:]|\/$)/gi;
    exports2.RE_SUBNET_STRING = /\/\d{1,3}(?=%|$)/;
    exports2.RE_ZONE_STRING = /%.*$/;
    exports2.RE_URL = new RegExp(/^\[{0,1}([0-9a-f:]+)\]{0,1}/);
    exports2.RE_URL_WITH_PORT = new RegExp(/\[([0-9a-f:]+)\]:([0-9]{1,5})/);
  }
});

// node_modules/ip-address/dist/v6/helpers.js
var require_helpers2 = __commonJS({
  "node_modules/ip-address/dist/v6/helpers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.simpleGroup = exports2.spanLeadingZeroes = exports2.spanAll = exports2.spanAllZeroes = void 0;
    var sprintf_js_1 = require_sprintf();
    function spanAllZeroes(s2) {
      return s2.replace(/(0+)/g, '<span class="zero">$1</span>');
    }
    exports2.spanAllZeroes = spanAllZeroes;
    function spanAll(s2, offset = 0) {
      const letters = s2.split("");
      return letters.map(
        (n, i2) => (0, sprintf_js_1.sprintf)('<span class="digit value-%s position-%d">%s</span>', n, i2 + offset, spanAllZeroes(n))
        // XXX Use #base-2 .value-0 instead?
      ).join("");
    }
    exports2.spanAll = spanAll;
    function spanLeadingZeroesSimple(group) {
      return group.replace(/^(0+)/, '<span class="zero">$1</span>');
    }
    function spanLeadingZeroes(address) {
      const groups = address.split(":");
      return groups.map((g) => spanLeadingZeroesSimple(g)).join(":");
    }
    exports2.spanLeadingZeroes = spanLeadingZeroes;
    function simpleGroup(addressString, offset = 0) {
      const groups = addressString.split(":");
      return groups.map((g, i2) => {
        if (/group-v4/.test(g)) {
          return g;
        }
        return (0, sprintf_js_1.sprintf)('<span class="hover-group group-%d">%s</span>', i2 + offset, spanLeadingZeroesSimple(g));
      });
    }
    exports2.simpleGroup = simpleGroup;
  }
});

// node_modules/ip-address/dist/v6/regular-expressions.js
var require_regular_expressions = __commonJS({
  "node_modules/ip-address/dist/v6/regular-expressions.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m2, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m2, k);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m2, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m2[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.possibleElisions = exports2.simpleRegularExpression = exports2.ADDRESS_BOUNDARY = exports2.padGroup = exports2.groupPossibilities = void 0;
    var v6 = __importStar(require_constants4());
    var sprintf_js_1 = require_sprintf();
    function groupPossibilities(possibilities) {
      return (0, sprintf_js_1.sprintf)("(%s)", possibilities.join("|"));
    }
    exports2.groupPossibilities = groupPossibilities;
    function padGroup(group) {
      if (group.length < 4) {
        return (0, sprintf_js_1.sprintf)("0{0,%d}%s", 4 - group.length, group);
      }
      return group;
    }
    exports2.padGroup = padGroup;
    exports2.ADDRESS_BOUNDARY = "[^A-Fa-f0-9:]";
    function simpleRegularExpression(groups) {
      const zeroIndexes = [];
      groups.forEach((group, i2) => {
        const groupInteger = parseInt(group, 16);
        if (groupInteger === 0) {
          zeroIndexes.push(i2);
        }
      });
      const possibilities = zeroIndexes.map((zeroIndex) => groups.map((group, i2) => {
        if (i2 === zeroIndex) {
          const elision = i2 === 0 || i2 === v6.GROUPS - 1 ? ":" : "";
          return groupPossibilities([padGroup(group), elision]);
        }
        return padGroup(group);
      }).join(":"));
      possibilities.push(groups.map(padGroup).join(":"));
      return groupPossibilities(possibilities);
    }
    exports2.simpleRegularExpression = simpleRegularExpression;
    function possibleElisions(elidedGroups, moreLeft, moreRight) {
      const left = moreLeft ? "" : ":";
      const right = moreRight ? "" : ":";
      const possibilities = [];
      if (!moreLeft && !moreRight) {
        possibilities.push("::");
      }
      if (moreLeft && moreRight) {
        possibilities.push("");
      }
      if (moreRight && !moreLeft || !moreRight && moreLeft) {
        possibilities.push(":");
      }
      possibilities.push((0, sprintf_js_1.sprintf)("%s(:0{1,4}){1,%d}", left, elidedGroups - 1));
      possibilities.push((0, sprintf_js_1.sprintf)("(0{1,4}:){1,%d}%s", elidedGroups - 1, right));
      possibilities.push((0, sprintf_js_1.sprintf)("(0{1,4}:){%d}0{1,4}", elidedGroups - 1));
      for (let groups = 1; groups < elidedGroups - 1; groups++) {
        for (let position = 1; position < elidedGroups - groups; position++) {
          possibilities.push((0, sprintf_js_1.sprintf)("(0{1,4}:){%d}:(0{1,4}:){%d}0{1,4}", position, elidedGroups - position - groups - 1));
        }
      }
      return groupPossibilities(possibilities);
    }
    exports2.possibleElisions = possibleElisions;
  }
});

// node_modules/ip-address/dist/ipv6.js
var require_ipv6 = __commonJS({
  "node_modules/ip-address/dist/ipv6.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m2, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m2, k);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m2, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m2[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Address6 = void 0;
    var common = __importStar(require_common2());
    var constants4 = __importStar(require_constants3());
    var constants6 = __importStar(require_constants4());
    var helpers = __importStar(require_helpers2());
    var ipv4_1 = require_ipv4();
    var regular_expressions_1 = require_regular_expressions();
    var address_error_1 = require_address_error();
    var jsbn_1 = require_jsbn();
    var sprintf_js_1 = require_sprintf();
    function assert(condition) {
      if (!condition) {
        throw new Error("Assertion failed.");
      }
    }
    function addCommas(number) {
      const r2 = /(\d+)(\d{3})/;
      while (r2.test(number)) {
        number = number.replace(r2, "$1,$2");
      }
      return number;
    }
    function spanLeadingZeroes4(n) {
      n = n.replace(/^(0{1,})([1-9]+)$/, '<span class="parse-error">$1</span>$2');
      n = n.replace(/^(0{1,})(0)$/, '<span class="parse-error">$1</span>$2');
      return n;
    }
    function compact(address, slice) {
      const s1 = [];
      const s2 = [];
      let i2;
      for (i2 = 0; i2 < address.length; i2++) {
        if (i2 < slice[0]) {
          s1.push(address[i2]);
        } else if (i2 > slice[1]) {
          s2.push(address[i2]);
        }
      }
      return s1.concat(["compact"]).concat(s2);
    }
    function paddedHex(octet) {
      return (0, sprintf_js_1.sprintf)("%04x", parseInt(octet, 16));
    }
    function unsignByte(b) {
      return b & 255;
    }
    var Address6 = class _Address6 {
      constructor(address, optionalGroups) {
        this.addressMinusSuffix = "";
        this.parsedSubnet = "";
        this.subnet = "/128";
        this.subnetMask = 128;
        this.v4 = false;
        this.zone = "";
        this.isInSubnet = common.isInSubnet;
        this.isCorrect = common.isCorrect(constants6.BITS);
        if (optionalGroups === void 0) {
          this.groups = constants6.GROUPS;
        } else {
          this.groups = optionalGroups;
        }
        this.address = address;
        const subnet = constants6.RE_SUBNET_STRING.exec(address);
        if (subnet) {
          this.parsedSubnet = subnet[0].replace("/", "");
          this.subnetMask = parseInt(this.parsedSubnet, 10);
          this.subnet = `/${this.subnetMask}`;
          if (Number.isNaN(this.subnetMask) || this.subnetMask < 0 || this.subnetMask > constants6.BITS) {
            throw new address_error_1.AddressError("Invalid subnet mask.");
          }
          address = address.replace(constants6.RE_SUBNET_STRING, "");
        } else if (/\//.test(address)) {
          throw new address_error_1.AddressError("Invalid subnet mask.");
        }
        const zone = constants6.RE_ZONE_STRING.exec(address);
        if (zone) {
          this.zone = zone[0];
          address = address.replace(constants6.RE_ZONE_STRING, "");
        }
        this.addressMinusSuffix = address;
        this.parsedAddress = this.parse(this.addressMinusSuffix);
      }
      static isValid(address) {
        try {
          new _Address6(address);
          return true;
        } catch (e2) {
          return false;
        }
      }
      /**
       * Convert a BigInteger to a v6 address object
       * @memberof Address6
       * @static
       * @param {BigInteger} bigInteger - a BigInteger to convert
       * @returns {Address6}
       * @example
       * var bigInteger = new BigInteger('1000000000000');
       * var address = Address6.fromBigInteger(bigInteger);
       * address.correctForm(); // '::e8:d4a5:1000'
       */
      static fromBigInteger(bigInteger) {
        const hex = bigInteger.toString(16).padStart(32, "0");
        const groups = [];
        let i2;
        for (i2 = 0; i2 < constants6.GROUPS; i2++) {
          groups.push(hex.slice(i2 * 4, (i2 + 1) * 4));
        }
        return new _Address6(groups.join(":"));
      }
      /**
       * Convert a URL (with optional port number) to an address object
       * @memberof Address6
       * @static
       * @param {string} url - a URL with optional port number
       * @example
       * var addressAndPort = Address6.fromURL('http://[ffff::]:8080/foo/');
       * addressAndPort.address.correctForm(); // 'ffff::'
       * addressAndPort.port; // 8080
       */
      static fromURL(url2) {
        let host;
        let port = null;
        let result;
        if (url2.indexOf("[") !== -1 && url2.indexOf("]:") !== -1) {
          result = constants6.RE_URL_WITH_PORT.exec(url2);
          if (result === null) {
            return {
              error: "failed to parse address with port",
              address: null,
              port: null
            };
          }
          host = result[1];
          port = result[2];
        } else if (url2.indexOf("/") !== -1) {
          url2 = url2.replace(/^[a-z0-9]+:\/\//, "");
          result = constants6.RE_URL.exec(url2);
          if (result === null) {
            return {
              error: "failed to parse address from URL",
              address: null,
              port: null
            };
          }
          host = result[1];
        } else {
          host = url2;
        }
        if (port) {
          port = parseInt(port, 10);
          if (port < 0 || port > 65536) {
            port = null;
          }
        } else {
          port = null;
        }
        return {
          address: new _Address6(host),
          port
        };
      }
      /**
       * Create an IPv6-mapped address given an IPv4 address
       * @memberof Address6
       * @static
       * @param {string} address - An IPv4 address string
       * @returns {Address6}
       * @example
       * var address = Address6.fromAddress4('192.168.0.1');
       * address.correctForm(); // '::ffff:c0a8:1'
       * address.to4in6(); // '::ffff:192.168.0.1'
       */
      static fromAddress4(address) {
        const address4 = new ipv4_1.Address4(address);
        const mask6 = constants6.BITS - (constants4.BITS - address4.subnetMask);
        return new _Address6(`::ffff:${address4.correctForm()}/${mask6}`);
      }
      /**
       * Return an address from ip6.arpa form
       * @memberof Address6
       * @static
       * @param {string} arpaFormAddress - an 'ip6.arpa' form address
       * @returns {Adress6}
       * @example
       * var address = Address6.fromArpa(e.f.f.f.3.c.2.6.f.f.f.e.6.6.8.e.1.0.6.7.9.4.e.c.0.0.0.0.1.0.0.2.ip6.arpa.)
       * address.correctForm(); // '2001:0:ce49:7601:e866:efff:62c3:fffe'
       */
      static fromArpa(arpaFormAddress) {
        let address = arpaFormAddress.replace(/(\.ip6\.arpa)?\.$/, "");
        const semicolonAmount = 7;
        if (address.length !== 63) {
          throw new address_error_1.AddressError("Invalid 'ip6.arpa' form.");
        }
        const parts = address.split(".").reverse();
        for (let i2 = semicolonAmount; i2 > 0; i2--) {
          const insertIndex = i2 * 4;
          parts.splice(insertIndex, 0, ":");
        }
        address = parts.join("");
        return new _Address6(address);
      }
      /**
       * Return the Microsoft UNC transcription of the address
       * @memberof Address6
       * @instance
       * @returns {String} the Microsoft UNC transcription of the address
       */
      microsoftTranscription() {
        return (0, sprintf_js_1.sprintf)("%s.ipv6-literal.net", this.correctForm().replace(/:/g, "-"));
      }
      /**
       * Return the first n bits of the address, defaulting to the subnet mask
       * @memberof Address6
       * @instance
       * @param {number} [mask=subnet] - the number of bits to mask
       * @returns {String} the first n bits of the address as a string
       */
      mask(mask = this.subnetMask) {
        return this.getBitsBase2(0, mask);
      }
      /**
       * Return the number of possible subnets of a given size in the address
       * @memberof Address6
       * @instance
       * @param {number} [size=128] - the subnet size
       * @returns {String}
       */
      // TODO: probably useful to have a numeric version of this too
      possibleSubnets(subnetSize = 128) {
        const availableBits = constants6.BITS - this.subnetMask;
        const subnetBits = Math.abs(subnetSize - constants6.BITS);
        const subnetPowers = availableBits - subnetBits;
        if (subnetPowers < 0) {
          return "0";
        }
        return addCommas(new jsbn_1.BigInteger("2", 10).pow(subnetPowers).toString(10));
      }
      /**
       * Helper function getting start address.
       * @memberof Address6
       * @instance
       * @returns {BigInteger}
       */
      _startAddress() {
        return new jsbn_1.BigInteger(this.mask() + "0".repeat(constants6.BITS - this.subnetMask), 2);
      }
      /**
       * The first address in the range given by this address' subnet
       * Often referred to as the Network Address.
       * @memberof Address6
       * @instance
       * @returns {Address6}
       */
      startAddress() {
        return _Address6.fromBigInteger(this._startAddress());
      }
      /**
       * The first host address in the range given by this address's subnet ie
       * the first address after the Network Address
       * @memberof Address6
       * @instance
       * @returns {Address6}
       */
      startAddressExclusive() {
        const adjust = new jsbn_1.BigInteger("1");
        return _Address6.fromBigInteger(this._startAddress().add(adjust));
      }
      /**
       * Helper function getting end address.
       * @memberof Address6
       * @instance
       * @returns {BigInteger}
       */
      _endAddress() {
        return new jsbn_1.BigInteger(this.mask() + "1".repeat(constants6.BITS - this.subnetMask), 2);
      }
      /**
       * The last address in the range given by this address' subnet
       * Often referred to as the Broadcast
       * @memberof Address6
       * @instance
       * @returns {Address6}
       */
      endAddress() {
        return _Address6.fromBigInteger(this._endAddress());
      }
      /**
       * The last host address in the range given by this address's subnet ie
       * the last address prior to the Broadcast Address
       * @memberof Address6
       * @instance
       * @returns {Address6}
       */
      endAddressExclusive() {
        const adjust = new jsbn_1.BigInteger("1");
        return _Address6.fromBigInteger(this._endAddress().subtract(adjust));
      }
      /**
       * Return the scope of the address
       * @memberof Address6
       * @instance
       * @returns {String}
       */
      getScope() {
        let scope = constants6.SCOPES[this.getBits(12, 16).intValue()];
        if (this.getType() === "Global unicast" && scope !== "Link local") {
          scope = "Global";
        }
        return scope || "Unknown";
      }
      /**
       * Return the type of the address
       * @memberof Address6
       * @instance
       * @returns {String}
       */
      getType() {
        for (const subnet of Object.keys(constants6.TYPES)) {
          if (this.isInSubnet(new _Address6(subnet))) {
            return constants6.TYPES[subnet];
          }
        }
        return "Global unicast";
      }
      /**
       * Return the bits in the given range as a BigInteger
       * @memberof Address6
       * @instance
       * @returns {BigInteger}
       */
      getBits(start, end) {
        return new jsbn_1.BigInteger(this.getBitsBase2(start, end), 2);
      }
      /**
       * Return the bits in the given range as a base-2 string
       * @memberof Address6
       * @instance
       * @returns {String}
       */
      getBitsBase2(start, end) {
        return this.binaryZeroPad().slice(start, end);
      }
      /**
       * Return the bits in the given range as a base-16 string
       * @memberof Address6
       * @instance
       * @returns {String}
       */
      getBitsBase16(start, end) {
        const length = end - start;
        if (length % 4 !== 0) {
          throw new Error("Length of bits to retrieve must be divisible by four");
        }
        return this.getBits(start, end).toString(16).padStart(length / 4, "0");
      }
      /**
       * Return the bits that are set past the subnet mask length
       * @memberof Address6
       * @instance
       * @returns {String}
       */
      getBitsPastSubnet() {
        return this.getBitsBase2(this.subnetMask, constants6.BITS);
      }
      /**
       * Return the reversed ip6.arpa form of the address
       * @memberof Address6
       * @param {Object} options
       * @param {boolean} options.omitSuffix - omit the "ip6.arpa" suffix
       * @instance
       * @returns {String}
       */
      reverseForm(options) {
        if (!options) {
          options = {};
        }
        const characters = Math.floor(this.subnetMask / 4);
        const reversed = this.canonicalForm().replace(/:/g, "").split("").slice(0, characters).reverse().join(".");
        if (characters > 0) {
          if (options.omitSuffix) {
            return reversed;
          }
          return (0, sprintf_js_1.sprintf)("%s.ip6.arpa.", reversed);
        }
        if (options.omitSuffix) {
          return "";
        }
        return "ip6.arpa.";
      }
      /**
       * Return the correct form of the address
       * @memberof Address6
       * @instance
       * @returns {String}
       */
      correctForm() {
        let i2;
        let groups = [];
        let zeroCounter = 0;
        const zeroes = [];
        for (i2 = 0; i2 < this.parsedAddress.length; i2++) {
          const value = parseInt(this.parsedAddress[i2], 16);
          if (value === 0) {
            zeroCounter++;
          }
          if (value !== 0 && zeroCounter > 0) {
            if (zeroCounter > 1) {
              zeroes.push([i2 - zeroCounter, i2 - 1]);
            }
            zeroCounter = 0;
          }
        }
        if (zeroCounter > 1) {
          zeroes.push([this.parsedAddress.length - zeroCounter, this.parsedAddress.length - 1]);
        }
        const zeroLengths = zeroes.map((n) => n[1] - n[0] + 1);
        if (zeroes.length > 0) {
          const index = zeroLengths.indexOf(Math.max(...zeroLengths));
          groups = compact(this.parsedAddress, zeroes[index]);
        } else {
          groups = this.parsedAddress;
        }
        for (i2 = 0; i2 < groups.length; i2++) {
          if (groups[i2] !== "compact") {
            groups[i2] = parseInt(groups[i2], 16).toString(16);
          }
        }
        let correct = groups.join(":");
        correct = correct.replace(/^compact$/, "::");
        correct = correct.replace(/^compact|compact$/, ":");
        correct = correct.replace(/compact/, "");
        return correct;
      }
      /**
       * Return a zero-padded base-2 string representation of the address
       * @memberof Address6
       * @instance
       * @returns {String}
       * @example
       * var address = new Address6('2001:4860:4001:803::1011');
       * address.binaryZeroPad();
       * // '0010000000000001010010000110000001000000000000010000100000000011
       * //  0000000000000000000000000000000000000000000000000001000000010001'
       */
      binaryZeroPad() {
        return this.bigInteger().toString(2).padStart(constants6.BITS, "0");
      }
      // TODO: Improve the semantics of this helper function
      parse4in6(address) {
        const groups = address.split(":");
        const lastGroup = groups.slice(-1)[0];
        const address4 = lastGroup.match(constants4.RE_ADDRESS);
        if (address4) {
          this.parsedAddress4 = address4[0];
          this.address4 = new ipv4_1.Address4(this.parsedAddress4);
          for (let i2 = 0; i2 < this.address4.groups; i2++) {
            if (/^0[0-9]+/.test(this.address4.parsedAddress[i2])) {
              throw new address_error_1.AddressError("IPv4 addresses can't have leading zeroes.", address.replace(constants4.RE_ADDRESS, this.address4.parsedAddress.map(spanLeadingZeroes4).join(".")));
            }
          }
          this.v4 = true;
          groups[groups.length - 1] = this.address4.toGroup6();
          address = groups.join(":");
        }
        return address;
      }
      // TODO: Make private?
      parse(address) {
        address = this.parse4in6(address);
        const badCharacters = address.match(constants6.RE_BAD_CHARACTERS);
        if (badCharacters) {
          throw new address_error_1.AddressError((0, sprintf_js_1.sprintf)("Bad character%s detected in address: %s", badCharacters.length > 1 ? "s" : "", badCharacters.join("")), address.replace(constants6.RE_BAD_CHARACTERS, '<span class="parse-error">$1</span>'));
        }
        const badAddress = address.match(constants6.RE_BAD_ADDRESS);
        if (badAddress) {
          throw new address_error_1.AddressError((0, sprintf_js_1.sprintf)("Address failed regex: %s", badAddress.join("")), address.replace(constants6.RE_BAD_ADDRESS, '<span class="parse-error">$1</span>'));
        }
        let groups = [];
        const halves = address.split("::");
        if (halves.length === 2) {
          let first = halves[0].split(":");
          let last = halves[1].split(":");
          if (first.length === 1 && first[0] === "") {
            first = [];
          }
          if (last.length === 1 && last[0] === "") {
            last = [];
          }
          const remaining = this.groups - (first.length + last.length);
          if (!remaining) {
            throw new address_error_1.AddressError("Error parsing groups");
          }
          this.elidedGroups = remaining;
          this.elisionBegin = first.length;
          this.elisionEnd = first.length + this.elidedGroups;
          groups = groups.concat(first);
          for (let i2 = 0; i2 < remaining; i2++) {
            groups.push("0");
          }
          groups = groups.concat(last);
        } else if (halves.length === 1) {
          groups = address.split(":");
          this.elidedGroups = 0;
        } else {
          throw new address_error_1.AddressError("Too many :: groups found");
        }
        groups = groups.map((group) => (0, sprintf_js_1.sprintf)("%x", parseInt(group, 16)));
        if (groups.length !== this.groups) {
          throw new address_error_1.AddressError("Incorrect number of groups found");
        }
        return groups;
      }
      /**
       * Return the canonical form of the address
       * @memberof Address6
       * @instance
       * @returns {String}
       */
      canonicalForm() {
        return this.parsedAddress.map(paddedHex).join(":");
      }
      /**
       * Return the decimal form of the address
       * @memberof Address6
       * @instance
       * @returns {String}
       */
      decimal() {
        return this.parsedAddress.map((n) => (0, sprintf_js_1.sprintf)("%05d", parseInt(n, 16))).join(":");
      }
      /**
       * Return the address as a BigInteger
       * @memberof Address6
       * @instance
       * @returns {BigInteger}
       */
      bigInteger() {
        return new jsbn_1.BigInteger(this.parsedAddress.map(paddedHex).join(""), 16);
      }
      /**
       * Return the last two groups of this address as an IPv4 address string
       * @memberof Address6
       * @instance
       * @returns {Address4}
       * @example
       * var address = new Address6('2001:4860:4001::1825:bf11');
       * address.to4().correctForm(); // '24.37.191.17'
       */
      to4() {
        const binary = this.binaryZeroPad().split("");
        return ipv4_1.Address4.fromHex(new jsbn_1.BigInteger(binary.slice(96, 128).join(""), 2).toString(16));
      }
      /**
       * Return the v4-in-v6 form of the address
       * @memberof Address6
       * @instance
       * @returns {String}
       */
      to4in6() {
        const address4 = this.to4();
        const address6 = new _Address6(this.parsedAddress.slice(0, 6).join(":"), 6);
        const correct = address6.correctForm();
        let infix = "";
        if (!/:$/.test(correct)) {
          infix = ":";
        }
        return correct + infix + address4.address;
      }
      /**
       * Return an object containing the Teredo properties of the address
       * @memberof Address6
       * @instance
       * @returns {Object}
       */
      inspectTeredo() {
        const prefix = this.getBitsBase16(0, 32);
        const udpPort = this.getBits(80, 96).xor(new jsbn_1.BigInteger("ffff", 16)).toString();
        const server4 = ipv4_1.Address4.fromHex(this.getBitsBase16(32, 64));
        const client4 = ipv4_1.Address4.fromHex(this.getBits(96, 128).xor(new jsbn_1.BigInteger("ffffffff", 16)).toString(16));
        const flags = this.getBits(64, 80);
        const flagsBase2 = this.getBitsBase2(64, 80);
        const coneNat = flags.testBit(15);
        const reserved = flags.testBit(14);
        const groupIndividual = flags.testBit(8);
        const universalLocal = flags.testBit(9);
        const nonce = new jsbn_1.BigInteger(flagsBase2.slice(2, 6) + flagsBase2.slice(8, 16), 2).toString(10);
        return {
          prefix: (0, sprintf_js_1.sprintf)("%s:%s", prefix.slice(0, 4), prefix.slice(4, 8)),
          server4: server4.address,
          client4: client4.address,
          flags: flagsBase2,
          coneNat,
          microsoft: {
            reserved,
            universalLocal,
            groupIndividual,
            nonce
          },
          udpPort
        };
      }
      /**
       * Return an object containing the 6to4 properties of the address
       * @memberof Address6
       * @instance
       * @returns {Object}
       */
      inspect6to4() {
        const prefix = this.getBitsBase16(0, 16);
        const gateway = ipv4_1.Address4.fromHex(this.getBitsBase16(16, 48));
        return {
          prefix: (0, sprintf_js_1.sprintf)("%s", prefix.slice(0, 4)),
          gateway: gateway.address
        };
      }
      /**
       * Return a v6 6to4 address from a v6 v4inv6 address
       * @memberof Address6
       * @instance
       * @returns {Address6}
       */
      to6to4() {
        if (!this.is4()) {
          return null;
        }
        const addr6to4 = [
          "2002",
          this.getBitsBase16(96, 112),
          this.getBitsBase16(112, 128),
          "",
          "/16"
        ].join(":");
        return new _Address6(addr6to4);
      }
      /**
       * Return a byte array
       * @memberof Address6
       * @instance
       * @returns {Array}
       */
      toByteArray() {
        const byteArray = this.bigInteger().toByteArray();
        if (byteArray.length === 17 && byteArray[0] === 0) {
          return byteArray.slice(1);
        }
        return byteArray;
      }
      /**
       * Return an unsigned byte array
       * @memberof Address6
       * @instance
       * @returns {Array}
       */
      toUnsignedByteArray() {
        return this.toByteArray().map(unsignByte);
      }
      /**
       * Convert a byte array to an Address6 object
       * @memberof Address6
       * @static
       * @returns {Address6}
       */
      static fromByteArray(bytes) {
        return this.fromUnsignedByteArray(bytes.map(unsignByte));
      }
      /**
       * Convert an unsigned byte array to an Address6 object
       * @memberof Address6
       * @static
       * @returns {Address6}
       */
      static fromUnsignedByteArray(bytes) {
        const BYTE_MAX = new jsbn_1.BigInteger("256", 10);
        let result = new jsbn_1.BigInteger("0", 10);
        let multiplier = new jsbn_1.BigInteger("1", 10);
        for (let i2 = bytes.length - 1; i2 >= 0; i2--) {
          result = result.add(multiplier.multiply(new jsbn_1.BigInteger(bytes[i2].toString(10), 10)));
          multiplier = multiplier.multiply(BYTE_MAX);
        }
        return _Address6.fromBigInteger(result);
      }
      /**
       * Returns true if the address is in the canonical form, false otherwise
       * @memberof Address6
       * @instance
       * @returns {boolean}
       */
      isCanonical() {
        return this.addressMinusSuffix === this.canonicalForm();
      }
      /**
       * Returns true if the address is a link local address, false otherwise
       * @memberof Address6
       * @instance
       * @returns {boolean}
       */
      isLinkLocal() {
        if (this.getBitsBase2(0, 64) === "1111111010000000000000000000000000000000000000000000000000000000") {
          return true;
        }
        return false;
      }
      /**
       * Returns true if the address is a multicast address, false otherwise
       * @memberof Address6
       * @instance
       * @returns {boolean}
       */
      isMulticast() {
        return this.getType() === "Multicast";
      }
      /**
       * Returns true if the address is a v4-in-v6 address, false otherwise
       * @memberof Address6
       * @instance
       * @returns {boolean}
       */
      is4() {
        return this.v4;
      }
      /**
       * Returns true if the address is a Teredo address, false otherwise
       * @memberof Address6
       * @instance
       * @returns {boolean}
       */
      isTeredo() {
        return this.isInSubnet(new _Address6("2001::/32"));
      }
      /**
       * Returns true if the address is a 6to4 address, false otherwise
       * @memberof Address6
       * @instance
       * @returns {boolean}
       */
      is6to4() {
        return this.isInSubnet(new _Address6("2002::/16"));
      }
      /**
       * Returns true if the address is a loopback address, false otherwise
       * @memberof Address6
       * @instance
       * @returns {boolean}
       */
      isLoopback() {
        return this.getType() === "Loopback";
      }
      // #endregion
      // #region HTML
      /**
       * @returns {String} the address in link form with a default port of 80
       */
      href(optionalPort) {
        if (optionalPort === void 0) {
          optionalPort = "";
        } else {
          optionalPort = (0, sprintf_js_1.sprintf)(":%s", optionalPort);
        }
        return (0, sprintf_js_1.sprintf)("http://[%s]%s/", this.correctForm(), optionalPort);
      }
      /**
       * @returns {String} a link suitable for conveying the address via a URL hash
       */
      link(options) {
        if (!options) {
          options = {};
        }
        if (options.className === void 0) {
          options.className = "";
        }
        if (options.prefix === void 0) {
          options.prefix = "/#address=";
        }
        if (options.v4 === void 0) {
          options.v4 = false;
        }
        let formFunction = this.correctForm;
        if (options.v4) {
          formFunction = this.to4in6;
        }
        if (options.className) {
          return (0, sprintf_js_1.sprintf)('<a href="%1$s%2$s" class="%3$s">%2$s</a>', options.prefix, formFunction.call(this), options.className);
        }
        return (0, sprintf_js_1.sprintf)('<a href="%1$s%2$s">%2$s</a>', options.prefix, formFunction.call(this));
      }
      /**
       * Groups an address
       * @returns {String}
       */
      group() {
        if (this.elidedGroups === 0) {
          return helpers.simpleGroup(this.address).join(":");
        }
        assert(typeof this.elidedGroups === "number");
        assert(typeof this.elisionBegin === "number");
        const output = [];
        const [left, right] = this.address.split("::");
        if (left.length) {
          output.push(...helpers.simpleGroup(left));
        } else {
          output.push("");
        }
        const classes = ["hover-group"];
        for (let i2 = this.elisionBegin; i2 < this.elisionBegin + this.elidedGroups; i2++) {
          classes.push((0, sprintf_js_1.sprintf)("group-%d", i2));
        }
        output.push((0, sprintf_js_1.sprintf)('<span class="%s"></span>', classes.join(" ")));
        if (right.length) {
          output.push(...helpers.simpleGroup(right, this.elisionEnd));
        } else {
          output.push("");
        }
        if (this.is4()) {
          assert(this.address4 instanceof ipv4_1.Address4);
          output.pop();
          output.push(this.address4.groupForV6());
        }
        return output.join(":");
      }
      // #endregion
      // #region Regular expressions
      /**
       * Generate a regular expression string that can be used to find or validate
       * all variations of this address
       * @memberof Address6
       * @instance
       * @param {boolean} substringSearch
       * @returns {string}
       */
      regularExpressionString(substringSearch = false) {
        let output = [];
        const address6 = new _Address6(this.correctForm());
        if (address6.elidedGroups === 0) {
          output.push((0, regular_expressions_1.simpleRegularExpression)(address6.parsedAddress));
        } else if (address6.elidedGroups === constants6.GROUPS) {
          output.push((0, regular_expressions_1.possibleElisions)(constants6.GROUPS));
        } else {
          const halves = address6.address.split("::");
          if (halves[0].length) {
            output.push((0, regular_expressions_1.simpleRegularExpression)(halves[0].split(":")));
          }
          assert(typeof address6.elidedGroups === "number");
          output.push((0, regular_expressions_1.possibleElisions)(address6.elidedGroups, halves[0].length !== 0, halves[1].length !== 0));
          if (halves[1].length) {
            output.push((0, regular_expressions_1.simpleRegularExpression)(halves[1].split(":")));
          }
          output = [output.join(":")];
        }
        if (!substringSearch) {
          output = [
            "(?=^|",
            regular_expressions_1.ADDRESS_BOUNDARY,
            "|[^\\w\\:])(",
            ...output,
            ")(?=[^\\w\\:]|",
            regular_expressions_1.ADDRESS_BOUNDARY,
            "|$)"
          ];
        }
        return output.join("");
      }
      /**
       * Generate a regular expression that can be used to find or validate all
       * variations of this address.
       * @memberof Address6
       * @instance
       * @param {boolean} substringSearch
       * @returns {RegExp}
       */
      regularExpression(substringSearch = false) {
        return new RegExp(this.regularExpressionString(substringSearch), "i");
      }
    };
    exports2.Address6 = Address6;
  }
});

// node_modules/ip-address/dist/ip-address.js
var require_ip_address = __commonJS({
  "node_modules/ip-address/dist/ip-address.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m2, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m2, k);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m2, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m2[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.v6 = exports2.AddressError = exports2.Address6 = exports2.Address4 = void 0;
    var ipv4_1 = require_ipv4();
    Object.defineProperty(exports2, "Address4", { enumerable: true, get: function() {
      return ipv4_1.Address4;
    } });
    var ipv6_1 = require_ipv6();
    Object.defineProperty(exports2, "Address6", { enumerable: true, get: function() {
      return ipv6_1.Address6;
    } });
    var address_error_1 = require_address_error();
    Object.defineProperty(exports2, "AddressError", { enumerable: true, get: function() {
      return address_error_1.AddressError;
    } });
    var helpers = __importStar(require_helpers2());
    exports2.v6 = { helpers };
  }
});

// node_modules/socks/build/common/helpers.js
var require_helpers3 = __commonJS({
  "node_modules/socks/build/common/helpers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ipToBuffer = exports2.int32ToIpv4 = exports2.ipv4ToInt32 = exports2.validateSocksClientChainOptions = exports2.validateSocksClientOptions = void 0;
    var util_1 = require_util();
    var constants_1 = require_constants2();
    var stream = require("stream");
    var ip_address_1 = require_ip_address();
    var net = require("net");
    function validateSocksClientOptions(options, acceptedCommands = ["connect", "bind", "associate"]) {
      if (!constants_1.SocksCommand[options.command]) {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksCommand, options);
      }
      if (acceptedCommands.indexOf(options.command) === -1) {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksCommandForOperation, options);
      }
      if (!isValidSocksRemoteHost(options.destination)) {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsDestination, options);
      }
      if (!isValidSocksProxy(options.proxy)) {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsProxy, options);
      }
      validateCustomProxyAuth(options.proxy, options);
      if (options.timeout && !isValidTimeoutValue(options.timeout)) {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsTimeout, options);
      }
      if (options.existing_socket && !(options.existing_socket instanceof stream.Duplex)) {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsExistingSocket, options);
      }
    }
    exports2.validateSocksClientOptions = validateSocksClientOptions;
    function validateSocksClientChainOptions(options) {
      if (options.command !== "connect") {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksCommandChain, options);
      }
      if (!isValidSocksRemoteHost(options.destination)) {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsDestination, options);
      }
      if (!(options.proxies && Array.isArray(options.proxies) && options.proxies.length >= 2)) {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsProxiesLength, options);
      }
      options.proxies.forEach((proxy) => {
        if (!isValidSocksProxy(proxy)) {
          throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsProxy, options);
        }
        validateCustomProxyAuth(proxy, options);
      });
      if (options.timeout && !isValidTimeoutValue(options.timeout)) {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsTimeout, options);
      }
    }
    exports2.validateSocksClientChainOptions = validateSocksClientChainOptions;
    function validateCustomProxyAuth(proxy, options) {
      if (proxy.custom_auth_method !== void 0) {
        if (proxy.custom_auth_method < constants_1.SOCKS5_CUSTOM_AUTH_START || proxy.custom_auth_method > constants_1.SOCKS5_CUSTOM_AUTH_END) {
          throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsCustomAuthRange, options);
        }
        if (proxy.custom_auth_request_handler === void 0 || typeof proxy.custom_auth_request_handler !== "function") {
          throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsCustomAuthOptions, options);
        }
        if (proxy.custom_auth_response_size === void 0) {
          throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsCustomAuthOptions, options);
        }
        if (proxy.custom_auth_response_handler === void 0 || typeof proxy.custom_auth_response_handler !== "function") {
          throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsCustomAuthOptions, options);
        }
      }
    }
    function isValidSocksRemoteHost(remoteHost) {
      return remoteHost && typeof remoteHost.host === "string" && typeof remoteHost.port === "number" && remoteHost.port >= 0 && remoteHost.port <= 65535;
    }
    function isValidSocksProxy(proxy) {
      return proxy && (typeof proxy.host === "string" || typeof proxy.ipaddress === "string") && typeof proxy.port === "number" && proxy.port >= 0 && proxy.port <= 65535 && (proxy.type === 4 || proxy.type === 5);
    }
    function isValidTimeoutValue(value) {
      return typeof value === "number" && value > 0;
    }
    function ipv4ToInt32(ip) {
      const address = new ip_address_1.Address4(ip);
      return address.toArray().reduce((acc, part) => (acc << 8) + part, 0);
    }
    exports2.ipv4ToInt32 = ipv4ToInt32;
    function int32ToIpv4(int32) {
      const octet1 = int32 >>> 24 & 255;
      const octet2 = int32 >>> 16 & 255;
      const octet3 = int32 >>> 8 & 255;
      const octet4 = int32 & 255;
      return [octet1, octet2, octet3, octet4].join(".");
    }
    exports2.int32ToIpv4 = int32ToIpv4;
    function ipToBuffer(ip) {
      if (net.isIPv4(ip)) {
        const address = new ip_address_1.Address4(ip);
        return Buffer.from(address.toArray());
      } else if (net.isIPv6(ip)) {
        const address = new ip_address_1.Address6(ip);
        return Buffer.from(address.canonicalForm().split(":").map((segment) => segment.padStart(4, "0")).join(""), "hex");
      } else {
        throw new Error("Invalid IP address format");
      }
    }
    exports2.ipToBuffer = ipToBuffer;
  }
});

// node_modules/socks/build/common/receivebuffer.js
var require_receivebuffer = __commonJS({
  "node_modules/socks/build/common/receivebuffer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ReceiveBuffer = void 0;
    var ReceiveBuffer = class {
      constructor(size = 4096) {
        this.buffer = Buffer.allocUnsafe(size);
        this.offset = 0;
        this.originalSize = size;
      }
      get length() {
        return this.offset;
      }
      append(data) {
        if (!Buffer.isBuffer(data)) {
          throw new Error("Attempted to append a non-buffer instance to ReceiveBuffer.");
        }
        if (this.offset + data.length >= this.buffer.length) {
          const tmp = this.buffer;
          this.buffer = Buffer.allocUnsafe(Math.max(this.buffer.length + this.originalSize, this.buffer.length + data.length));
          tmp.copy(this.buffer);
        }
        data.copy(this.buffer, this.offset);
        return this.offset += data.length;
      }
      peek(length) {
        if (length > this.offset) {
          throw new Error("Attempted to read beyond the bounds of the managed internal data.");
        }
        return this.buffer.slice(0, length);
      }
      get(length) {
        if (length > this.offset) {
          throw new Error("Attempted to read beyond the bounds of the managed internal data.");
        }
        const value = Buffer.allocUnsafe(length);
        this.buffer.slice(0, length).copy(value);
        this.buffer.copyWithin(0, length, length + this.offset - length);
        this.offset -= length;
        return value;
      }
    };
    exports2.ReceiveBuffer = ReceiveBuffer;
  }
});

// node_modules/socks/build/client/socksclient.js
var require_socksclient = __commonJS({
  "node_modules/socks/build/client/socksclient.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SocksClientError = exports2.SocksClient = void 0;
    var events_1 = require("events");
    var net = require("net");
    var smart_buffer_1 = require_smartbuffer();
    var constants_1 = require_constants2();
    var helpers_1 = require_helpers3();
    var receivebuffer_1 = require_receivebuffer();
    var util_1 = require_util();
    Object.defineProperty(exports2, "SocksClientError", { enumerable: true, get: function() {
      return util_1.SocksClientError;
    } });
    var ip_address_1 = require_ip_address();
    var SocksClient = class _SocksClient extends events_1.EventEmitter {
      constructor(options) {
        super();
        this.options = Object.assign({}, options);
        (0, helpers_1.validateSocksClientOptions)(options);
        this.setState(constants_1.SocksClientState.Created);
      }
      /**
       * Creates a new SOCKS connection.
       *
       * Note: Supports callbacks and promises. Only supports the connect command.
       * @param options { SocksClientOptions } Options.
       * @param callback { Function } An optional callback function.
       * @returns { Promise }
       */
      static createConnection(options, callback) {
        return new Promise((resolve, reject) => {
          try {
            (0, helpers_1.validateSocksClientOptions)(options, ["connect"]);
          } catch (err) {
            if (typeof callback === "function") {
              callback(err);
              return resolve(err);
            } else {
              return reject(err);
            }
          }
          const client = new _SocksClient(options);
          client.connect(options.existing_socket);
          client.once("established", (info) => {
            client.removeAllListeners();
            if (typeof callback === "function") {
              callback(null, info);
              resolve(info);
            } else {
              resolve(info);
            }
          });
          client.once("error", (err) => {
            client.removeAllListeners();
            if (typeof callback === "function") {
              callback(err);
              resolve(err);
            } else {
              reject(err);
            }
          });
        });
      }
      /**
       * Creates a new SOCKS connection chain to a destination host through 2 or more SOCKS proxies.
       *
       * Note: Supports callbacks and promises. Only supports the connect method.
       * Note: Implemented via createConnection() factory function.
       * @param options { SocksClientChainOptions } Options
       * @param callback { Function } An optional callback function.
       * @returns { Promise }
       */
      static createConnectionChain(options, callback) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
          try {
            (0, helpers_1.validateSocksClientChainOptions)(options);
          } catch (err) {
            if (typeof callback === "function") {
              callback(err);
              return resolve(err);
            } else {
              return reject(err);
            }
          }
          if (options.randomizeChain) {
            (0, util_1.shuffleArray)(options.proxies);
          }
          try {
            let sock;
            for (let i2 = 0; i2 < options.proxies.length; i2++) {
              const nextProxy = options.proxies[i2];
              const nextDestination = i2 === options.proxies.length - 1 ? options.destination : {
                host: options.proxies[i2 + 1].host || options.proxies[i2 + 1].ipaddress,
                port: options.proxies[i2 + 1].port
              };
              const result = yield _SocksClient.createConnection({
                command: "connect",
                proxy: nextProxy,
                destination: nextDestination,
                existing_socket: sock
              });
              sock = sock || result.socket;
            }
            if (typeof callback === "function") {
              callback(null, { socket: sock });
              resolve({ socket: sock });
            } else {
              resolve({ socket: sock });
            }
          } catch (err) {
            if (typeof callback === "function") {
              callback(err);
              resolve(err);
            } else {
              reject(err);
            }
          }
        }));
      }
      /**
       * Creates a SOCKS UDP Frame.
       * @param options
       */
      static createUDPFrame(options) {
        const buff = new smart_buffer_1.SmartBuffer();
        buff.writeUInt16BE(0);
        buff.writeUInt8(options.frameNumber || 0);
        if (net.isIPv4(options.remoteHost.host)) {
          buff.writeUInt8(constants_1.Socks5HostType.IPv4);
          buff.writeUInt32BE((0, helpers_1.ipv4ToInt32)(options.remoteHost.host));
        } else if (net.isIPv6(options.remoteHost.host)) {
          buff.writeUInt8(constants_1.Socks5HostType.IPv6);
          buff.writeBuffer((0, helpers_1.ipToBuffer)(options.remoteHost.host));
        } else {
          buff.writeUInt8(constants_1.Socks5HostType.Hostname);
          buff.writeUInt8(Buffer.byteLength(options.remoteHost.host));
          buff.writeString(options.remoteHost.host);
        }
        buff.writeUInt16BE(options.remoteHost.port);
        buff.writeBuffer(options.data);
        return buff.toBuffer();
      }
      /**
       * Parses a SOCKS UDP frame.
       * @param data
       */
      static parseUDPFrame(data) {
        const buff = smart_buffer_1.SmartBuffer.fromBuffer(data);
        buff.readOffset = 2;
        const frameNumber = buff.readUInt8();
        const hostType = buff.readUInt8();
        let remoteHost;
        if (hostType === constants_1.Socks5HostType.IPv4) {
          remoteHost = (0, helpers_1.int32ToIpv4)(buff.readUInt32BE());
        } else if (hostType === constants_1.Socks5HostType.IPv6) {
          remoteHost = ip_address_1.Address6.fromByteArray(Array.from(buff.readBuffer(16))).canonicalForm();
        } else {
          remoteHost = buff.readString(buff.readUInt8());
        }
        const remotePort = buff.readUInt16BE();
        return {
          frameNumber,
          remoteHost: {
            host: remoteHost,
            port: remotePort
          },
          data: buff.readBuffer()
        };
      }
      /**
       * Internal state setter. If the SocksClient is in an error state, it cannot be changed to a non error state.
       */
      setState(newState) {
        if (this.state !== constants_1.SocksClientState.Error) {
          this.state = newState;
        }
      }
      /**
       * Starts the connection establishment to the proxy and destination.
       * @param existingSocket Connected socket to use instead of creating a new one (internal use).
       */
      connect(existingSocket) {
        this.onDataReceived = (data) => this.onDataReceivedHandler(data);
        this.onClose = () => this.onCloseHandler();
        this.onError = (err) => this.onErrorHandler(err);
        this.onConnect = () => this.onConnectHandler();
        const timer = setTimeout(() => this.onEstablishedTimeout(), this.options.timeout || constants_1.DEFAULT_TIMEOUT);
        if (timer.unref && typeof timer.unref === "function") {
          timer.unref();
        }
        if (existingSocket) {
          this.socket = existingSocket;
        } else {
          this.socket = new net.Socket();
        }
        this.socket.once("close", this.onClose);
        this.socket.once("error", this.onError);
        this.socket.once("connect", this.onConnect);
        this.socket.on("data", this.onDataReceived);
        this.setState(constants_1.SocksClientState.Connecting);
        this.receiveBuffer = new receivebuffer_1.ReceiveBuffer();
        if (existingSocket) {
          this.socket.emit("connect");
        } else {
          this.socket.connect(this.getSocketOptions());
          if (this.options.set_tcp_nodelay !== void 0 && this.options.set_tcp_nodelay !== null) {
            this.socket.setNoDelay(!!this.options.set_tcp_nodelay);
          }
        }
        this.prependOnceListener("established", (info) => {
          setImmediate(() => {
            if (this.receiveBuffer.length > 0) {
              const excessData = this.receiveBuffer.get(this.receiveBuffer.length);
              info.socket.emit("data", excessData);
            }
            info.socket.resume();
          });
        });
      }
      // Socket options (defaults host/port to options.proxy.host/options.proxy.port)
      getSocketOptions() {
        return Object.assign(Object.assign({}, this.options.socket_options), { host: this.options.proxy.host || this.options.proxy.ipaddress, port: this.options.proxy.port });
      }
      /**
       * Handles internal Socks timeout callback.
       * Note: If the Socks client is not BoundWaitingForConnection or Established, the connection will be closed.
       */
      onEstablishedTimeout() {
        if (this.state !== constants_1.SocksClientState.Established && this.state !== constants_1.SocksClientState.BoundWaitingForConnection) {
          this.closeSocket(constants_1.ERRORS.ProxyConnectionTimedOut);
        }
      }
      /**
       * Handles Socket connect event.
       */
      onConnectHandler() {
        this.setState(constants_1.SocksClientState.Connected);
        if (this.options.proxy.type === 4) {
          this.sendSocks4InitialHandshake();
        } else {
          this.sendSocks5InitialHandshake();
        }
        this.setState(constants_1.SocksClientState.SentInitialHandshake);
      }
      /**
       * Handles Socket data event.
       * @param data
       */
      onDataReceivedHandler(data) {
        this.receiveBuffer.append(data);
        this.processData();
      }
      /**
       * Handles processing of the data we have received.
       */
      processData() {
        while (this.state !== constants_1.SocksClientState.Established && this.state !== constants_1.SocksClientState.Error && this.receiveBuffer.length >= this.nextRequiredPacketBufferSize) {
          if (this.state === constants_1.SocksClientState.SentInitialHandshake) {
            if (this.options.proxy.type === 4) {
              this.handleSocks4FinalHandshakeResponse();
            } else {
              this.handleInitialSocks5HandshakeResponse();
            }
          } else if (this.state === constants_1.SocksClientState.SentAuthentication) {
            this.handleInitialSocks5AuthenticationHandshakeResponse();
          } else if (this.state === constants_1.SocksClientState.SentFinalHandshake) {
            this.handleSocks5FinalHandshakeResponse();
          } else if (this.state === constants_1.SocksClientState.BoundWaitingForConnection) {
            if (this.options.proxy.type === 4) {
              this.handleSocks4IncomingConnectionResponse();
            } else {
              this.handleSocks5IncomingConnectionResponse();
            }
          } else {
            this.closeSocket(constants_1.ERRORS.InternalError);
            break;
          }
        }
      }
      /**
       * Handles Socket close event.
       * @param had_error
       */
      onCloseHandler() {
        this.closeSocket(constants_1.ERRORS.SocketClosed);
      }
      /**
       * Handles Socket error event.
       * @param err
       */
      onErrorHandler(err) {
        this.closeSocket(err.message);
      }
      /**
       * Removes internal event listeners on the underlying Socket.
       */
      removeInternalSocketHandlers() {
        this.socket.pause();
        this.socket.removeListener("data", this.onDataReceived);
        this.socket.removeListener("close", this.onClose);
        this.socket.removeListener("error", this.onError);
        this.socket.removeListener("connect", this.onConnect);
      }
      /**
       * Closes and destroys the underlying Socket. Emits an error event.
       * @param err { String } An error string to include in error event.
       */
      closeSocket(err) {
        if (this.state !== constants_1.SocksClientState.Error) {
          this.setState(constants_1.SocksClientState.Error);
          this.socket.destroy();
          this.removeInternalSocketHandlers();
          this.emit("error", new util_1.SocksClientError(err, this.options));
        }
      }
      /**
       * Sends initial Socks v4 handshake request.
       */
      sendSocks4InitialHandshake() {
        const userId = this.options.proxy.userId || "";
        const buff = new smart_buffer_1.SmartBuffer();
        buff.writeUInt8(4);
        buff.writeUInt8(constants_1.SocksCommand[this.options.command]);
        buff.writeUInt16BE(this.options.destination.port);
        if (net.isIPv4(this.options.destination.host)) {
          buff.writeBuffer((0, helpers_1.ipToBuffer)(this.options.destination.host));
          buff.writeStringNT(userId);
        } else {
          buff.writeUInt8(0);
          buff.writeUInt8(0);
          buff.writeUInt8(0);
          buff.writeUInt8(1);
          buff.writeStringNT(userId);
          buff.writeStringNT(this.options.destination.host);
        }
        this.nextRequiredPacketBufferSize = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks4Response;
        this.socket.write(buff.toBuffer());
      }
      /**
       * Handles Socks v4 handshake response.
       * @param data
       */
      handleSocks4FinalHandshakeResponse() {
        const data = this.receiveBuffer.get(8);
        if (data[1] !== constants_1.Socks4Response.Granted) {
          this.closeSocket(`${constants_1.ERRORS.Socks4ProxyRejectedConnection} - (${constants_1.Socks4Response[data[1]]})`);
        } else {
          if (constants_1.SocksCommand[this.options.command] === constants_1.SocksCommand.bind) {
            const buff = smart_buffer_1.SmartBuffer.fromBuffer(data);
            buff.readOffset = 2;
            const remoteHost = {
              port: buff.readUInt16BE(),
              host: (0, helpers_1.int32ToIpv4)(buff.readUInt32BE())
            };
            if (remoteHost.host === "0.0.0.0") {
              remoteHost.host = this.options.proxy.ipaddress;
            }
            this.setState(constants_1.SocksClientState.BoundWaitingForConnection);
            this.emit("bound", { remoteHost, socket: this.socket });
          } else {
            this.setState(constants_1.SocksClientState.Established);
            this.removeInternalSocketHandlers();
            this.emit("established", { socket: this.socket });
          }
        }
      }
      /**
       * Handles Socks v4 incoming connection request (BIND)
       * @param data
       */
      handleSocks4IncomingConnectionResponse() {
        const data = this.receiveBuffer.get(8);
        if (data[1] !== constants_1.Socks4Response.Granted) {
          this.closeSocket(`${constants_1.ERRORS.Socks4ProxyRejectedIncomingBoundConnection} - (${constants_1.Socks4Response[data[1]]})`);
        } else {
          const buff = smart_buffer_1.SmartBuffer.fromBuffer(data);
          buff.readOffset = 2;
          const remoteHost = {
            port: buff.readUInt16BE(),
            host: (0, helpers_1.int32ToIpv4)(buff.readUInt32BE())
          };
          this.setState(constants_1.SocksClientState.Established);
          this.removeInternalSocketHandlers();
          this.emit("established", { remoteHost, socket: this.socket });
        }
      }
      /**
       * Sends initial Socks v5 handshake request.
       */
      sendSocks5InitialHandshake() {
        const buff = new smart_buffer_1.SmartBuffer();
        const supportedAuthMethods = [constants_1.Socks5Auth.NoAuth];
        if (this.options.proxy.userId || this.options.proxy.password) {
          supportedAuthMethods.push(constants_1.Socks5Auth.UserPass);
        }
        if (this.options.proxy.custom_auth_method !== void 0) {
          supportedAuthMethods.push(this.options.proxy.custom_auth_method);
        }
        buff.writeUInt8(5);
        buff.writeUInt8(supportedAuthMethods.length);
        for (const authMethod of supportedAuthMethods) {
          buff.writeUInt8(authMethod);
        }
        this.nextRequiredPacketBufferSize = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5InitialHandshakeResponse;
        this.socket.write(buff.toBuffer());
        this.setState(constants_1.SocksClientState.SentInitialHandshake);
      }
      /**
       * Handles initial Socks v5 handshake response.
       * @param data
       */
      handleInitialSocks5HandshakeResponse() {
        const data = this.receiveBuffer.get(2);
        if (data[0] !== 5) {
          this.closeSocket(constants_1.ERRORS.InvalidSocks5IntiailHandshakeSocksVersion);
        } else if (data[1] === constants_1.SOCKS5_NO_ACCEPTABLE_AUTH) {
          this.closeSocket(constants_1.ERRORS.InvalidSocks5InitialHandshakeNoAcceptedAuthType);
        } else {
          if (data[1] === constants_1.Socks5Auth.NoAuth) {
            this.socks5ChosenAuthType = constants_1.Socks5Auth.NoAuth;
            this.sendSocks5CommandRequest();
          } else if (data[1] === constants_1.Socks5Auth.UserPass) {
            this.socks5ChosenAuthType = constants_1.Socks5Auth.UserPass;
            this.sendSocks5UserPassAuthentication();
          } else if (data[1] === this.options.proxy.custom_auth_method) {
            this.socks5ChosenAuthType = this.options.proxy.custom_auth_method;
            this.sendSocks5CustomAuthentication();
          } else {
            this.closeSocket(constants_1.ERRORS.InvalidSocks5InitialHandshakeUnknownAuthType);
          }
        }
      }
      /**
       * Sends Socks v5 user & password auth handshake.
       *
       * Note: No auth and user/pass are currently supported.
       */
      sendSocks5UserPassAuthentication() {
        const userId = this.options.proxy.userId || "";
        const password = this.options.proxy.password || "";
        const buff = new smart_buffer_1.SmartBuffer();
        buff.writeUInt8(1);
        buff.writeUInt8(Buffer.byteLength(userId));
        buff.writeString(userId);
        buff.writeUInt8(Buffer.byteLength(password));
        buff.writeString(password);
        this.nextRequiredPacketBufferSize = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5UserPassAuthenticationResponse;
        this.socket.write(buff.toBuffer());
        this.setState(constants_1.SocksClientState.SentAuthentication);
      }
      sendSocks5CustomAuthentication() {
        return __awaiter(this, void 0, void 0, function* () {
          this.nextRequiredPacketBufferSize = this.options.proxy.custom_auth_response_size;
          this.socket.write(yield this.options.proxy.custom_auth_request_handler());
          this.setState(constants_1.SocksClientState.SentAuthentication);
        });
      }
      handleSocks5CustomAuthHandshakeResponse(data) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.options.proxy.custom_auth_response_handler(data);
        });
      }
      handleSocks5AuthenticationNoAuthHandshakeResponse(data) {
        return __awaiter(this, void 0, void 0, function* () {
          return data[1] === 0;
        });
      }
      handleSocks5AuthenticationUserPassHandshakeResponse(data) {
        return __awaiter(this, void 0, void 0, function* () {
          return data[1] === 0;
        });
      }
      /**
       * Handles Socks v5 auth handshake response.
       * @param data
       */
      handleInitialSocks5AuthenticationHandshakeResponse() {
        return __awaiter(this, void 0, void 0, function* () {
          this.setState(constants_1.SocksClientState.ReceivedAuthenticationResponse);
          let authResult = false;
          if (this.socks5ChosenAuthType === constants_1.Socks5Auth.NoAuth) {
            authResult = yield this.handleSocks5AuthenticationNoAuthHandshakeResponse(this.receiveBuffer.get(2));
          } else if (this.socks5ChosenAuthType === constants_1.Socks5Auth.UserPass) {
            authResult = yield this.handleSocks5AuthenticationUserPassHandshakeResponse(this.receiveBuffer.get(2));
          } else if (this.socks5ChosenAuthType === this.options.proxy.custom_auth_method) {
            authResult = yield this.handleSocks5CustomAuthHandshakeResponse(this.receiveBuffer.get(this.options.proxy.custom_auth_response_size));
          }
          if (!authResult) {
            this.closeSocket(constants_1.ERRORS.Socks5AuthenticationFailed);
          } else {
            this.sendSocks5CommandRequest();
          }
        });
      }
      /**
       * Sends Socks v5 final handshake request.
       */
      sendSocks5CommandRequest() {
        const buff = new smart_buffer_1.SmartBuffer();
        buff.writeUInt8(5);
        buff.writeUInt8(constants_1.SocksCommand[this.options.command]);
        buff.writeUInt8(0);
        if (net.isIPv4(this.options.destination.host)) {
          buff.writeUInt8(constants_1.Socks5HostType.IPv4);
          buff.writeBuffer((0, helpers_1.ipToBuffer)(this.options.destination.host));
        } else if (net.isIPv6(this.options.destination.host)) {
          buff.writeUInt8(constants_1.Socks5HostType.IPv6);
          buff.writeBuffer((0, helpers_1.ipToBuffer)(this.options.destination.host));
        } else {
          buff.writeUInt8(constants_1.Socks5HostType.Hostname);
          buff.writeUInt8(this.options.destination.host.length);
          buff.writeString(this.options.destination.host);
        }
        buff.writeUInt16BE(this.options.destination.port);
        this.nextRequiredPacketBufferSize = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHeader;
        this.socket.write(buff.toBuffer());
        this.setState(constants_1.SocksClientState.SentFinalHandshake);
      }
      /**
       * Handles Socks v5 final handshake response.
       * @param data
       */
      handleSocks5FinalHandshakeResponse() {
        const header = this.receiveBuffer.peek(5);
        if (header[0] !== 5 || header[1] !== constants_1.Socks5Response.Granted) {
          this.closeSocket(`${constants_1.ERRORS.InvalidSocks5FinalHandshakeRejected} - ${constants_1.Socks5Response[header[1]]}`);
        } else {
          const addressType = header[3];
          let remoteHost;
          let buff;
          if (addressType === constants_1.Socks5HostType.IPv4) {
            const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv4;
            if (this.receiveBuffer.length < dataNeeded) {
              this.nextRequiredPacketBufferSize = dataNeeded;
              return;
            }
            buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(4));
            remoteHost = {
              host: (0, helpers_1.int32ToIpv4)(buff.readUInt32BE()),
              port: buff.readUInt16BE()
            };
            if (remoteHost.host === "0.0.0.0") {
              remoteHost.host = this.options.proxy.ipaddress;
            }
          } else if (addressType === constants_1.Socks5HostType.Hostname) {
            const hostLength = header[4];
            const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHostname(hostLength);
            if (this.receiveBuffer.length < dataNeeded) {
              this.nextRequiredPacketBufferSize = dataNeeded;
              return;
            }
            buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(5));
            remoteHost = {
              host: buff.readString(hostLength),
              port: buff.readUInt16BE()
            };
          } else if (addressType === constants_1.Socks5HostType.IPv6) {
            const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv6;
            if (this.receiveBuffer.length < dataNeeded) {
              this.nextRequiredPacketBufferSize = dataNeeded;
              return;
            }
            buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(4));
            remoteHost = {
              host: ip_address_1.Address6.fromByteArray(Array.from(buff.readBuffer(16))).canonicalForm(),
              port: buff.readUInt16BE()
            };
          }
          this.setState(constants_1.SocksClientState.ReceivedFinalResponse);
          if (constants_1.SocksCommand[this.options.command] === constants_1.SocksCommand.connect) {
            this.setState(constants_1.SocksClientState.Established);
            this.removeInternalSocketHandlers();
            this.emit("established", { remoteHost, socket: this.socket });
          } else if (constants_1.SocksCommand[this.options.command] === constants_1.SocksCommand.bind) {
            this.setState(constants_1.SocksClientState.BoundWaitingForConnection);
            this.nextRequiredPacketBufferSize = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHeader;
            this.emit("bound", { remoteHost, socket: this.socket });
          } else if (constants_1.SocksCommand[this.options.command] === constants_1.SocksCommand.associate) {
            this.setState(constants_1.SocksClientState.Established);
            this.removeInternalSocketHandlers();
            this.emit("established", {
              remoteHost,
              socket: this.socket
            });
          }
        }
      }
      /**
       * Handles Socks v5 incoming connection request (BIND).
       */
      handleSocks5IncomingConnectionResponse() {
        const header = this.receiveBuffer.peek(5);
        if (header[0] !== 5 || header[1] !== constants_1.Socks5Response.Granted) {
          this.closeSocket(`${constants_1.ERRORS.Socks5ProxyRejectedIncomingBoundConnection} - ${constants_1.Socks5Response[header[1]]}`);
        } else {
          const addressType = header[3];
          let remoteHost;
          let buff;
          if (addressType === constants_1.Socks5HostType.IPv4) {
            const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv4;
            if (this.receiveBuffer.length < dataNeeded) {
              this.nextRequiredPacketBufferSize = dataNeeded;
              return;
            }
            buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(4));
            remoteHost = {
              host: (0, helpers_1.int32ToIpv4)(buff.readUInt32BE()),
              port: buff.readUInt16BE()
            };
            if (remoteHost.host === "0.0.0.0") {
              remoteHost.host = this.options.proxy.ipaddress;
            }
          } else if (addressType === constants_1.Socks5HostType.Hostname) {
            const hostLength = header[4];
            const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHostname(hostLength);
            if (this.receiveBuffer.length < dataNeeded) {
              this.nextRequiredPacketBufferSize = dataNeeded;
              return;
            }
            buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(5));
            remoteHost = {
              host: buff.readString(hostLength),
              port: buff.readUInt16BE()
            };
          } else if (addressType === constants_1.Socks5HostType.IPv6) {
            const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv6;
            if (this.receiveBuffer.length < dataNeeded) {
              this.nextRequiredPacketBufferSize = dataNeeded;
              return;
            }
            buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(4));
            remoteHost = {
              host: ip_address_1.Address6.fromByteArray(Array.from(buff.readBuffer(16))).canonicalForm(),
              port: buff.readUInt16BE()
            };
          }
          this.setState(constants_1.SocksClientState.Established);
          this.removeInternalSocketHandlers();
          this.emit("established", { remoteHost, socket: this.socket });
        }
      }
      get socksClientOptions() {
        return Object.assign({}, this.options);
      }
    };
    exports2.SocksClient = SocksClient;
  }
});

// node_modules/socks/build/index.js
var require_build2 = __commonJS({
  "node_modules/socks/build/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m2, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m2, k);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m2, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m2[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m2, exports3) {
      for (var p in m2) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m2, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_socksclient(), exports2);
  }
});

// node_modules/socks-proxy-agent/dist/index.js
var require_dist4 = __commonJS({
  "node_modules/socks-proxy-agent/dist/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m2, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m2, k);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m2, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m2[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SocksProxyAgent = void 0;
    var socks_1 = require_build2();
    var agent_base_1 = require_dist2();
    var debug_1 = __importDefault(require_src());
    var dns = __importStar(require("dns"));
    var net = __importStar(require("net"));
    var tls = __importStar(require("tls"));
    var url_1 = require("url");
    var debug = (0, debug_1.default)("socks-proxy-agent");
    var setServernameFromNonIpHost = (options) => {
      if (options.servername === void 0 && options.host && !net.isIP(options.host)) {
        return {
          ...options,
          servername: options.host
        };
      }
      return options;
    };
    function parseSocksURL(url2) {
      let lookup = false;
      let type = 5;
      const host = url2.hostname;
      const port = parseInt(url2.port, 10) || 1080;
      switch (url2.protocol.replace(":", "")) {
        case "socks4":
          lookup = true;
          type = 4;
          break;
        // pass through
        case "socks4a":
          type = 4;
          break;
        case "socks5":
          lookup = true;
          type = 5;
          break;
        // pass through
        case "socks":
          type = 5;
          break;
        case "socks5h":
          type = 5;
          break;
        default:
          throw new TypeError(`A "socks" protocol must be specified! Got: ${String(url2.protocol)}`);
      }
      const proxy = {
        host,
        port,
        type
      };
      if (url2.username) {
        Object.defineProperty(proxy, "userId", {
          value: decodeURIComponent(url2.username),
          enumerable: false
        });
      }
      if (url2.password != null) {
        Object.defineProperty(proxy, "password", {
          value: decodeURIComponent(url2.password),
          enumerable: false
        });
      }
      return { lookup, proxy };
    }
    var SocksProxyAgent2 = class extends agent_base_1.Agent {
      constructor(uri, opts) {
        super(opts);
        const url2 = typeof uri === "string" ? new url_1.URL(uri) : uri;
        const { proxy, lookup } = parseSocksURL(url2);
        this.shouldLookup = lookup;
        this.proxy = proxy;
        this.timeout = opts?.timeout ?? null;
        this.socketOptions = opts?.socketOptions ?? null;
      }
      /**
       * Initiates a SOCKS connection to the specified SOCKS proxy server,
       * which in turn connects to the specified remote host and port.
       */
      async connect(req, opts) {
        const { shouldLookup, proxy, timeout } = this;
        if (!opts.host) {
          throw new Error("No `host` defined!");
        }
        let { host } = opts;
        const { port, lookup: lookupFn = dns.lookup } = opts;
        if (shouldLookup) {
          host = await new Promise((resolve, reject) => {
            lookupFn(host, {}, (err, res) => {
              if (err) {
                reject(err);
              } else {
                resolve(res);
              }
            });
          });
        }
        const socksOpts = {
          proxy,
          destination: {
            host,
            port: typeof port === "number" ? port : parseInt(port, 10)
          },
          command: "connect",
          timeout: timeout ?? void 0,
          // @ts-expect-error the type supplied by socks for socket_options is wider
          // than necessary since socks will always override the host and port
          socket_options: this.socketOptions ?? void 0
        };
        const cleanup = (tlsSocket) => {
          req.destroy();
          socket.destroy();
          if (tlsSocket)
            tlsSocket.destroy();
        };
        debug("Creating socks proxy connection: %o", socksOpts);
        const { socket } = await socks_1.SocksClient.createConnection(socksOpts);
        debug("Successfully created socks proxy connection");
        if (timeout !== null) {
          socket.setTimeout(timeout);
          socket.on("timeout", () => cleanup());
        }
        if (opts.secureEndpoint) {
          debug("Upgrading socket connection to TLS");
          const tlsSocket = tls.connect({
            ...omit(setServernameFromNonIpHost(opts), "host", "path", "port"),
            socket
          });
          tlsSocket.once("error", (error) => {
            debug("Socket TLS error", error.message);
            cleanup(tlsSocket);
          });
          return tlsSocket;
        }
        return socket;
      }
    };
    SocksProxyAgent2.protocols = [
      "socks",
      "socks4",
      "socks4a",
      "socks5",
      "socks5h"
    ];
    exports2.SocksProxyAgent = SocksProxyAgent2;
    function omit(obj, ...keys) {
      const ret = {};
      let key;
      for (key in obj) {
        if (!keys.includes(key)) {
          ret[key] = obj[key];
        }
      }
      return ret;
    }
  }
});

// node_modules/lodash.zipobject/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.zipobject/index.js"(exports2, module2) {
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
        object[key] = value;
      }
    }
    function baseZipObject(props, values, assignFunc) {
      var index = -1, length = props.length, valsLength = values.length, result = {};
      while (++index < length) {
        var value = index < valsLength ? values[index] : void 0;
        assignFunc(result, props[index], value);
      }
      return result;
    }
    function zipObject(props, values) {
      return baseZipObject(props || [], values || [], assignValue);
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    module2.exports = zipObject;
  }
});

// node_modules/string-hash/index.js
var require_string_hash = __commonJS({
  "node_modules/string-hash/index.js"(exports2, module2) {
    "use strict";
    function hash(str) {
      var hash2 = 5381, i2 = str.length;
      while (i2) {
        hash2 = hash2 * 33 ^ str.charCodeAt(--i2);
      }
      return hash2 >>> 0;
    }
    module2.exports = hash;
  }
});

// node_modules/async/dist/async.js
var require_async = __commonJS({
  "node_modules/async/dist/async.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.async = {}));
    })(exports2, function(exports3) {
      "use strict";
      function apply(fn, ...args) {
        return (...callArgs) => fn(...args, ...callArgs);
      }
      function initialParams(fn) {
        return function(...args) {
          var callback = args.pop();
          return fn.call(this, args, callback);
        };
      }
      var hasQueueMicrotask = typeof queueMicrotask === "function" && queueMicrotask;
      var hasSetImmediate = typeof setImmediate === "function" && setImmediate;
      var hasNextTick = typeof process === "object" && typeof process.nextTick === "function";
      function fallback(fn) {
        setTimeout(fn, 0);
      }
      function wrap(defer) {
        return (fn, ...args) => defer(() => fn(...args));
      }
      var _defer$1;
      if (hasQueueMicrotask) {
        _defer$1 = queueMicrotask;
      } else if (hasSetImmediate) {
        _defer$1 = setImmediate;
      } else if (hasNextTick) {
        _defer$1 = process.nextTick;
      } else {
        _defer$1 = fallback;
      }
      var setImmediate$1 = wrap(_defer$1);
      function asyncify(func) {
        if (isAsync(func)) {
          return function(...args) {
            const callback = args.pop();
            const promise = func.apply(this, args);
            return handlePromise(promise, callback);
          };
        }
        return initialParams(function(args, callback) {
          var result;
          try {
            result = func.apply(this, args);
          } catch (e2) {
            return callback(e2);
          }
          if (result && typeof result.then === "function") {
            return handlePromise(result, callback);
          } else {
            callback(null, result);
          }
        });
      }
      function handlePromise(promise, callback) {
        return promise.then((value) => {
          invokeCallback(callback, null, value);
        }, (err) => {
          invokeCallback(callback, err && (err instanceof Error || err.message) ? err : new Error(err));
        });
      }
      function invokeCallback(callback, error, value) {
        try {
          callback(error, value);
        } catch (err) {
          setImmediate$1((e2) => {
            throw e2;
          }, err);
        }
      }
      function isAsync(fn) {
        return fn[Symbol.toStringTag] === "AsyncFunction";
      }
      function isAsyncGenerator(fn) {
        return fn[Symbol.toStringTag] === "AsyncGenerator";
      }
      function isAsyncIterable(obj) {
        return typeof obj[Symbol.asyncIterator] === "function";
      }
      function wrapAsync(asyncFn) {
        if (typeof asyncFn !== "function") throw new Error("expected a function");
        return isAsync(asyncFn) ? asyncify(asyncFn) : asyncFn;
      }
      function awaitify(asyncFn, arity) {
        if (!arity) arity = asyncFn.length;
        if (!arity) throw new Error("arity is undefined");
        function awaitable(...args) {
          if (typeof args[arity - 1] === "function") {
            return asyncFn.apply(this, args);
          }
          return new Promise((resolve, reject2) => {
            args[arity - 1] = (err, ...cbArgs) => {
              if (err) return reject2(err);
              resolve(cbArgs.length > 1 ? cbArgs : cbArgs[0]);
            };
            asyncFn.apply(this, args);
          });
        }
        return awaitable;
      }
      function applyEach$1(eachfn) {
        return function applyEach2(fns, ...callArgs) {
          const go = awaitify(function(callback) {
            var that = this;
            return eachfn(fns, (fn, cb) => {
              wrapAsync(fn).apply(that, callArgs.concat(cb));
            }, callback);
          });
          return go;
        };
      }
      function _asyncMap(eachfn, arr, iteratee, callback) {
        arr = arr || [];
        var results = [];
        var counter = 0;
        var _iteratee = wrapAsync(iteratee);
        return eachfn(arr, (value, _, iterCb) => {
          var index2 = counter++;
          _iteratee(value, (err, v) => {
            results[index2] = v;
            iterCb(err);
          });
        }, (err) => {
          callback(err, results);
        });
      }
      function isArrayLike(value) {
        return value && typeof value.length === "number" && value.length >= 0 && value.length % 1 === 0;
      }
      const breakLoop = {};
      function once(fn) {
        function wrapper(...args) {
          if (fn === null) return;
          var callFn = fn;
          fn = null;
          callFn.apply(this, args);
        }
        Object.assign(wrapper, fn);
        return wrapper;
      }
      function getIterator(coll) {
        return coll[Symbol.iterator] && coll[Symbol.iterator]();
      }
      function createArrayIterator(coll) {
        var i2 = -1;
        var len = coll.length;
        return function next() {
          return ++i2 < len ? { value: coll[i2], key: i2 } : null;
        };
      }
      function createES2015Iterator(iterator) {
        var i2 = -1;
        return function next() {
          var item = iterator.next();
          if (item.done)
            return null;
          i2++;
          return { value: item.value, key: i2 };
        };
      }
      function createObjectIterator(obj) {
        var okeys = obj ? Object.keys(obj) : [];
        var i2 = -1;
        var len = okeys.length;
        return function next() {
          var key = okeys[++i2];
          if (key === "__proto__") {
            return next();
          }
          return i2 < len ? { value: obj[key], key } : null;
        };
      }
      function createIterator(coll) {
        if (isArrayLike(coll)) {
          return createArrayIterator(coll);
        }
        var iterator = getIterator(coll);
        return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);
      }
      function onlyOnce(fn) {
        return function(...args) {
          if (fn === null) throw new Error("Callback was already called.");
          var callFn = fn;
          fn = null;
          callFn.apply(this, args);
        };
      }
      function asyncEachOfLimit(generator, limit, iteratee, callback) {
        let done = false;
        let canceled = false;
        let awaiting = false;
        let running = 0;
        let idx = 0;
        function replenish() {
          if (running >= limit || awaiting || done) return;
          awaiting = true;
          generator.next().then(({ value, done: iterDone }) => {
            if (canceled || done) return;
            awaiting = false;
            if (iterDone) {
              done = true;
              if (running <= 0) {
                callback(null);
              }
              return;
            }
            running++;
            iteratee(value, idx, iterateeCallback);
            idx++;
            replenish();
          }).catch(handleError);
        }
        function iterateeCallback(err, result) {
          running -= 1;
          if (canceled) return;
          if (err) return handleError(err);
          if (err === false) {
            done = true;
            canceled = true;
            return;
          }
          if (result === breakLoop || done && running <= 0) {
            done = true;
            return callback(null);
          }
          replenish();
        }
        function handleError(err) {
          if (canceled) return;
          awaiting = false;
          done = true;
          callback(err);
        }
        replenish();
      }
      var eachOfLimit$2 = (limit) => {
        return (obj, iteratee, callback) => {
          callback = once(callback);
          if (limit <= 0) {
            throw new RangeError("concurrency limit cannot be less than 1");
          }
          if (!obj) {
            return callback(null);
          }
          if (isAsyncGenerator(obj)) {
            return asyncEachOfLimit(obj, limit, iteratee, callback);
          }
          if (isAsyncIterable(obj)) {
            return asyncEachOfLimit(obj[Symbol.asyncIterator](), limit, iteratee, callback);
          }
          var nextElem = createIterator(obj);
          var done = false;
          var canceled = false;
          var running = 0;
          var looping = false;
          function iterateeCallback(err, value) {
            if (canceled) return;
            running -= 1;
            if (err) {
              done = true;
              callback(err);
            } else if (err === false) {
              done = true;
              canceled = true;
            } else if (value === breakLoop || done && running <= 0) {
              done = true;
              return callback(null);
            } else if (!looping) {
              replenish();
            }
          }
          function replenish() {
            looping = true;
            while (running < limit && !done) {
              var elem = nextElem();
              if (elem === null) {
                done = true;
                if (running <= 0) {
                  callback(null);
                }
                return;
              }
              running += 1;
              iteratee(elem.value, elem.key, onlyOnce(iterateeCallback));
            }
            looping = false;
          }
          replenish();
        };
      };
      function eachOfLimit(coll, limit, iteratee, callback) {
        return eachOfLimit$2(limit)(coll, wrapAsync(iteratee), callback);
      }
      var eachOfLimit$1 = awaitify(eachOfLimit, 4);
      function eachOfArrayLike(coll, iteratee, callback) {
        callback = once(callback);
        var index2 = 0, completed = 0, { length } = coll, canceled = false;
        if (length === 0) {
          callback(null);
        }
        function iteratorCallback(err, value) {
          if (err === false) {
            canceled = true;
          }
          if (canceled === true) return;
          if (err) {
            callback(err);
          } else if (++completed === length || value === breakLoop) {
            callback(null);
          }
        }
        for (; index2 < length; index2++) {
          iteratee(coll[index2], index2, onlyOnce(iteratorCallback));
        }
      }
      function eachOfGeneric(coll, iteratee, callback) {
        return eachOfLimit$1(coll, Infinity, iteratee, callback);
      }
      function eachOf(coll, iteratee, callback) {
        var eachOfImplementation = isArrayLike(coll) ? eachOfArrayLike : eachOfGeneric;
        return eachOfImplementation(coll, wrapAsync(iteratee), callback);
      }
      var eachOf$1 = awaitify(eachOf, 3);
      function map(coll, iteratee, callback) {
        return _asyncMap(eachOf$1, coll, iteratee, callback);
      }
      var map$1 = awaitify(map, 3);
      var applyEach = applyEach$1(map$1);
      function eachOfSeries(coll, iteratee, callback) {
        return eachOfLimit$1(coll, 1, iteratee, callback);
      }
      var eachOfSeries$1 = awaitify(eachOfSeries, 3);
      function mapSeries(coll, iteratee, callback) {
        return _asyncMap(eachOfSeries$1, coll, iteratee, callback);
      }
      var mapSeries$1 = awaitify(mapSeries, 3);
      var applyEachSeries = applyEach$1(mapSeries$1);
      const PROMISE_SYMBOL = Symbol("promiseCallback");
      function promiseCallback() {
        let resolve, reject2;
        function callback(err, ...args) {
          if (err) return reject2(err);
          resolve(args.length > 1 ? args : args[0]);
        }
        callback[PROMISE_SYMBOL] = new Promise((res, rej) => {
          resolve = res, reject2 = rej;
        });
        return callback;
      }
      function auto(tasks, concurrency, callback) {
        if (typeof concurrency !== "number") {
          callback = concurrency;
          concurrency = null;
        }
        callback = once(callback || promiseCallback());
        var numTasks = Object.keys(tasks).length;
        if (!numTasks) {
          return callback(null);
        }
        if (!concurrency) {
          concurrency = numTasks;
        }
        var results = {};
        var runningTasks = 0;
        var canceled = false;
        var hasError = false;
        var listeners = /* @__PURE__ */ Object.create(null);
        var readyTasks = [];
        var readyToCheck = [];
        var uncheckedDependencies = {};
        Object.keys(tasks).forEach((key) => {
          var task = tasks[key];
          if (!Array.isArray(task)) {
            enqueueTask(key, [task]);
            readyToCheck.push(key);
            return;
          }
          var dependencies = task.slice(0, task.length - 1);
          var remainingDependencies = dependencies.length;
          if (remainingDependencies === 0) {
            enqueueTask(key, task);
            readyToCheck.push(key);
            return;
          }
          uncheckedDependencies[key] = remainingDependencies;
          dependencies.forEach((dependencyName) => {
            if (!tasks[dependencyName]) {
              throw new Error("async.auto task `" + key + "` has a non-existent dependency `" + dependencyName + "` in " + dependencies.join(", "));
            }
            addListener(dependencyName, () => {
              remainingDependencies--;
              if (remainingDependencies === 0) {
                enqueueTask(key, task);
              }
            });
          });
        });
        checkForDeadlocks();
        processQueue();
        function enqueueTask(key, task) {
          readyTasks.push(() => runTask(key, task));
        }
        function processQueue() {
          if (canceled) return;
          if (readyTasks.length === 0 && runningTasks === 0) {
            return callback(null, results);
          }
          while (readyTasks.length && runningTasks < concurrency) {
            var run = readyTasks.shift();
            run();
          }
        }
        function addListener(taskName, fn) {
          var taskListeners = listeners[taskName];
          if (!taskListeners) {
            taskListeners = listeners[taskName] = [];
          }
          taskListeners.push(fn);
        }
        function taskComplete(taskName) {
          var taskListeners = listeners[taskName] || [];
          taskListeners.forEach((fn) => fn());
          processQueue();
        }
        function runTask(key, task) {
          if (hasError) return;
          var taskCallback = onlyOnce((err, ...result) => {
            runningTasks--;
            if (err === false) {
              canceled = true;
              return;
            }
            if (result.length < 2) {
              [result] = result;
            }
            if (err) {
              var safeResults = {};
              Object.keys(results).forEach((rkey) => {
                safeResults[rkey] = results[rkey];
              });
              safeResults[key] = result;
              hasError = true;
              listeners = /* @__PURE__ */ Object.create(null);
              if (canceled) return;
              callback(err, safeResults);
            } else {
              results[key] = result;
              taskComplete(key);
            }
          });
          runningTasks++;
          var taskFn = wrapAsync(task[task.length - 1]);
          if (task.length > 1) {
            taskFn(results, taskCallback);
          } else {
            taskFn(taskCallback);
          }
        }
        function checkForDeadlocks() {
          var currentTask;
          var counter = 0;
          while (readyToCheck.length) {
            currentTask = readyToCheck.pop();
            counter++;
            getDependents(currentTask).forEach((dependent) => {
              if (--uncheckedDependencies[dependent] === 0) {
                readyToCheck.push(dependent);
              }
            });
          }
          if (counter !== numTasks) {
            throw new Error(
              "async.auto cannot execute tasks due to a recursive dependency"
            );
          }
        }
        function getDependents(taskName) {
          var result = [];
          Object.keys(tasks).forEach((key) => {
            const task = tasks[key];
            if (Array.isArray(task) && task.indexOf(taskName) >= 0) {
              result.push(key);
            }
          });
          return result;
        }
        return callback[PROMISE_SYMBOL];
      }
      var FN_ARGS = /^(?:async\s)?(?:function)?\s*(?:\w+\s*)?\(([^)]+)\)(?:\s*{)/;
      var ARROW_FN_ARGS = /^(?:async\s)?\s*(?:\(\s*)?((?:[^)=\s]\s*)*)(?:\)\s*)?=>/;
      var FN_ARG_SPLIT = /,/;
      var FN_ARG = /(=.+)?(\s*)$/;
      function stripComments(string) {
        let stripped = "";
        let index2 = 0;
        let endBlockComment = string.indexOf("*/");
        while (index2 < string.length) {
          if (string[index2] === "/" && string[index2 + 1] === "/") {
            let endIndex = string.indexOf("\n", index2);
            index2 = endIndex === -1 ? string.length : endIndex;
          } else if (endBlockComment !== -1 && string[index2] === "/" && string[index2 + 1] === "*") {
            let endIndex = string.indexOf("*/", index2);
            if (endIndex !== -1) {
              index2 = endIndex + 2;
              endBlockComment = string.indexOf("*/", index2);
            } else {
              stripped += string[index2];
              index2++;
            }
          } else {
            stripped += string[index2];
            index2++;
          }
        }
        return stripped;
      }
      function parseParams(func) {
        const src = stripComments(func.toString());
        let match = src.match(FN_ARGS);
        if (!match) {
          match = src.match(ARROW_FN_ARGS);
        }
        if (!match) throw new Error("could not parse args in autoInject\nSource:\n" + src);
        let [, args] = match;
        return args.replace(/\s/g, "").split(FN_ARG_SPLIT).map((arg) => arg.replace(FN_ARG, "").trim());
      }
      function autoInject(tasks, callback) {
        var newTasks = {};
        Object.keys(tasks).forEach((key) => {
          var taskFn = tasks[key];
          var params;
          var fnIsAsync = isAsync(taskFn);
          var hasNoDeps = !fnIsAsync && taskFn.length === 1 || fnIsAsync && taskFn.length === 0;
          if (Array.isArray(taskFn)) {
            params = [...taskFn];
            taskFn = params.pop();
            newTasks[key] = params.concat(params.length > 0 ? newTask : taskFn);
          } else if (hasNoDeps) {
            newTasks[key] = taskFn;
          } else {
            params = parseParams(taskFn);
            if (taskFn.length === 0 && !fnIsAsync && params.length === 0) {
              throw new Error("autoInject task functions require explicit parameters.");
            }
            if (!fnIsAsync) params.pop();
            newTasks[key] = params.concat(newTask);
          }
          function newTask(results, taskCb) {
            var newArgs = params.map((name) => results[name]);
            newArgs.push(taskCb);
            wrapAsync(taskFn)(...newArgs);
          }
        });
        return auto(newTasks, callback);
      }
      class DLL {
        constructor() {
          this.head = this.tail = null;
          this.length = 0;
        }
        removeLink(node) {
          if (node.prev) node.prev.next = node.next;
          else this.head = node.next;
          if (node.next) node.next.prev = node.prev;
          else this.tail = node.prev;
          node.prev = node.next = null;
          this.length -= 1;
          return node;
        }
        empty() {
          while (this.head) this.shift();
          return this;
        }
        insertAfter(node, newNode) {
          newNode.prev = node;
          newNode.next = node.next;
          if (node.next) node.next.prev = newNode;
          else this.tail = newNode;
          node.next = newNode;
          this.length += 1;
        }
        insertBefore(node, newNode) {
          newNode.prev = node.prev;
          newNode.next = node;
          if (node.prev) node.prev.next = newNode;
          else this.head = newNode;
          node.prev = newNode;
          this.length += 1;
        }
        unshift(node) {
          if (this.head) this.insertBefore(this.head, node);
          else setInitial(this, node);
        }
        push(node) {
          if (this.tail) this.insertAfter(this.tail, node);
          else setInitial(this, node);
        }
        shift() {
          return this.head && this.removeLink(this.head);
        }
        pop() {
          return this.tail && this.removeLink(this.tail);
        }
        toArray() {
          return [...this];
        }
        *[Symbol.iterator]() {
          var cur = this.head;
          while (cur) {
            yield cur.data;
            cur = cur.next;
          }
        }
        remove(testFn) {
          var curr = this.head;
          while (curr) {
            var { next } = curr;
            if (testFn(curr)) {
              this.removeLink(curr);
            }
            curr = next;
          }
          return this;
        }
      }
      function setInitial(dll, node) {
        dll.length = 1;
        dll.head = dll.tail = node;
      }
      function queue$1(worker, concurrency, payload) {
        if (concurrency == null) {
          concurrency = 1;
        } else if (concurrency === 0) {
          throw new RangeError("Concurrency must not be zero");
        }
        var _worker = wrapAsync(worker);
        var numRunning = 0;
        var workersList = [];
        const events = {
          error: [],
          drain: [],
          saturated: [],
          unsaturated: [],
          empty: []
        };
        function on(event, handler) {
          events[event].push(handler);
        }
        function once2(event, handler) {
          const handleAndRemove = (...args) => {
            off(event, handleAndRemove);
            handler(...args);
          };
          events[event].push(handleAndRemove);
        }
        function off(event, handler) {
          if (!event) return Object.keys(events).forEach((ev) => events[ev] = []);
          if (!handler) return events[event] = [];
          events[event] = events[event].filter((ev) => ev !== handler);
        }
        function trigger(event, ...args) {
          events[event].forEach((handler) => handler(...args));
        }
        var processingScheduled = false;
        function _insert(data, insertAtFront, rejectOnError, callback) {
          if (callback != null && typeof callback !== "function") {
            throw new Error("task callback must be a function");
          }
          q.started = true;
          var res, rej;
          function promiseCallback2(err, ...args) {
            if (err) return rejectOnError ? rej(err) : res();
            if (args.length <= 1) return res(args[0]);
            res(args);
          }
          var item = q._createTaskItem(
            data,
            rejectOnError ? promiseCallback2 : callback || promiseCallback2
          );
          if (insertAtFront) {
            q._tasks.unshift(item);
          } else {
            q._tasks.push(item);
          }
          if (!processingScheduled) {
            processingScheduled = true;
            setImmediate$1(() => {
              processingScheduled = false;
              q.process();
            });
          }
          if (rejectOnError || !callback) {
            return new Promise((resolve, reject2) => {
              res = resolve;
              rej = reject2;
            });
          }
        }
        function _createCB(tasks) {
          return function(err, ...args) {
            numRunning -= 1;
            for (var i2 = 0, l = tasks.length; i2 < l; i2++) {
              var task = tasks[i2];
              var index2 = workersList.indexOf(task);
              if (index2 === 0) {
                workersList.shift();
              } else if (index2 > 0) {
                workersList.splice(index2, 1);
              }
              task.callback(err, ...args);
              if (err != null) {
                trigger("error", err, task.data);
              }
            }
            if (numRunning <= q.concurrency - q.buffer) {
              trigger("unsaturated");
            }
            if (q.idle()) {
              trigger("drain");
            }
            q.process();
          };
        }
        function _maybeDrain(data) {
          if (data.length === 0 && q.idle()) {
            setImmediate$1(() => trigger("drain"));
            return true;
          }
          return false;
        }
        const eventMethod = (name) => (handler) => {
          if (!handler) {
            return new Promise((resolve, reject2) => {
              once2(name, (err, data) => {
                if (err) return reject2(err);
                resolve(data);
              });
            });
          }
          off(name);
          on(name, handler);
        };
        var isProcessing = false;
        var q = {
          _tasks: new DLL(),
          _createTaskItem(data, callback) {
            return {
              data,
              callback
            };
          },
          *[Symbol.iterator]() {
            yield* q._tasks[Symbol.iterator]();
          },
          concurrency,
          payload,
          buffer: concurrency / 4,
          started: false,
          paused: false,
          push(data, callback) {
            if (Array.isArray(data)) {
              if (_maybeDrain(data)) return;
              return data.map((datum) => _insert(datum, false, false, callback));
            }
            return _insert(data, false, false, callback);
          },
          pushAsync(data, callback) {
            if (Array.isArray(data)) {
              if (_maybeDrain(data)) return;
              return data.map((datum) => _insert(datum, false, true, callback));
            }
            return _insert(data, false, true, callback);
          },
          kill() {
            off();
            q._tasks.empty();
          },
          unshift(data, callback) {
            if (Array.isArray(data)) {
              if (_maybeDrain(data)) return;
              return data.map((datum) => _insert(datum, true, false, callback));
            }
            return _insert(data, true, false, callback);
          },
          unshiftAsync(data, callback) {
            if (Array.isArray(data)) {
              if (_maybeDrain(data)) return;
              return data.map((datum) => _insert(datum, true, true, callback));
            }
            return _insert(data, true, true, callback);
          },
          remove(testFn) {
            q._tasks.remove(testFn);
          },
          process() {
            if (isProcessing) {
              return;
            }
            isProcessing = true;
            while (!q.paused && numRunning < q.concurrency && q._tasks.length) {
              var tasks = [], data = [];
              var l = q._tasks.length;
              if (q.payload) l = Math.min(l, q.payload);
              for (var i2 = 0; i2 < l; i2++) {
                var node = q._tasks.shift();
                tasks.push(node);
                workersList.push(node);
                data.push(node.data);
              }
              numRunning += 1;
              if (q._tasks.length === 0) {
                trigger("empty");
              }
              if (numRunning === q.concurrency) {
                trigger("saturated");
              }
              var cb = onlyOnce(_createCB(tasks));
              _worker(data, cb);
            }
            isProcessing = false;
          },
          length() {
            return q._tasks.length;
          },
          running() {
            return numRunning;
          },
          workersList() {
            return workersList;
          },
          idle() {
            return q._tasks.length + numRunning === 0;
          },
          pause() {
            q.paused = true;
          },
          resume() {
            if (q.paused === false) {
              return;
            }
            q.paused = false;
            setImmediate$1(q.process);
          }
        };
        Object.defineProperties(q, {
          saturated: {
            writable: false,
            value: eventMethod("saturated")
          },
          unsaturated: {
            writable: false,
            value: eventMethod("unsaturated")
          },
          empty: {
            writable: false,
            value: eventMethod("empty")
          },
          drain: {
            writable: false,
            value: eventMethod("drain")
          },
          error: {
            writable: false,
            value: eventMethod("error")
          }
        });
        return q;
      }
      function cargo$1(worker, payload) {
        return queue$1(worker, 1, payload);
      }
      function cargo(worker, concurrency, payload) {
        return queue$1(worker, concurrency, payload);
      }
      function reduce(coll, memo, iteratee, callback) {
        callback = once(callback);
        var _iteratee = wrapAsync(iteratee);
        return eachOfSeries$1(coll, (x2, i2, iterCb) => {
          _iteratee(memo, x2, (err, v) => {
            memo = v;
            iterCb(err);
          });
        }, (err) => callback(err, memo));
      }
      var reduce$1 = awaitify(reduce, 4);
      function seq(...functions) {
        var _functions = functions.map(wrapAsync);
        return function(...args) {
          var that = this;
          var cb = args[args.length - 1];
          if (typeof cb == "function") {
            args.pop();
          } else {
            cb = promiseCallback();
          }
          reduce$1(
            _functions,
            args,
            (newargs, fn, iterCb) => {
              fn.apply(that, newargs.concat((err, ...nextargs) => {
                iterCb(err, nextargs);
              }));
            },
            (err, results) => cb(err, ...results)
          );
          return cb[PROMISE_SYMBOL];
        };
      }
      function compose(...args) {
        return seq(...args.reverse());
      }
      function mapLimit(coll, limit, iteratee, callback) {
        return _asyncMap(eachOfLimit$2(limit), coll, iteratee, callback);
      }
      var mapLimit$1 = awaitify(mapLimit, 4);
      function concatLimit(coll, limit, iteratee, callback) {
        var _iteratee = wrapAsync(iteratee);
        return mapLimit$1(coll, limit, (val, iterCb) => {
          _iteratee(val, (err, ...args) => {
            if (err) return iterCb(err);
            return iterCb(err, args);
          });
        }, (err, mapResults) => {
          var result = [];
          for (var i2 = 0; i2 < mapResults.length; i2++) {
            if (mapResults[i2]) {
              result = result.concat(...mapResults[i2]);
            }
          }
          return callback(err, result);
        });
      }
      var concatLimit$1 = awaitify(concatLimit, 4);
      function concat(coll, iteratee, callback) {
        return concatLimit$1(coll, Infinity, iteratee, callback);
      }
      var concat$1 = awaitify(concat, 3);
      function concatSeries(coll, iteratee, callback) {
        return concatLimit$1(coll, 1, iteratee, callback);
      }
      var concatSeries$1 = awaitify(concatSeries, 3);
      function constant$1(...args) {
        return function(...ignoredArgs) {
          var callback = ignoredArgs.pop();
          return callback(null, ...args);
        };
      }
      function _createTester(check, getResult) {
        return (eachfn, arr, _iteratee, cb) => {
          var testPassed = false;
          var testResult;
          const iteratee = wrapAsync(_iteratee);
          eachfn(arr, (value, _, callback) => {
            iteratee(value, (err, result) => {
              if (err || err === false) return callback(err);
              if (check(result) && !testResult) {
                testPassed = true;
                testResult = getResult(true, value);
                return callback(null, breakLoop);
              }
              callback();
            });
          }, (err) => {
            if (err) return cb(err);
            cb(null, testPassed ? testResult : getResult(false));
          });
        };
      }
      function detect(coll, iteratee, callback) {
        return _createTester((bool) => bool, (res, item) => item)(eachOf$1, coll, iteratee, callback);
      }
      var detect$1 = awaitify(detect, 3);
      function detectLimit(coll, limit, iteratee, callback) {
        return _createTester((bool) => bool, (res, item) => item)(eachOfLimit$2(limit), coll, iteratee, callback);
      }
      var detectLimit$1 = awaitify(detectLimit, 4);
      function detectSeries(coll, iteratee, callback) {
        return _createTester((bool) => bool, (res, item) => item)(eachOfLimit$2(1), coll, iteratee, callback);
      }
      var detectSeries$1 = awaitify(detectSeries, 3);
      function consoleFunc(name) {
        return (fn, ...args) => wrapAsync(fn)(...args, (err, ...resultArgs) => {
          if (typeof console === "object") {
            if (err) {
              if (console.error) {
                console.error(err);
              }
            } else if (console[name]) {
              resultArgs.forEach((x2) => console[name](x2));
            }
          }
        });
      }
      var dir = consoleFunc("dir");
      function doWhilst(iteratee, test, callback) {
        callback = onlyOnce(callback);
        var _fn = wrapAsync(iteratee);
        var _test = wrapAsync(test);
        var results;
        function next(err, ...args) {
          if (err) return callback(err);
          if (err === false) return;
          results = args;
          _test(...args, check);
        }
        function check(err, truth) {
          if (err) return callback(err);
          if (err === false) return;
          if (!truth) return callback(null, ...results);
          _fn(next);
        }
        return check(null, true);
      }
      var doWhilst$1 = awaitify(doWhilst, 3);
      function doUntil(iteratee, test, callback) {
        const _test = wrapAsync(test);
        return doWhilst$1(iteratee, (...args) => {
          const cb = args.pop();
          _test(...args, (err, truth) => cb(err, !truth));
        }, callback);
      }
      function _withoutIndex(iteratee) {
        return (value, index2, callback) => iteratee(value, callback);
      }
      function eachLimit$2(coll, iteratee, callback) {
        return eachOf$1(coll, _withoutIndex(wrapAsync(iteratee)), callback);
      }
      var each = awaitify(eachLimit$2, 3);
      function eachLimit(coll, limit, iteratee, callback) {
        return eachOfLimit$2(limit)(coll, _withoutIndex(wrapAsync(iteratee)), callback);
      }
      var eachLimit$1 = awaitify(eachLimit, 4);
      function eachSeries(coll, iteratee, callback) {
        return eachLimit$1(coll, 1, iteratee, callback);
      }
      var eachSeries$1 = awaitify(eachSeries, 3);
      function ensureAsync(fn) {
        if (isAsync(fn)) return fn;
        return function(...args) {
          var callback = args.pop();
          var sync = true;
          args.push((...innerArgs) => {
            if (sync) {
              setImmediate$1(() => callback(...innerArgs));
            } else {
              callback(...innerArgs);
            }
          });
          fn.apply(this, args);
          sync = false;
        };
      }
      function every(coll, iteratee, callback) {
        return _createTester((bool) => !bool, (res) => !res)(eachOf$1, coll, iteratee, callback);
      }
      var every$1 = awaitify(every, 3);
      function everyLimit(coll, limit, iteratee, callback) {
        return _createTester((bool) => !bool, (res) => !res)(eachOfLimit$2(limit), coll, iteratee, callback);
      }
      var everyLimit$1 = awaitify(everyLimit, 4);
      function everySeries(coll, iteratee, callback) {
        return _createTester((bool) => !bool, (res) => !res)(eachOfSeries$1, coll, iteratee, callback);
      }
      var everySeries$1 = awaitify(everySeries, 3);
      function filterArray(eachfn, arr, iteratee, callback) {
        var truthValues = new Array(arr.length);
        eachfn(arr, (x2, index2, iterCb) => {
          iteratee(x2, (err, v) => {
            truthValues[index2] = !!v;
            iterCb(err);
          });
        }, (err) => {
          if (err) return callback(err);
          var results = [];
          for (var i2 = 0; i2 < arr.length; i2++) {
            if (truthValues[i2]) results.push(arr[i2]);
          }
          callback(null, results);
        });
      }
      function filterGeneric(eachfn, coll, iteratee, callback) {
        var results = [];
        eachfn(coll, (x2, index2, iterCb) => {
          iteratee(x2, (err, v) => {
            if (err) return iterCb(err);
            if (v) {
              results.push({ index: index2, value: x2 });
            }
            iterCb(err);
          });
        }, (err) => {
          if (err) return callback(err);
          callback(null, results.sort((a, b) => a.index - b.index).map((v) => v.value));
        });
      }
      function _filter(eachfn, coll, iteratee, callback) {
        var filter2 = isArrayLike(coll) ? filterArray : filterGeneric;
        return filter2(eachfn, coll, wrapAsync(iteratee), callback);
      }
      function filter(coll, iteratee, callback) {
        return _filter(eachOf$1, coll, iteratee, callback);
      }
      var filter$1 = awaitify(filter, 3);
      function filterLimit(coll, limit, iteratee, callback) {
        return _filter(eachOfLimit$2(limit), coll, iteratee, callback);
      }
      var filterLimit$1 = awaitify(filterLimit, 4);
      function filterSeries(coll, iteratee, callback) {
        return _filter(eachOfSeries$1, coll, iteratee, callback);
      }
      var filterSeries$1 = awaitify(filterSeries, 3);
      function forever(fn, errback) {
        var done = onlyOnce(errback);
        var task = wrapAsync(ensureAsync(fn));
        function next(err) {
          if (err) return done(err);
          if (err === false) return;
          task(next);
        }
        return next();
      }
      var forever$1 = awaitify(forever, 2);
      function groupByLimit(coll, limit, iteratee, callback) {
        var _iteratee = wrapAsync(iteratee);
        return mapLimit$1(coll, limit, (val, iterCb) => {
          _iteratee(val, (err, key) => {
            if (err) return iterCb(err);
            return iterCb(err, { key, val });
          });
        }, (err, mapResults) => {
          var result = {};
          var { hasOwnProperty } = Object.prototype;
          for (var i2 = 0; i2 < mapResults.length; i2++) {
            if (mapResults[i2]) {
              var { key } = mapResults[i2];
              var { val } = mapResults[i2];
              if (hasOwnProperty.call(result, key)) {
                result[key].push(val);
              } else {
                result[key] = [val];
              }
            }
          }
          return callback(err, result);
        });
      }
      var groupByLimit$1 = awaitify(groupByLimit, 4);
      function groupBy(coll, iteratee, callback) {
        return groupByLimit$1(coll, Infinity, iteratee, callback);
      }
      function groupBySeries(coll, iteratee, callback) {
        return groupByLimit$1(coll, 1, iteratee, callback);
      }
      var log = consoleFunc("log");
      function mapValuesLimit(obj, limit, iteratee, callback) {
        callback = once(callback);
        var newObj = {};
        var _iteratee = wrapAsync(iteratee);
        return eachOfLimit$2(limit)(obj, (val, key, next) => {
          _iteratee(val, key, (err, result) => {
            if (err) return next(err);
            newObj[key] = result;
            next(err);
          });
        }, (err) => callback(err, newObj));
      }
      var mapValuesLimit$1 = awaitify(mapValuesLimit, 4);
      function mapValues(obj, iteratee, callback) {
        return mapValuesLimit$1(obj, Infinity, iteratee, callback);
      }
      function mapValuesSeries(obj, iteratee, callback) {
        return mapValuesLimit$1(obj, 1, iteratee, callback);
      }
      function memoize(fn, hasher = (v) => v) {
        var memo = /* @__PURE__ */ Object.create(null);
        var queues = /* @__PURE__ */ Object.create(null);
        var _fn = wrapAsync(fn);
        var memoized = initialParams((args, callback) => {
          var key = hasher(...args);
          if (key in memo) {
            setImmediate$1(() => callback(null, ...memo[key]));
          } else if (key in queues) {
            queues[key].push(callback);
          } else {
            queues[key] = [callback];
            _fn(...args, (err, ...resultArgs) => {
              if (!err) {
                memo[key] = resultArgs;
              }
              var q = queues[key];
              delete queues[key];
              for (var i2 = 0, l = q.length; i2 < l; i2++) {
                q[i2](err, ...resultArgs);
              }
            });
          }
        });
        memoized.memo = memo;
        memoized.unmemoized = fn;
        return memoized;
      }
      var _defer;
      if (hasNextTick) {
        _defer = process.nextTick;
      } else if (hasSetImmediate) {
        _defer = setImmediate;
      } else {
        _defer = fallback;
      }
      var nextTick = wrap(_defer);
      var _parallel = awaitify((eachfn, tasks, callback) => {
        var results = isArrayLike(tasks) ? [] : {};
        eachfn(tasks, (task, key, taskCb) => {
          wrapAsync(task)((err, ...result) => {
            if (result.length < 2) {
              [result] = result;
            }
            results[key] = result;
            taskCb(err);
          });
        }, (err) => callback(err, results));
      }, 3);
      function parallel(tasks, callback) {
        return _parallel(eachOf$1, tasks, callback);
      }
      function parallelLimit(tasks, limit, callback) {
        return _parallel(eachOfLimit$2(limit), tasks, callback);
      }
      function queue(worker, concurrency) {
        var _worker = wrapAsync(worker);
        return queue$1((items, cb) => {
          _worker(items[0], cb);
        }, concurrency, 1);
      }
      class Heap {
        constructor() {
          this.heap = [];
          this.pushCount = Number.MIN_SAFE_INTEGER;
        }
        get length() {
          return this.heap.length;
        }
        empty() {
          this.heap = [];
          return this;
        }
        percUp(index2) {
          let p;
          while (index2 > 0 && smaller(this.heap[index2], this.heap[p = parent(index2)])) {
            let t2 = this.heap[index2];
            this.heap[index2] = this.heap[p];
            this.heap[p] = t2;
            index2 = p;
          }
        }
        percDown(index2) {
          let l;
          while ((l = leftChi(index2)) < this.heap.length) {
            if (l + 1 < this.heap.length && smaller(this.heap[l + 1], this.heap[l])) {
              l = l + 1;
            }
            if (smaller(this.heap[index2], this.heap[l])) {
              break;
            }
            let t2 = this.heap[index2];
            this.heap[index2] = this.heap[l];
            this.heap[l] = t2;
            index2 = l;
          }
        }
        push(node) {
          node.pushCount = ++this.pushCount;
          this.heap.push(node);
          this.percUp(this.heap.length - 1);
        }
        unshift(node) {
          return this.heap.push(node);
        }
        shift() {
          let [top] = this.heap;
          this.heap[0] = this.heap[this.heap.length - 1];
          this.heap.pop();
          this.percDown(0);
          return top;
        }
        toArray() {
          return [...this];
        }
        *[Symbol.iterator]() {
          for (let i2 = 0; i2 < this.heap.length; i2++) {
            yield this.heap[i2].data;
          }
        }
        remove(testFn) {
          let j = 0;
          for (let i2 = 0; i2 < this.heap.length; i2++) {
            if (!testFn(this.heap[i2])) {
              this.heap[j] = this.heap[i2];
              j++;
            }
          }
          this.heap.splice(j);
          for (let i2 = parent(this.heap.length - 1); i2 >= 0; i2--) {
            this.percDown(i2);
          }
          return this;
        }
      }
      function leftChi(i2) {
        return (i2 << 1) + 1;
      }
      function parent(i2) {
        return (i2 + 1 >> 1) - 1;
      }
      function smaller(x2, y) {
        if (x2.priority !== y.priority) {
          return x2.priority < y.priority;
        } else {
          return x2.pushCount < y.pushCount;
        }
      }
      function priorityQueue(worker, concurrency) {
        var q = queue(worker, concurrency);
        var {
          push,
          pushAsync
        } = q;
        q._tasks = new Heap();
        q._createTaskItem = ({ data, priority }, callback) => {
          return {
            data,
            priority,
            callback
          };
        };
        function createDataItems(tasks, priority) {
          if (!Array.isArray(tasks)) {
            return { data: tasks, priority };
          }
          return tasks.map((data) => {
            return { data, priority };
          });
        }
        q.push = function(data, priority = 0, callback) {
          return push(createDataItems(data, priority), callback);
        };
        q.pushAsync = function(data, priority = 0, callback) {
          return pushAsync(createDataItems(data, priority), callback);
        };
        delete q.unshift;
        delete q.unshiftAsync;
        return q;
      }
      function race(tasks, callback) {
        callback = once(callback);
        if (!Array.isArray(tasks)) return callback(new TypeError("First argument to race must be an array of functions"));
        if (!tasks.length) return callback();
        for (var i2 = 0, l = tasks.length; i2 < l; i2++) {
          wrapAsync(tasks[i2])(callback);
        }
      }
      var race$1 = awaitify(race, 2);
      function reduceRight(array, memo, iteratee, callback) {
        var reversed = [...array].reverse();
        return reduce$1(reversed, memo, iteratee, callback);
      }
      function reflect(fn) {
        var _fn = wrapAsync(fn);
        return initialParams(function reflectOn(args, reflectCallback) {
          args.push((error, ...cbArgs) => {
            let retVal = {};
            if (error) {
              retVal.error = error;
            }
            if (cbArgs.length > 0) {
              var value = cbArgs;
              if (cbArgs.length <= 1) {
                [value] = cbArgs;
              }
              retVal.value = value;
            }
            reflectCallback(null, retVal);
          });
          return _fn.apply(this, args);
        });
      }
      function reflectAll(tasks) {
        var results;
        if (Array.isArray(tasks)) {
          results = tasks.map(reflect);
        } else {
          results = {};
          Object.keys(tasks).forEach((key) => {
            results[key] = reflect.call(this, tasks[key]);
          });
        }
        return results;
      }
      function reject$2(eachfn, arr, _iteratee, callback) {
        const iteratee = wrapAsync(_iteratee);
        return _filter(eachfn, arr, (value, cb) => {
          iteratee(value, (err, v) => {
            cb(err, !v);
          });
        }, callback);
      }
      function reject(coll, iteratee, callback) {
        return reject$2(eachOf$1, coll, iteratee, callback);
      }
      var reject$1 = awaitify(reject, 3);
      function rejectLimit(coll, limit, iteratee, callback) {
        return reject$2(eachOfLimit$2(limit), coll, iteratee, callback);
      }
      var rejectLimit$1 = awaitify(rejectLimit, 4);
      function rejectSeries(coll, iteratee, callback) {
        return reject$2(eachOfSeries$1, coll, iteratee, callback);
      }
      var rejectSeries$1 = awaitify(rejectSeries, 3);
      function constant(value) {
        return function() {
          return value;
        };
      }
      const DEFAULT_TIMES = 5;
      const DEFAULT_INTERVAL = 0;
      function retry(opts, task, callback) {
        var options = {
          times: DEFAULT_TIMES,
          intervalFunc: constant(DEFAULT_INTERVAL)
        };
        if (arguments.length < 3 && typeof opts === "function") {
          callback = task || promiseCallback();
          task = opts;
        } else {
          parseTimes(options, opts);
          callback = callback || promiseCallback();
        }
        if (typeof task !== "function") {
          throw new Error("Invalid arguments for async.retry");
        }
        var _task = wrapAsync(task);
        var attempt = 1;
        function retryAttempt() {
          _task((err, ...args) => {
            if (err === false) return;
            if (err && attempt++ < options.times && (typeof options.errorFilter != "function" || options.errorFilter(err))) {
              setTimeout(retryAttempt, options.intervalFunc(attempt - 1));
            } else {
              callback(err, ...args);
            }
          });
        }
        retryAttempt();
        return callback[PROMISE_SYMBOL];
      }
      function parseTimes(acc, t2) {
        if (typeof t2 === "object") {
          acc.times = +t2.times || DEFAULT_TIMES;
          acc.intervalFunc = typeof t2.interval === "function" ? t2.interval : constant(+t2.interval || DEFAULT_INTERVAL);
          acc.errorFilter = t2.errorFilter;
        } else if (typeof t2 === "number" || typeof t2 === "string") {
          acc.times = +t2 || DEFAULT_TIMES;
        } else {
          throw new Error("Invalid arguments for async.retry");
        }
      }
      function retryable(opts, task) {
        if (!task) {
          task = opts;
          opts = null;
        }
        let arity = opts && opts.arity || task.length;
        if (isAsync(task)) {
          arity += 1;
        }
        var _task = wrapAsync(task);
        return initialParams((args, callback) => {
          if (args.length < arity - 1 || callback == null) {
            args.push(callback);
            callback = promiseCallback();
          }
          function taskFn(cb) {
            _task(...args, cb);
          }
          if (opts) retry(opts, taskFn, callback);
          else retry(taskFn, callback);
          return callback[PROMISE_SYMBOL];
        });
      }
      function series(tasks, callback) {
        return _parallel(eachOfSeries$1, tasks, callback);
      }
      function some(coll, iteratee, callback) {
        return _createTester(Boolean, (res) => res)(eachOf$1, coll, iteratee, callback);
      }
      var some$1 = awaitify(some, 3);
      function someLimit(coll, limit, iteratee, callback) {
        return _createTester(Boolean, (res) => res)(eachOfLimit$2(limit), coll, iteratee, callback);
      }
      var someLimit$1 = awaitify(someLimit, 4);
      function someSeries(coll, iteratee, callback) {
        return _createTester(Boolean, (res) => res)(eachOfSeries$1, coll, iteratee, callback);
      }
      var someSeries$1 = awaitify(someSeries, 3);
      function sortBy(coll, iteratee, callback) {
        var _iteratee = wrapAsync(iteratee);
        return map$1(coll, (x2, iterCb) => {
          _iteratee(x2, (err, criteria) => {
            if (err) return iterCb(err);
            iterCb(err, { value: x2, criteria });
          });
        }, (err, results) => {
          if (err) return callback(err);
          callback(null, results.sort(comparator).map((v) => v.value));
        });
        function comparator(left, right) {
          var a = left.criteria, b = right.criteria;
          return a < b ? -1 : a > b ? 1 : 0;
        }
      }
      var sortBy$1 = awaitify(sortBy, 3);
      function timeout(asyncFn, milliseconds, info) {
        var fn = wrapAsync(asyncFn);
        return initialParams((args, callback) => {
          var timedOut = false;
          var timer;
          function timeoutCallback() {
            var name = asyncFn.name || "anonymous";
            var error = new Error('Callback function "' + name + '" timed out.');
            error.code = "ETIMEDOUT";
            if (info) {
              error.info = info;
            }
            timedOut = true;
            callback(error);
          }
          args.push((...cbArgs) => {
            if (!timedOut) {
              callback(...cbArgs);
              clearTimeout(timer);
            }
          });
          timer = setTimeout(timeoutCallback, milliseconds);
          fn(...args);
        });
      }
      function range(size) {
        var result = Array(size);
        while (size--) {
          result[size] = size;
        }
        return result;
      }
      function timesLimit(count, limit, iteratee, callback) {
        var _iteratee = wrapAsync(iteratee);
        return mapLimit$1(range(count), limit, _iteratee, callback);
      }
      function times(n, iteratee, callback) {
        return timesLimit(n, Infinity, iteratee, callback);
      }
      function timesSeries(n, iteratee, callback) {
        return timesLimit(n, 1, iteratee, callback);
      }
      function transform(coll, accumulator, iteratee, callback) {
        if (arguments.length <= 3 && typeof accumulator === "function") {
          callback = iteratee;
          iteratee = accumulator;
          accumulator = Array.isArray(coll) ? [] : {};
        }
        callback = once(callback || promiseCallback());
        var _iteratee = wrapAsync(iteratee);
        eachOf$1(coll, (v, k, cb) => {
          _iteratee(accumulator, v, k, cb);
        }, (err) => callback(err, accumulator));
        return callback[PROMISE_SYMBOL];
      }
      function tryEach(tasks, callback) {
        var error = null;
        var result;
        return eachSeries$1(tasks, (task, taskCb) => {
          wrapAsync(task)((err, ...args) => {
            if (err === false) return taskCb(err);
            if (args.length < 2) {
              [result] = args;
            } else {
              result = args;
            }
            error = err;
            taskCb(err ? null : {});
          });
        }, () => callback(error, result));
      }
      var tryEach$1 = awaitify(tryEach);
      function unmemoize(fn) {
        return (...args) => {
          return (fn.unmemoized || fn)(...args);
        };
      }
      function whilst(test, iteratee, callback) {
        callback = onlyOnce(callback);
        var _fn = wrapAsync(iteratee);
        var _test = wrapAsync(test);
        var results = [];
        function next(err, ...rest) {
          if (err) return callback(err);
          results = rest;
          if (err === false) return;
          _test(check);
        }
        function check(err, truth) {
          if (err) return callback(err);
          if (err === false) return;
          if (!truth) return callback(null, ...results);
          _fn(next);
        }
        return _test(check);
      }
      var whilst$1 = awaitify(whilst, 3);
      function until(test, iteratee, callback) {
        const _test = wrapAsync(test);
        return whilst$1((cb) => _test((err, truth) => cb(err, !truth)), iteratee, callback);
      }
      function waterfall(tasks, callback) {
        callback = once(callback);
        if (!Array.isArray(tasks)) return callback(new Error("First argument to waterfall must be an array of functions"));
        if (!tasks.length) return callback();
        var taskIndex = 0;
        function nextTask(args) {
          var task = wrapAsync(tasks[taskIndex++]);
          task(...args, onlyOnce(next));
        }
        function next(err, ...args) {
          if (err === false) return;
          if (err || taskIndex === tasks.length) {
            return callback(err, ...args);
          }
          nextTask(args);
        }
        nextTask([]);
      }
      var waterfall$1 = awaitify(waterfall);
      var index = {
        apply,
        applyEach,
        applyEachSeries,
        asyncify,
        auto,
        autoInject,
        cargo: cargo$1,
        cargoQueue: cargo,
        compose,
        concat: concat$1,
        concatLimit: concatLimit$1,
        concatSeries: concatSeries$1,
        constant: constant$1,
        detect: detect$1,
        detectLimit: detectLimit$1,
        detectSeries: detectSeries$1,
        dir,
        doUntil,
        doWhilst: doWhilst$1,
        each,
        eachLimit: eachLimit$1,
        eachOf: eachOf$1,
        eachOfLimit: eachOfLimit$1,
        eachOfSeries: eachOfSeries$1,
        eachSeries: eachSeries$1,
        ensureAsync,
        every: every$1,
        everyLimit: everyLimit$1,
        everySeries: everySeries$1,
        filter: filter$1,
        filterLimit: filterLimit$1,
        filterSeries: filterSeries$1,
        forever: forever$1,
        groupBy,
        groupByLimit: groupByLimit$1,
        groupBySeries,
        log,
        map: map$1,
        mapLimit: mapLimit$1,
        mapSeries: mapSeries$1,
        mapValues,
        mapValuesLimit: mapValuesLimit$1,
        mapValuesSeries,
        memoize,
        nextTick,
        parallel,
        parallelLimit,
        priorityQueue,
        queue,
        race: race$1,
        reduce: reduce$1,
        reduceRight,
        reflect,
        reflectAll,
        reject: reject$1,
        rejectLimit: rejectLimit$1,
        rejectSeries: rejectSeries$1,
        retry,
        retryable,
        seq,
        series,
        setImmediate: setImmediate$1,
        some: some$1,
        someLimit: someLimit$1,
        someSeries: someSeries$1,
        sortBy: sortBy$1,
        timeout,
        times,
        timesLimit,
        timesSeries,
        transform,
        tryEach: tryEach$1,
        unmemoize,
        until,
        waterfall: waterfall$1,
        whilst: whilst$1,
        // aliases
        all: every$1,
        allLimit: everyLimit$1,
        allSeries: everySeries$1,
        any: some$1,
        anyLimit: someLimit$1,
        anySeries: someSeries$1,
        find: detect$1,
        findLimit: detectLimit$1,
        findSeries: detectSeries$1,
        flatMap: concat$1,
        flatMapLimit: concatLimit$1,
        flatMapSeries: concatSeries$1,
        forEach: each,
        forEachSeries: eachSeries$1,
        forEachLimit: eachLimit$1,
        forEachOf: eachOf$1,
        forEachOfSeries: eachOfSeries$1,
        forEachOfLimit: eachOfLimit$1,
        inject: reduce$1,
        foldl: reduce$1,
        foldr: reduceRight,
        select: filter$1,
        selectLimit: filterLimit$1,
        selectSeries: filterSeries$1,
        wrapSync: asyncify,
        during: whilst$1,
        doDuring: doWhilst$1
      };
      exports3.all = every$1;
      exports3.allLimit = everyLimit$1;
      exports3.allSeries = everySeries$1;
      exports3.any = some$1;
      exports3.anyLimit = someLimit$1;
      exports3.anySeries = someSeries$1;
      exports3.apply = apply;
      exports3.applyEach = applyEach;
      exports3.applyEachSeries = applyEachSeries;
      exports3.asyncify = asyncify;
      exports3.auto = auto;
      exports3.autoInject = autoInject;
      exports3.cargo = cargo$1;
      exports3.cargoQueue = cargo;
      exports3.compose = compose;
      exports3.concat = concat$1;
      exports3.concatLimit = concatLimit$1;
      exports3.concatSeries = concatSeries$1;
      exports3.constant = constant$1;
      exports3.default = index;
      exports3.detect = detect$1;
      exports3.detectLimit = detectLimit$1;
      exports3.detectSeries = detectSeries$1;
      exports3.dir = dir;
      exports3.doDuring = doWhilst$1;
      exports3.doUntil = doUntil;
      exports3.doWhilst = doWhilst$1;
      exports3.during = whilst$1;
      exports3.each = each;
      exports3.eachLimit = eachLimit$1;
      exports3.eachOf = eachOf$1;
      exports3.eachOfLimit = eachOfLimit$1;
      exports3.eachOfSeries = eachOfSeries$1;
      exports3.eachSeries = eachSeries$1;
      exports3.ensureAsync = ensureAsync;
      exports3.every = every$1;
      exports3.everyLimit = everyLimit$1;
      exports3.everySeries = everySeries$1;
      exports3.filter = filter$1;
      exports3.filterLimit = filterLimit$1;
      exports3.filterSeries = filterSeries$1;
      exports3.find = detect$1;
      exports3.findLimit = detectLimit$1;
      exports3.findSeries = detectSeries$1;
      exports3.flatMap = concat$1;
      exports3.flatMapLimit = concatLimit$1;
      exports3.flatMapSeries = concatSeries$1;
      exports3.foldl = reduce$1;
      exports3.foldr = reduceRight;
      exports3.forEach = each;
      exports3.forEachLimit = eachLimit$1;
      exports3.forEachOf = eachOf$1;
      exports3.forEachOfLimit = eachOfLimit$1;
      exports3.forEachOfSeries = eachOfSeries$1;
      exports3.forEachSeries = eachSeries$1;
      exports3.forever = forever$1;
      exports3.groupBy = groupBy;
      exports3.groupByLimit = groupByLimit$1;
      exports3.groupBySeries = groupBySeries;
      exports3.inject = reduce$1;
      exports3.log = log;
      exports3.map = map$1;
      exports3.mapLimit = mapLimit$1;
      exports3.mapSeries = mapSeries$1;
      exports3.mapValues = mapValues;
      exports3.mapValuesLimit = mapValuesLimit$1;
      exports3.mapValuesSeries = mapValuesSeries;
      exports3.memoize = memoize;
      exports3.nextTick = nextTick;
      exports3.parallel = parallel;
      exports3.parallelLimit = parallelLimit;
      exports3.priorityQueue = priorityQueue;
      exports3.queue = queue;
      exports3.race = race$1;
      exports3.reduce = reduce$1;
      exports3.reduceRight = reduceRight;
      exports3.reflect = reflect;
      exports3.reflectAll = reflectAll;
      exports3.reject = reject$1;
      exports3.rejectLimit = rejectLimit$1;
      exports3.rejectSeries = rejectSeries$1;
      exports3.retry = retry;
      exports3.retryable = retryable;
      exports3.select = filter$1;
      exports3.selectLimit = filterLimit$1;
      exports3.selectSeries = filterSeries$1;
      exports3.seq = seq;
      exports3.series = series;
      exports3.setImmediate = setImmediate$1;
      exports3.some = some$1;
      exports3.someLimit = someLimit$1;
      exports3.someSeries = someSeries$1;
      exports3.sortBy = sortBy$1;
      exports3.timeout = timeout;
      exports3.times = times;
      exports3.timesLimit = timesLimit;
      exports3.timesSeries = timesSeries;
      exports3.transform = transform;
      exports3.tryEach = tryEach$1;
      exports3.unmemoize = unmemoize;
      exports3.until = until;
      exports3.waterfall = waterfall$1;
      exports3.whilst = whilst$1;
      exports3.wrapSync = asyncify;
      Object.defineProperty(exports3, "__esModule", { value: true });
    });
  }
});

// src/app.ts
var import_supertrend = __toESM(require_build());

// src/core/utils.ts
function convertStringToNumbers(candles) {
  return candles.reduce((result, candle) => {
    const [
      time,
      open,
      high,
      low,
      close,
      volume,
      closeTime,
      assetVolume,
      trades,
      buyBaseVolume,
      buyAssetVolume,
      ignored
    ] = candle;
    const newObj = {
      time: new Date(Number(time)).toISOString(),
      open: Number(open),
      high: Number(high),
      low: Number(low),
      close: Number(close),
      volume: Number(volume),
      closeTime: Number(closeTime),
      assetVolume: Number(assetVolume),
      trades: Number(trades),
      buyBaseVolume: Number(buyBaseVolume),
      buyAssetVolume: Number(buyAssetVolume),
      ignored
    };
    return [...result, newObj];
  }, []);
}

// node_modules/node-fetch/src/index.js
var import_node_http2 = __toESM(require("node:http"), 1);
var import_node_https = __toESM(require("node:https"), 1);
var import_node_zlib = __toESM(require("node:zlib"), 1);
var import_node_stream2 = __toESM(require("node:stream"), 1);
var import_node_buffer2 = require("node:buffer");

// node_modules/data-uri-to-buffer/dist/index.js
function dataUriToBuffer(uri) {
  if (!/^data:/i.test(uri)) {
    throw new TypeError('`uri` does not appear to be a Data URI (must begin with "data:")');
  }
  uri = uri.replace(/\r?\n/g, "");
  const firstComma = uri.indexOf(",");
  if (firstComma === -1 || firstComma <= 4) {
    throw new TypeError("malformed data: URI");
  }
  const meta = uri.substring(5, firstComma).split(";");
  let charset = "";
  let base64 = false;
  const type = meta[0] || "text/plain";
  let typeFull = type;
  for (let i2 = 1; i2 < meta.length; i2++) {
    if (meta[i2] === "base64") {
      base64 = true;
    } else if (meta[i2]) {
      typeFull += `;${meta[i2]}`;
      if (meta[i2].indexOf("charset=") === 0) {
        charset = meta[i2].substring(8);
      }
    }
  }
  if (!meta[0] && !charset.length) {
    typeFull += ";charset=US-ASCII";
    charset = "US-ASCII";
  }
  const encoding = base64 ? "base64" : "ascii";
  const data = unescape(uri.substring(firstComma + 1));
  const buffer = Buffer.from(data, encoding);
  buffer.type = type;
  buffer.typeFull = typeFull;
  buffer.charset = charset;
  return buffer;
}
var dist_default = dataUriToBuffer;

// node_modules/node-fetch/src/body.js
var import_node_stream = __toESM(require("node:stream"), 1);
var import_node_util = require("node:util");
var import_node_buffer = require("node:buffer");
init_fetch_blob();
init_esm_min();

// node_modules/node-fetch/src/errors/base.js
var FetchBaseError = class extends Error {
  constructor(message, type) {
    super(message);
    Error.captureStackTrace(this, this.constructor);
    this.type = type;
  }
  get name() {
    return this.constructor.name;
  }
  get [Symbol.toStringTag]() {
    return this.constructor.name;
  }
};

// node_modules/node-fetch/src/errors/fetch-error.js
var FetchError = class extends FetchBaseError {
  /**
   * @param  {string} message -      Error message for human
   * @param  {string} [type] -        Error type for machine
   * @param  {SystemError} [systemError] - For Node.js system error
   */
  constructor(message, type, systemError) {
    super(message, type);
    if (systemError) {
      this.code = this.errno = systemError.code;
      this.erroredSysCall = systemError.syscall;
    }
  }
};

// node_modules/node-fetch/src/utils/is.js
var NAME = Symbol.toStringTag;
var isURLSearchParameters = (object) => {
  return typeof object === "object" && typeof object.append === "function" && typeof object.delete === "function" && typeof object.get === "function" && typeof object.getAll === "function" && typeof object.has === "function" && typeof object.set === "function" && typeof object.sort === "function" && object[NAME] === "URLSearchParams";
};
var isBlob = (object) => {
  return object && typeof object === "object" && typeof object.arrayBuffer === "function" && typeof object.type === "string" && typeof object.stream === "function" && typeof object.constructor === "function" && /^(Blob|File)$/.test(object[NAME]);
};
var isAbortSignal = (object) => {
  return typeof object === "object" && (object[NAME] === "AbortSignal" || object[NAME] === "EventTarget");
};
var isDomainOrSubdomain = (destination, original) => {
  const orig = new URL(original).hostname;
  const dest = new URL(destination).hostname;
  return orig === dest || orig.endsWith(`.${dest}`);
};
var isSameProtocol = (destination, original) => {
  const orig = new URL(original).protocol;
  const dest = new URL(destination).protocol;
  return orig === dest;
};

// node_modules/node-fetch/src/body.js
var pipeline = (0, import_node_util.promisify)(import_node_stream.default.pipeline);
var INTERNALS = Symbol("Body internals");
var Body = class {
  constructor(body, {
    size = 0
  } = {}) {
    let boundary = null;
    if (body === null) {
      body = null;
    } else if (isURLSearchParameters(body)) {
      body = import_node_buffer.Buffer.from(body.toString());
    } else if (isBlob(body)) {
    } else if (import_node_buffer.Buffer.isBuffer(body)) {
    } else if (import_node_util.types.isAnyArrayBuffer(body)) {
      body = import_node_buffer.Buffer.from(body);
    } else if (ArrayBuffer.isView(body)) {
      body = import_node_buffer.Buffer.from(body.buffer, body.byteOffset, body.byteLength);
    } else if (body instanceof import_node_stream.default) {
    } else if (body instanceof FormData) {
      body = formDataToBlob(body);
      boundary = body.type.split("=")[1];
    } else {
      body = import_node_buffer.Buffer.from(String(body));
    }
    let stream = body;
    if (import_node_buffer.Buffer.isBuffer(body)) {
      stream = import_node_stream.default.Readable.from(body);
    } else if (isBlob(body)) {
      stream = import_node_stream.default.Readable.from(body.stream());
    }
    this[INTERNALS] = {
      body,
      stream,
      boundary,
      disturbed: false,
      error: null
    };
    this.size = size;
    if (body instanceof import_node_stream.default) {
      body.on("error", (error_) => {
        const error = error_ instanceof FetchBaseError ? error_ : new FetchError(`Invalid response body while trying to fetch ${this.url}: ${error_.message}`, "system", error_);
        this[INTERNALS].error = error;
      });
    }
  }
  get body() {
    return this[INTERNALS].stream;
  }
  get bodyUsed() {
    return this[INTERNALS].disturbed;
  }
  /**
   * Decode response as ArrayBuffer
   *
   * @return  Promise
   */
  async arrayBuffer() {
    const { buffer, byteOffset, byteLength } = await consumeBody(this);
    return buffer.slice(byteOffset, byteOffset + byteLength);
  }
  async formData() {
    const ct = this.headers.get("content-type");
    if (ct.startsWith("application/x-www-form-urlencoded")) {
      const formData = new FormData();
      const parameters = new URLSearchParams(await this.text());
      for (const [name, value] of parameters) {
        formData.append(name, value);
      }
      return formData;
    }
    const { toFormData: toFormData2 } = await Promise.resolve().then(() => (init_multipart_parser(), multipart_parser_exports));
    return toFormData2(this.body, ct);
  }
  /**
   * Return raw response as Blob
   *
   * @return Promise
   */
  async blob() {
    const ct = this.headers && this.headers.get("content-type") || this[INTERNALS].body && this[INTERNALS].body.type || "";
    const buf = await this.arrayBuffer();
    return new fetch_blob_default([buf], {
      type: ct
    });
  }
  /**
   * Decode response as json
   *
   * @return  Promise
   */
  async json() {
    const text = await this.text();
    return JSON.parse(text);
  }
  /**
   * Decode response as text
   *
   * @return  Promise
   */
  async text() {
    const buffer = await consumeBody(this);
    return new TextDecoder().decode(buffer);
  }
  /**
   * Decode response as buffer (non-spec api)
   *
   * @return  Promise
   */
  buffer() {
    return consumeBody(this);
  }
};
Body.prototype.buffer = (0, import_node_util.deprecate)(Body.prototype.buffer, "Please use 'response.arrayBuffer()' instead of 'response.buffer()'", "node-fetch#buffer");
Object.defineProperties(Body.prototype, {
  body: { enumerable: true },
  bodyUsed: { enumerable: true },
  arrayBuffer: { enumerable: true },
  blob: { enumerable: true },
  json: { enumerable: true },
  text: { enumerable: true },
  data: { get: (0, import_node_util.deprecate)(
    () => {
    },
    "data doesn't exist, use json(), text(), arrayBuffer(), or body instead",
    "https://github.com/node-fetch/node-fetch/issues/1000 (response)"
  ) }
});
async function consumeBody(data) {
  if (data[INTERNALS].disturbed) {
    throw new TypeError(`body used already for: ${data.url}`);
  }
  data[INTERNALS].disturbed = true;
  if (data[INTERNALS].error) {
    throw data[INTERNALS].error;
  }
  const { body } = data;
  if (body === null) {
    return import_node_buffer.Buffer.alloc(0);
  }
  if (!(body instanceof import_node_stream.default)) {
    return import_node_buffer.Buffer.alloc(0);
  }
  const accum = [];
  let accumBytes = 0;
  try {
    for await (const chunk of body) {
      if (data.size > 0 && accumBytes + chunk.length > data.size) {
        const error = new FetchError(`content size at ${data.url} over limit: ${data.size}`, "max-size");
        body.destroy(error);
        throw error;
      }
      accumBytes += chunk.length;
      accum.push(chunk);
    }
  } catch (error) {
    const error_ = error instanceof FetchBaseError ? error : new FetchError(`Invalid response body while trying to fetch ${data.url}: ${error.message}`, "system", error);
    throw error_;
  }
  if (body.readableEnded === true || body._readableState.ended === true) {
    try {
      if (accum.every((c) => typeof c === "string")) {
        return import_node_buffer.Buffer.from(accum.join(""));
      }
      return import_node_buffer.Buffer.concat(accum, accumBytes);
    } catch (error) {
      throw new FetchError(`Could not create Buffer from response body for ${data.url}: ${error.message}`, "system", error);
    }
  } else {
    throw new FetchError(`Premature close of server response while trying to fetch ${data.url}`);
  }
}
var clone = (instance, highWaterMark) => {
  let p1;
  let p2;
  let { body } = instance[INTERNALS];
  if (instance.bodyUsed) {
    throw new Error("cannot clone body after it is used");
  }
  if (body instanceof import_node_stream.default && typeof body.getBoundary !== "function") {
    p1 = new import_node_stream.PassThrough({ highWaterMark });
    p2 = new import_node_stream.PassThrough({ highWaterMark });
    body.pipe(p1);
    body.pipe(p2);
    instance[INTERNALS].stream = p1;
    body = p2;
  }
  return body;
};
var getNonSpecFormDataBoundary = (0, import_node_util.deprecate)(
  (body) => body.getBoundary(),
  "form-data doesn't follow the spec and requires special treatment. Use alternative package",
  "https://github.com/node-fetch/node-fetch/issues/1167"
);
var extractContentType = (body, request) => {
  if (body === null) {
    return null;
  }
  if (typeof body === "string") {
    return "text/plain;charset=UTF-8";
  }
  if (isURLSearchParameters(body)) {
    return "application/x-www-form-urlencoded;charset=UTF-8";
  }
  if (isBlob(body)) {
    return body.type || null;
  }
  if (import_node_buffer.Buffer.isBuffer(body) || import_node_util.types.isAnyArrayBuffer(body) || ArrayBuffer.isView(body)) {
    return null;
  }
  if (body instanceof FormData) {
    return `multipart/form-data; boundary=${request[INTERNALS].boundary}`;
  }
  if (body && typeof body.getBoundary === "function") {
    return `multipart/form-data;boundary=${getNonSpecFormDataBoundary(body)}`;
  }
  if (body instanceof import_node_stream.default) {
    return null;
  }
  return "text/plain;charset=UTF-8";
};
var getTotalBytes = (request) => {
  const { body } = request[INTERNALS];
  if (body === null) {
    return 0;
  }
  if (isBlob(body)) {
    return body.size;
  }
  if (import_node_buffer.Buffer.isBuffer(body)) {
    return body.length;
  }
  if (body && typeof body.getLengthSync === "function") {
    return body.hasKnownLength && body.hasKnownLength() ? body.getLengthSync() : null;
  }
  return null;
};
var writeToStream = async (dest, { body }) => {
  if (body === null) {
    dest.end();
  } else {
    await pipeline(body, dest);
  }
};

// node_modules/node-fetch/src/headers.js
var import_node_util2 = require("node:util");
var import_node_http = __toESM(require("node:http"), 1);
var validateHeaderName = typeof import_node_http.default.validateHeaderName === "function" ? import_node_http.default.validateHeaderName : (name) => {
  if (!/^[\^`\-\w!#$%&'*+.|~]+$/.test(name)) {
    const error = new TypeError(`Header name must be a valid HTTP token [${name}]`);
    Object.defineProperty(error, "code", { value: "ERR_INVALID_HTTP_TOKEN" });
    throw error;
  }
};
var validateHeaderValue = typeof import_node_http.default.validateHeaderValue === "function" ? import_node_http.default.validateHeaderValue : (name, value) => {
  if (/[^\t\u0020-\u007E\u0080-\u00FF]/.test(value)) {
    const error = new TypeError(`Invalid character in header content ["${name}"]`);
    Object.defineProperty(error, "code", { value: "ERR_INVALID_CHAR" });
    throw error;
  }
};
var Headers = class _Headers extends URLSearchParams {
  /**
   * Headers class
   *
   * @constructor
   * @param {HeadersInit} [init] - Response headers
   */
  constructor(init) {
    let result = [];
    if (init instanceof _Headers) {
      const raw = init.raw();
      for (const [name, values] of Object.entries(raw)) {
        result.push(...values.map((value) => [name, value]));
      }
    } else if (init == null) {
    } else if (typeof init === "object" && !import_node_util2.types.isBoxedPrimitive(init)) {
      const method = init[Symbol.iterator];
      if (method == null) {
        result.push(...Object.entries(init));
      } else {
        if (typeof method !== "function") {
          throw new TypeError("Header pairs must be iterable");
        }
        result = [...init].map((pair) => {
          if (typeof pair !== "object" || import_node_util2.types.isBoxedPrimitive(pair)) {
            throw new TypeError("Each header pair must be an iterable object");
          }
          return [...pair];
        }).map((pair) => {
          if (pair.length !== 2) {
            throw new TypeError("Each header pair must be a name/value tuple");
          }
          return [...pair];
        });
      }
    } else {
      throw new TypeError("Failed to construct 'Headers': The provided value is not of type '(sequence<sequence<ByteString>> or record<ByteString, ByteString>)");
    }
    result = result.length > 0 ? result.map(([name, value]) => {
      validateHeaderName(name);
      validateHeaderValue(name, String(value));
      return [String(name).toLowerCase(), String(value)];
    }) : void 0;
    super(result);
    return new Proxy(this, {
      get(target, p, receiver) {
        switch (p) {
          case "append":
          case "set":
            return (name, value) => {
              validateHeaderName(name);
              validateHeaderValue(name, String(value));
              return URLSearchParams.prototype[p].call(
                target,
                String(name).toLowerCase(),
                String(value)
              );
            };
          case "delete":
          case "has":
          case "getAll":
            return (name) => {
              validateHeaderName(name);
              return URLSearchParams.prototype[p].call(
                target,
                String(name).toLowerCase()
              );
            };
          case "keys":
            return () => {
              target.sort();
              return new Set(URLSearchParams.prototype.keys.call(target)).keys();
            };
          default:
            return Reflect.get(target, p, receiver);
        }
      }
    });
  }
  get [Symbol.toStringTag]() {
    return this.constructor.name;
  }
  toString() {
    return Object.prototype.toString.call(this);
  }
  get(name) {
    const values = this.getAll(name);
    if (values.length === 0) {
      return null;
    }
    let value = values.join(", ");
    if (/^content-encoding$/i.test(name)) {
      value = value.toLowerCase();
    }
    return value;
  }
  forEach(callback, thisArg = void 0) {
    for (const name of this.keys()) {
      Reflect.apply(callback, thisArg, [this.get(name), name, this]);
    }
  }
  *values() {
    for (const name of this.keys()) {
      yield this.get(name);
    }
  }
  /**
   * @type {() => IterableIterator<[string, string]>}
   */
  *entries() {
    for (const name of this.keys()) {
      yield [name, this.get(name)];
    }
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  /**
   * Node-fetch non-spec method
   * returning all headers and their values as array
   * @returns {Record<string, string[]>}
   */
  raw() {
    return [...this.keys()].reduce((result, key) => {
      result[key] = this.getAll(key);
      return result;
    }, {});
  }
  /**
   * For better console.log(headers) and also to convert Headers into Node.js Request compatible format
   */
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return [...this.keys()].reduce((result, key) => {
      const values = this.getAll(key);
      if (key === "host") {
        result[key] = values[0];
      } else {
        result[key] = values.length > 1 ? values : values[0];
      }
      return result;
    }, {});
  }
};
Object.defineProperties(
  Headers.prototype,
  ["get", "entries", "forEach", "values"].reduce((result, property) => {
    result[property] = { enumerable: true };
    return result;
  }, {})
);
function fromRawHeaders(headers = []) {
  return new Headers(
    headers.reduce((result, value, index, array) => {
      if (index % 2 === 0) {
        result.push(array.slice(index, index + 2));
      }
      return result;
    }, []).filter(([name, value]) => {
      try {
        validateHeaderName(name);
        validateHeaderValue(name, String(value));
        return true;
      } catch {
        return false;
      }
    })
  );
}

// node_modules/node-fetch/src/utils/is-redirect.js
var redirectStatus = /* @__PURE__ */ new Set([301, 302, 303, 307, 308]);
var isRedirect = (code) => {
  return redirectStatus.has(code);
};

// node_modules/node-fetch/src/response.js
var INTERNALS2 = Symbol("Response internals");
var Response = class _Response extends Body {
  constructor(body = null, options = {}) {
    super(body, options);
    const status = options.status != null ? options.status : 200;
    const headers = new Headers(options.headers);
    if (body !== null && !headers.has("Content-Type")) {
      const contentType = extractContentType(body, this);
      if (contentType) {
        headers.append("Content-Type", contentType);
      }
    }
    this[INTERNALS2] = {
      type: "default",
      url: options.url,
      status,
      statusText: options.statusText || "",
      headers,
      counter: options.counter,
      highWaterMark: options.highWaterMark
    };
  }
  get type() {
    return this[INTERNALS2].type;
  }
  get url() {
    return this[INTERNALS2].url || "";
  }
  get status() {
    return this[INTERNALS2].status;
  }
  /**
   * Convenience property representing if the request ended normally
   */
  get ok() {
    return this[INTERNALS2].status >= 200 && this[INTERNALS2].status < 300;
  }
  get redirected() {
    return this[INTERNALS2].counter > 0;
  }
  get statusText() {
    return this[INTERNALS2].statusText;
  }
  get headers() {
    return this[INTERNALS2].headers;
  }
  get highWaterMark() {
    return this[INTERNALS2].highWaterMark;
  }
  /**
   * Clone this response
   *
   * @return  Response
   */
  clone() {
    return new _Response(clone(this, this.highWaterMark), {
      type: this.type,
      url: this.url,
      status: this.status,
      statusText: this.statusText,
      headers: this.headers,
      ok: this.ok,
      redirected: this.redirected,
      size: this.size,
      highWaterMark: this.highWaterMark
    });
  }
  /**
   * @param {string} url    The URL that the new response is to originate from.
   * @param {number} status An optional status code for the response (e.g., 302.)
   * @returns {Response}    A Response object.
   */
  static redirect(url2, status = 302) {
    if (!isRedirect(status)) {
      throw new RangeError('Failed to execute "redirect" on "response": Invalid status code');
    }
    return new _Response(null, {
      headers: {
        location: new URL(url2).toString()
      },
      status
    });
  }
  static error() {
    const response = new _Response(null, { status: 0, statusText: "" });
    response[INTERNALS2].type = "error";
    return response;
  }
  static json(data = void 0, init = {}) {
    const body = JSON.stringify(data);
    if (body === void 0) {
      throw new TypeError("data is not JSON serializable");
    }
    const headers = new Headers(init && init.headers);
    if (!headers.has("content-type")) {
      headers.set("content-type", "application/json");
    }
    return new _Response(body, {
      ...init,
      headers
    });
  }
  get [Symbol.toStringTag]() {
    return "Response";
  }
};
Object.defineProperties(Response.prototype, {
  type: { enumerable: true },
  url: { enumerable: true },
  status: { enumerable: true },
  ok: { enumerable: true },
  redirected: { enumerable: true },
  statusText: { enumerable: true },
  headers: { enumerable: true },
  clone: { enumerable: true }
});

// node_modules/node-fetch/src/request.js
var import_node_url = require("node:url");
var import_node_util3 = require("node:util");

// node_modules/node-fetch/src/utils/get-search.js
var getSearch = (parsedURL) => {
  if (parsedURL.search) {
    return parsedURL.search;
  }
  const lastOffset = parsedURL.href.length - 1;
  const hash = parsedURL.hash || (parsedURL.href[lastOffset] === "#" ? "#" : "");
  return parsedURL.href[lastOffset - hash.length] === "?" ? "?" : "";
};

// node_modules/node-fetch/src/utils/referrer.js
var import_node_net = require("node:net");
function stripURLForUseAsAReferrer(url2, originOnly = false) {
  if (url2 == null) {
    return "no-referrer";
  }
  url2 = new URL(url2);
  if (/^(about|blob|data):$/.test(url2.protocol)) {
    return "no-referrer";
  }
  url2.username = "";
  url2.password = "";
  url2.hash = "";
  if (originOnly) {
    url2.pathname = "";
    url2.search = "";
  }
  return url2;
}
var ReferrerPolicy = /* @__PURE__ */ new Set([
  "",
  "no-referrer",
  "no-referrer-when-downgrade",
  "same-origin",
  "origin",
  "strict-origin",
  "origin-when-cross-origin",
  "strict-origin-when-cross-origin",
  "unsafe-url"
]);
var DEFAULT_REFERRER_POLICY = "strict-origin-when-cross-origin";
function validateReferrerPolicy(referrerPolicy) {
  if (!ReferrerPolicy.has(referrerPolicy)) {
    throw new TypeError(`Invalid referrerPolicy: ${referrerPolicy}`);
  }
  return referrerPolicy;
}
function isOriginPotentiallyTrustworthy(url2) {
  if (/^(http|ws)s:$/.test(url2.protocol)) {
    return true;
  }
  const hostIp = url2.host.replace(/(^\[)|(]$)/g, "");
  const hostIPVersion = (0, import_node_net.isIP)(hostIp);
  if (hostIPVersion === 4 && /^127\./.test(hostIp)) {
    return true;
  }
  if (hostIPVersion === 6 && /^(((0+:){7})|(::(0+:){0,6}))0*1$/.test(hostIp)) {
    return true;
  }
  if (url2.host === "localhost" || url2.host.endsWith(".localhost")) {
    return false;
  }
  if (url2.protocol === "file:") {
    return true;
  }
  return false;
}
function isUrlPotentiallyTrustworthy(url2) {
  if (/^about:(blank|srcdoc)$/.test(url2)) {
    return true;
  }
  if (url2.protocol === "data:") {
    return true;
  }
  if (/^(blob|filesystem):$/.test(url2.protocol)) {
    return true;
  }
  return isOriginPotentiallyTrustworthy(url2);
}
function determineRequestsReferrer(request, { referrerURLCallback, referrerOriginCallback } = {}) {
  if (request.referrer === "no-referrer" || request.referrerPolicy === "") {
    return null;
  }
  const policy = request.referrerPolicy;
  if (request.referrer === "about:client") {
    return "no-referrer";
  }
  const referrerSource = request.referrer;
  let referrerURL = stripURLForUseAsAReferrer(referrerSource);
  let referrerOrigin = stripURLForUseAsAReferrer(referrerSource, true);
  if (referrerURL.toString().length > 4096) {
    referrerURL = referrerOrigin;
  }
  if (referrerURLCallback) {
    referrerURL = referrerURLCallback(referrerURL);
  }
  if (referrerOriginCallback) {
    referrerOrigin = referrerOriginCallback(referrerOrigin);
  }
  const currentURL = new URL(request.url);
  switch (policy) {
    case "no-referrer":
      return "no-referrer";
    case "origin":
      return referrerOrigin;
    case "unsafe-url":
      return referrerURL;
    case "strict-origin":
      if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {
        return "no-referrer";
      }
      return referrerOrigin.toString();
    case "strict-origin-when-cross-origin":
      if (referrerURL.origin === currentURL.origin) {
        return referrerURL;
      }
      if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {
        return "no-referrer";
      }
      return referrerOrigin;
    case "same-origin":
      if (referrerURL.origin === currentURL.origin) {
        return referrerURL;
      }
      return "no-referrer";
    case "origin-when-cross-origin":
      if (referrerURL.origin === currentURL.origin) {
        return referrerURL;
      }
      return referrerOrigin;
    case "no-referrer-when-downgrade":
      if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {
        return "no-referrer";
      }
      return referrerURL;
    default:
      throw new TypeError(`Invalid referrerPolicy: ${policy}`);
  }
}
function parseReferrerPolicyFromHeader(headers) {
  const policyTokens = (headers.get("referrer-policy") || "").split(/[,\s]+/);
  let policy = "";
  for (const token of policyTokens) {
    if (token && ReferrerPolicy.has(token)) {
      policy = token;
    }
  }
  return policy;
}

// node_modules/node-fetch/src/request.js
var INTERNALS3 = Symbol("Request internals");
var isRequest = (object) => {
  return typeof object === "object" && typeof object[INTERNALS3] === "object";
};
var doBadDataWarn = (0, import_node_util3.deprecate)(
  () => {
  },
  ".data is not a valid RequestInit property, use .body instead",
  "https://github.com/node-fetch/node-fetch/issues/1000 (request)"
);
var Request = class _Request extends Body {
  constructor(input, init = {}) {
    let parsedURL;
    if (isRequest(input)) {
      parsedURL = new URL(input.url);
    } else {
      parsedURL = new URL(input);
      input = {};
    }
    if (parsedURL.username !== "" || parsedURL.password !== "") {
      throw new TypeError(`${parsedURL} is an url with embedded credentials.`);
    }
    let method = init.method || input.method || "GET";
    if (/^(delete|get|head|options|post|put)$/i.test(method)) {
      method = method.toUpperCase();
    }
    if (!isRequest(init) && "data" in init) {
      doBadDataWarn();
    }
    if ((init.body != null || isRequest(input) && input.body !== null) && (method === "GET" || method === "HEAD")) {
      throw new TypeError("Request with GET/HEAD method cannot have body");
    }
    const inputBody = init.body ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;
    super(inputBody, {
      size: init.size || input.size || 0
    });
    const headers = new Headers(init.headers || input.headers || {});
    if (inputBody !== null && !headers.has("Content-Type")) {
      const contentType = extractContentType(inputBody, this);
      if (contentType) {
        headers.set("Content-Type", contentType);
      }
    }
    let signal = isRequest(input) ? input.signal : null;
    if ("signal" in init) {
      signal = init.signal;
    }
    if (signal != null && !isAbortSignal(signal)) {
      throw new TypeError("Expected signal to be an instanceof AbortSignal or EventTarget");
    }
    let referrer = init.referrer == null ? input.referrer : init.referrer;
    if (referrer === "") {
      referrer = "no-referrer";
    } else if (referrer) {
      const parsedReferrer = new URL(referrer);
      referrer = /^about:(\/\/)?client$/.test(parsedReferrer) ? "client" : parsedReferrer;
    } else {
      referrer = void 0;
    }
    this[INTERNALS3] = {
      method,
      redirect: init.redirect || input.redirect || "follow",
      headers,
      parsedURL,
      signal,
      referrer
    };
    this.follow = init.follow === void 0 ? input.follow === void 0 ? 20 : input.follow : init.follow;
    this.compress = init.compress === void 0 ? input.compress === void 0 ? true : input.compress : init.compress;
    this.counter = init.counter || input.counter || 0;
    this.agent = init.agent || input.agent;
    this.highWaterMark = init.highWaterMark || input.highWaterMark || 16384;
    this.insecureHTTPParser = init.insecureHTTPParser || input.insecureHTTPParser || false;
    this.referrerPolicy = init.referrerPolicy || input.referrerPolicy || "";
  }
  /** @returns {string} */
  get method() {
    return this[INTERNALS3].method;
  }
  /** @returns {string} */
  get url() {
    return (0, import_node_url.format)(this[INTERNALS3].parsedURL);
  }
  /** @returns {Headers} */
  get headers() {
    return this[INTERNALS3].headers;
  }
  get redirect() {
    return this[INTERNALS3].redirect;
  }
  /** @returns {AbortSignal} */
  get signal() {
    return this[INTERNALS3].signal;
  }
  // https://fetch.spec.whatwg.org/#dom-request-referrer
  get referrer() {
    if (this[INTERNALS3].referrer === "no-referrer") {
      return "";
    }
    if (this[INTERNALS3].referrer === "client") {
      return "about:client";
    }
    if (this[INTERNALS3].referrer) {
      return this[INTERNALS3].referrer.toString();
    }
    return void 0;
  }
  get referrerPolicy() {
    return this[INTERNALS3].referrerPolicy;
  }
  set referrerPolicy(referrerPolicy) {
    this[INTERNALS3].referrerPolicy = validateReferrerPolicy(referrerPolicy);
  }
  /**
   * Clone this request
   *
   * @return  Request
   */
  clone() {
    return new _Request(this);
  }
  get [Symbol.toStringTag]() {
    return "Request";
  }
};
Object.defineProperties(Request.prototype, {
  method: { enumerable: true },
  url: { enumerable: true },
  headers: { enumerable: true },
  redirect: { enumerable: true },
  clone: { enumerable: true },
  signal: { enumerable: true },
  referrer: { enumerable: true },
  referrerPolicy: { enumerable: true }
});
var getNodeRequestOptions = (request) => {
  const { parsedURL } = request[INTERNALS3];
  const headers = new Headers(request[INTERNALS3].headers);
  if (!headers.has("Accept")) {
    headers.set("Accept", "*/*");
  }
  let contentLengthValue = null;
  if (request.body === null && /^(post|put)$/i.test(request.method)) {
    contentLengthValue = "0";
  }
  if (request.body !== null) {
    const totalBytes = getTotalBytes(request);
    if (typeof totalBytes === "number" && !Number.isNaN(totalBytes)) {
      contentLengthValue = String(totalBytes);
    }
  }
  if (contentLengthValue) {
    headers.set("Content-Length", contentLengthValue);
  }
  if (request.referrerPolicy === "") {
    request.referrerPolicy = DEFAULT_REFERRER_POLICY;
  }
  if (request.referrer && request.referrer !== "no-referrer") {
    request[INTERNALS3].referrer = determineRequestsReferrer(request);
  } else {
    request[INTERNALS3].referrer = "no-referrer";
  }
  if (request[INTERNALS3].referrer instanceof URL) {
    headers.set("Referer", request.referrer);
  }
  if (!headers.has("User-Agent")) {
    headers.set("User-Agent", "node-fetch");
  }
  if (request.compress && !headers.has("Accept-Encoding")) {
    headers.set("Accept-Encoding", "gzip, deflate, br");
  }
  let { agent } = request;
  if (typeof agent === "function") {
    agent = agent(parsedURL);
  }
  const search = getSearch(parsedURL);
  const options = {
    // Overwrite search to retain trailing ? (issue #776)
    path: parsedURL.pathname + search,
    // The following options are not expressed in the URL
    method: request.method,
    headers: headers[Symbol.for("nodejs.util.inspect.custom")](),
    insecureHTTPParser: request.insecureHTTPParser,
    agent
  };
  return {
    /** @type {URL} */
    parsedURL,
    options
  };
};

// node_modules/node-fetch/src/errors/abort-error.js
var AbortError = class extends FetchBaseError {
  constructor(message, type = "aborted") {
    super(message, type);
  }
};

// node_modules/node-fetch/src/index.js
init_esm_min();
init_from();
var supportedSchemas = /* @__PURE__ */ new Set(["data:", "http:", "https:"]);
async function fetch2(url2, options_) {
  return new Promise((resolve, reject) => {
    const request = new Request(url2, options_);
    const { parsedURL, options } = getNodeRequestOptions(request);
    if (!supportedSchemas.has(parsedURL.protocol)) {
      throw new TypeError(`node-fetch cannot load ${url2}. URL scheme "${parsedURL.protocol.replace(/:$/, "")}" is not supported.`);
    }
    if (parsedURL.protocol === "data:") {
      const data = dist_default(request.url);
      const response2 = new Response(data, { headers: { "Content-Type": data.typeFull } });
      resolve(response2);
      return;
    }
    const send = (parsedURL.protocol === "https:" ? import_node_https.default : import_node_http2.default).request;
    const { signal } = request;
    let response = null;
    const abort = () => {
      const error = new AbortError("The operation was aborted.");
      reject(error);
      if (request.body && request.body instanceof import_node_stream2.default.Readable) {
        request.body.destroy(error);
      }
      if (!response || !response.body) {
        return;
      }
      response.body.emit("error", error);
    };
    if (signal && signal.aborted) {
      abort();
      return;
    }
    const abortAndFinalize = () => {
      abort();
      finalize();
    };
    const request_ = send(parsedURL.toString(), options);
    if (signal) {
      signal.addEventListener("abort", abortAndFinalize);
    }
    const finalize = () => {
      request_.abort();
      if (signal) {
        signal.removeEventListener("abort", abortAndFinalize);
      }
    };
    request_.on("error", (error) => {
      reject(new FetchError(`request to ${request.url} failed, reason: ${error.message}`, "system", error));
      finalize();
    });
    fixResponseChunkedTransferBadEnding(request_, (error) => {
      if (response && response.body) {
        response.body.destroy(error);
      }
    });
    if (process.version < "v14") {
      request_.on("socket", (s2) => {
        let endedWithEventsCount;
        s2.prependListener("end", () => {
          endedWithEventsCount = s2._eventsCount;
        });
        s2.prependListener("close", (hadError) => {
          if (response && endedWithEventsCount < s2._eventsCount && !hadError) {
            const error = new Error("Premature close");
            error.code = "ERR_STREAM_PREMATURE_CLOSE";
            response.body.emit("error", error);
          }
        });
      });
    }
    request_.on("response", (response_) => {
      request_.setTimeout(0);
      const headers = fromRawHeaders(response_.rawHeaders);
      if (isRedirect(response_.statusCode)) {
        const location = headers.get("Location");
        let locationURL = null;
        try {
          locationURL = location === null ? null : new URL(location, request.url);
        } catch {
          if (request.redirect !== "manual") {
            reject(new FetchError(`uri requested responds with an invalid redirect URL: ${location}`, "invalid-redirect"));
            finalize();
            return;
          }
        }
        switch (request.redirect) {
          case "error":
            reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect"));
            finalize();
            return;
          case "manual":
            break;
          case "follow": {
            if (locationURL === null) {
              break;
            }
            if (request.counter >= request.follow) {
              reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect"));
              finalize();
              return;
            }
            const requestOptions = {
              headers: new Headers(request.headers),
              follow: request.follow,
              counter: request.counter + 1,
              agent: request.agent,
              compress: request.compress,
              method: request.method,
              body: clone(request),
              signal: request.signal,
              size: request.size,
              referrer: request.referrer,
              referrerPolicy: request.referrerPolicy
            };
            if (!isDomainOrSubdomain(request.url, locationURL) || !isSameProtocol(request.url, locationURL)) {
              for (const name of ["authorization", "www-authenticate", "cookie", "cookie2"]) {
                requestOptions.headers.delete(name);
              }
            }
            if (response_.statusCode !== 303 && request.body && options_.body instanceof import_node_stream2.default.Readable) {
              reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
              finalize();
              return;
            }
            if (response_.statusCode === 303 || (response_.statusCode === 301 || response_.statusCode === 302) && request.method === "POST") {
              requestOptions.method = "GET";
              requestOptions.body = void 0;
              requestOptions.headers.delete("content-length");
            }
            const responseReferrerPolicy = parseReferrerPolicyFromHeader(headers);
            if (responseReferrerPolicy) {
              requestOptions.referrerPolicy = responseReferrerPolicy;
            }
            resolve(fetch2(new Request(locationURL, requestOptions)));
            finalize();
            return;
          }
          default:
            return reject(new TypeError(`Redirect option '${request.redirect}' is not a valid value of RequestRedirect`));
        }
      }
      if (signal) {
        response_.once("end", () => {
          signal.removeEventListener("abort", abortAndFinalize);
        });
      }
      let body = (0, import_node_stream2.pipeline)(response_, new import_node_stream2.PassThrough(), (error) => {
        if (error) {
          reject(error);
        }
      });
      if (process.version < "v12.10") {
        response_.on("aborted", abortAndFinalize);
      }
      const responseOptions = {
        url: request.url,
        status: response_.statusCode,
        statusText: response_.statusMessage,
        headers,
        size: request.size,
        counter: request.counter,
        highWaterMark: request.highWaterMark
      };
      const codings = headers.get("Content-Encoding");
      if (!request.compress || request.method === "HEAD" || codings === null || response_.statusCode === 204 || response_.statusCode === 304) {
        response = new Response(body, responseOptions);
        resolve(response);
        return;
      }
      const zlibOptions = {
        flush: import_node_zlib.default.Z_SYNC_FLUSH,
        finishFlush: import_node_zlib.default.Z_SYNC_FLUSH
      };
      if (codings === "gzip" || codings === "x-gzip") {
        body = (0, import_node_stream2.pipeline)(body, import_node_zlib.default.createGunzip(zlibOptions), (error) => {
          if (error) {
            reject(error);
          }
        });
        response = new Response(body, responseOptions);
        resolve(response);
        return;
      }
      if (codings === "deflate" || codings === "x-deflate") {
        const raw = (0, import_node_stream2.pipeline)(response_, new import_node_stream2.PassThrough(), (error) => {
          if (error) {
            reject(error);
          }
        });
        raw.once("data", (chunk) => {
          if ((chunk[0] & 15) === 8) {
            body = (0, import_node_stream2.pipeline)(body, import_node_zlib.default.createInflate(), (error) => {
              if (error) {
                reject(error);
              }
            });
          } else {
            body = (0, import_node_stream2.pipeline)(body, import_node_zlib.default.createInflateRaw(), (error) => {
              if (error) {
                reject(error);
              }
            });
          }
          response = new Response(body, responseOptions);
          resolve(response);
        });
        raw.once("end", () => {
          if (!response) {
            response = new Response(body, responseOptions);
            resolve(response);
          }
        });
        return;
      }
      if (codings === "br") {
        body = (0, import_node_stream2.pipeline)(body, import_node_zlib.default.createBrotliDecompress(), (error) => {
          if (error) {
            reject(error);
          }
        });
        response = new Response(body, responseOptions);
        resolve(response);
        return;
      }
      response = new Response(body, responseOptions);
      resolve(response);
    });
    writeToStream(request_, request).catch(reject);
  });
}
function fixResponseChunkedTransferBadEnding(request, errorCallback) {
  const LAST_CHUNK = import_node_buffer2.Buffer.from("0\r\n\r\n");
  let isChunkedTransfer = false;
  let properLastChunkReceived = false;
  let previousChunk;
  request.on("response", (response) => {
    const { headers } = response;
    isChunkedTransfer = headers["transfer-encoding"] === "chunked" && !headers["content-length"];
  });
  request.on("socket", (socket) => {
    const onSocketClose = () => {
      if (isChunkedTransfer && !properLastChunkReceived) {
        const error = new Error("Premature close");
        error.code = "ERR_STREAM_PREMATURE_CLOSE";
        errorCallback(error);
      }
    };
    const onData = (buf) => {
      properLastChunkReceived = import_node_buffer2.Buffer.compare(buf.slice(-5), LAST_CHUNK) === 0;
      if (!properLastChunkReceived && previousChunk) {
        properLastChunkReceived = import_node_buffer2.Buffer.compare(previousChunk.slice(-3), LAST_CHUNK.slice(0, 3)) === 0 && import_node_buffer2.Buffer.compare(buf.slice(-2), LAST_CHUNK.slice(3)) === 0;
      }
      previousChunk = buf;
    };
    socket.prependListener("close", onSocketClose);
    socket.on("data", onData);
    request.on("close", () => {
      socket.removeListener("close", onSocketClose);
      socket.removeListener("data", onData);
    });
  });
}

// src/services/market.service.ts
var MarketService = class {
  constructor(market, tickInterval, limit) {
    this.market = market;
    this.tickInterval = tickInterval.getInterval();
    this.limit = limit;
  }
  async fetchCandlestickData() {
    let trying = 0;
    while (true) {
      trying++;
      try {
        const response = await fetch2(
          `https://api.binance.com/api/v1/klines?symbol=${this.market}&interval=${this.tickInterval}&limit=${this.limit + 1}`
        );
        const rawData = await response.json();
        return convertStringToNumbers(rawData).filter(
          (candle) => candle.closeTime > Date.now() - 1e3 * 60 * 60 * 24 * 7
        );
      } catch (error) {
        await new Promise((resolve) => setTimeout(resolve, 5e3));
        continue;
      }
    }
  }
};

// src/strategies/strategy-manager.ts
var StrategyManager = class {
  constructor(strategy) {
    this.strategy = strategy;
  }
  setStrategy(strategy) {
    this.strategy = strategy;
  }
  executeStrategy(candles, superTrends) {
    return this.strategy.execute(candles, superTrends);
  }
};

// src/models/operation.enum.ts
var Operation = {
  BUY: "BUY",
  SELL: "SELL"
};

// src/strategies/supertrend/supertrend-strategy.ts
var SuperTrendStrategy = class {
  execute(candles, superTrends) {
    const lastCandle = candles[candles.length - 1];
    const previousCandle = candles[candles.length - 2];
    const lastSuperTrend = superTrends[superTrends.length - 1];
    const previousSuperTrend = superTrends[superTrends.length - 2];
    if (previousCandle.close < previousSuperTrend && lastCandle.close > lastSuperTrend) {
      return Operation.BUY;
    } else if (previousCandle.close > previousSuperTrend && lastCandle.close < lastSuperTrend) {
      return Operation.SELL;
    }
    return "";
  }
};

// src/constants.ts
var TIME_FRAME = "1m";
var ASSET = "BTC";
var BALANCE_IN_POSTIOTION = 1;
var TARGET_ROI = 1.003;
var BASE_CURRENCY = "USDT";
var PAIR = ASSET + BASE_CURRENCY;

// src/models/tick-interval.model.ts
var Interval = /* @__PURE__ */ ((Interval2) => {
  Interval2["1m"] = "1m";
  Interval2["5m"] = "5m";
  Interval2["15m"] = "15m";
  Interval2["30m"] = "30m";
  Interval2["1h"] = "1h";
  Interval2["2h"] = "2h";
  Interval2["4h"] = "4h";
  Interval2["6h"] = "6h";
  Interval2["8h"] = "8h";
  Interval2["12h"] = "12h";
  Interval2["1d"] = "1d";
  Interval2["3d"] = "3d";
  Interval2["1w"] = "1w";
  Interval2["1M"] = "1M";
  return Interval2;
})(Interval || {});
var TickInterval = class {
  constructor(interval2) {
    this.interval = interval2;
  }
  getInterval() {
    return this.interval.toString();
  }
  getTickIntervalInMs() {
    return convertIntervalToMS(this.interval);
  }
};
function convertIntervalToMS(interval2) {
  const minute = 60 * 1e3;
  const hour = 60 * minute;
  const day = 24 * hour;
  const week = 7 * day;
  const month = 30 * day;
  switch (interval2) {
    case "1m" /* 1m */:
      return minute;
    case "5m" /* 5m */:
      return 5 * minute;
    case "15m" /* 15m */:
      return 15 * minute;
    case "30m" /* 30m */:
      return 30 * minute;
    case "1h" /* 1h */:
      return hour;
    case "2h" /* 2h */:
      return 2 * hour;
    case "4h" /* 4h */:
      return 4 * hour;
    case "6h" /* 6h */:
      return 6 * hour;
    case "8h" /* 8h */:
      return 8 * hour;
    case "12h" /* 12h */:
      return 12 * hour;
    case "1d" /* 1d */:
      return day;
    case "3d" /* 3d */:
      return 3 * day;
    case "1w" /* 1w */:
      return week;
    case "1M" /* 1M */:
      return month;
  }
}

// src/services/log.service.ts
var fs2 = __toESM(require("fs"));
var logStream = fs2.createWriteStream("./output.log", { flags: "a" });
var LogService = class {
  static log(...messages) {
    logStream.write(`${(/* @__PURE__ */ new Date()).toISOString()} - ${messages}
`);
    process.stdout.write(`${messages}
`);
  }
};

// src/services/binance-api.service.ts
var dotenv = __toESM(require_main());

// node_modules/node-binance-api/dist/node-binance-api.js
var import_ws = __toESM(require_ws(), 1);
var import_crypto = __toESM(require("crypto"), 1);
var import_fs = __toESM(require("fs"), 1);
var import_url = __toESM(require("url"), 1);
var import_json_bigint = __toESM(require_json_bigint(), 1);
var import_https_proxy_agent = __toESM(require_dist3(), 1);
var import_socks_proxy_agent = __toESM(require_dist4(), 1);
var import_lodash = __toESM(require_lodash(), 1);
var import_string_hash = __toESM(require_string_hash(), 1);
var import_async = __toESM(require_async(), 1);
var Binance = class {
  domain = "com";
  base = `https://api.binance.${this.domain}/api/`;
  baseTest = `https://testnet.binance.vision/api/`;
  wapi = `https://api.binance.${this.domain}/wapi/`;
  sapi = `https://api.binance.${this.domain}/sapi/`;
  fapi = `https://fapi.binance.${this.domain}/fapi/`;
  dapi = `https://dapi.binance.${this.domain}/dapi/`;
  fapiTest = `https://testnet.binancefuture.com/fapi/`;
  dapiTest = `https://testnet.binancefuture.com/dapi/`;
  fstream = `wss://fstream.binance.${this.domain}/stream?streams=`;
  fstreamSingle = `wss://fstream.binance.${this.domain}/ws/`;
  fstreamSingleTest = `wss://stream.binancefuture.${this.domain}/ws/`;
  fstreamTest = `wss://stream.binancefuture.${this.domain}/stream?streams=`;
  dstream = `wss://dstream.binance.${this.domain}/stream?streams=`;
  dstreamSingle = `wss://dstream.binance.${this.domain}/ws/`;
  dstreamSingleTest = `wss://dstream.binancefuture.${this.domain}/ws/`;
  dstreamTest = `wss://dstream.binancefuture.${this.domain}/stream?streams=`;
  stream = `wss://stream.binance.${this.domain}:9443/ws/`;
  combineStream = `wss://stream.binance.${this.domain}:9443/stream?streams=`;
  verbose = false;
  futuresListenKeyKeepAlive = 60 * 30 * 1e3;
  // 30 minutes
  spotListenKeyKeepAlive = 60 * 30 * 1e3;
  // 30 minutes
  heartBeatInterval = 3e4;
  // 30 seconds
  // proxy variables
  urlProxy = void 0;
  httpsProxy = void 0;
  socksProxy = void 0;
  nodeFetch = void 0;
  APIKEY = void 0;
  APISECRET = void 0;
  test = false;
  timeOffset = 0;
  userAgent = "Mozilla/4.0 (compatible; Node Binance API)";
  contentType = "application/x-www-form-urlencoded";
  SPOT_PREFIX = "x-HNA2TXFJ";
  CONTRACT_PREFIX = "x-Cb7ytekJ";
  // Websockets Options
  isAlive = false;
  socketHeartbeatInterval = null;
  // endpoint: string = ""; // endpoint for WS?
  reconnect = true;
  headers = {};
  subscriptions = {};
  futuresSubscriptions = {};
  futuresInfo = {};
  futuresMeta = {};
  futuresTicks = {};
  futuresRealtime = {};
  futuresKlineQueue = {};
  deliverySubscriptions = {};
  deliveryInfo = {};
  deliveryMeta = {};
  deliveryTicks = {};
  deliveryRealtime = {};
  deliveryKlineQueue = {};
  depthCache = {};
  depthCacheContext = {};
  ohlcLatest = {};
  klineQueue = {};
  ohlc = {};
  info = {};
  websockets = {
    userData: this.userData.bind(this),
    userMarginData: this.userMarginData.bind(this),
    depthCacheStaggered: this.depthCacheStaggered.bind(this),
    userFutureData: this.userFutureData.bind(this),
    userDeliveryData: this.userDeliveryData.bind(this),
    subscribeCombined: this.subscribeCombined.bind(this),
    subscribe: this.subscribe.bind(this),
    subscriptions: () => this.getSubscriptions.bind(this),
    terminate: this.terminate.bind(this),
    depth: this.depthStream.bind(this),
    depthCache: this.depthCacheStream.bind(this),
    clearDepthCache: this.clearDepthCache.bind(this),
    aggTrades: this.aggTradesStream.bind(this),
    trades: this.tradesStream.bind(this),
    chart: this.chart.bind(this),
    candlesticks: this.candlesticksStream.bind(this),
    miniTicker: this.miniTicker.bind(this),
    bookTickers: this.bookTickersStream.bind(this),
    prevDay: this.prevDayStream.bind(this),
    futuresCandlesticks: this.futuresCandlesticksStream.bind(this),
    futuresTicker: this.futuresTickerStream.bind(this),
    futuresMiniTicker: this.futuresMiniTickerStream.bind(this),
    futuresAggTrades: this.futuresAggTradeStream.bind(this),
    futuresMarkPrice: this.futuresMarkPriceStream.bind(this),
    futuresLiquidation: this.futuresLiquidationStream.bind(this),
    futuresBookTicker: this.futuresBookTickerStream.bind(this),
    futuresChart: this.futuresChart.bind(this),
    deliveryAggTrade: this.deliveryAggTradeStream.bind(this),
    deliveryCandlesticks: this.deliveryCandlesticks.bind(this),
    deliveryTicker: this.deliveryTickerStream.bind(this),
    deliveryMiniTicker: this.deliveryMiniTickerStream.bind(this),
    deliveryMarkPrice: this.deliveryMarkPriceStream.bind(this),
    deliveryBookTicker: this.deliveryBookTickerStream.bind(this),
    deliveryChart: this.deliveryChart.bind(this),
    deliveryLiquidation: this.deliveryLiquidationStream.bind(this),
    futuresSubcriptions: () => this.getFuturesSubscriptions.bind(this),
    deliverySubcriptions: () => this.getDeliverySubscriptions.bind(this),
    futuresTerminate: this.futuresTerminate.bind(this),
    deliveryTerminate: this.deliveryTerminate.bind(this)
  };
  default_options = {
    recvWindow: 5e3,
    useServerTime: false,
    reconnect: true,
    keepAlive: true,
    verbose: false,
    test: false,
    hedgeMode: false,
    localAddress: false,
    family: 4,
    log(...args) {
      console.log(Array.prototype.slice.call(args));
    }
  };
  Options = {};
  constructor(userOptions = {}) {
    if (userOptions) {
      this.setOptions(userOptions);
    }
  }
  options(opt = {}) {
    this.setOptions(opt);
    return this;
  }
  assignOptions(opt = {}) {
    if (typeof opt === "string") {
      this.Options = JSON.parse(import_fs.default.readFileSync(opt));
    } else
      this.Options = opt;
    if (!this.Options.recvWindow)
      this.Options.recvWindow = this.default_options.recvWindow;
    if (!this.Options.useServerTime)
      this.Options.useServerTime = this.default_options.useServerTime;
    if (!this.Options.reconnect)
      this.Options.reconnect = this.default_options.reconnect;
    if (!this.Options.test)
      this.Options.test = this.default_options.test;
    if (!this.Options.hedgeMode)
      this.Options.hedgeMode = this.default_options.hedgeMode;
    if (!this.Options.log)
      this.Options.log = this.default_options.log;
    if (!this.Options.verbose)
      this.Options.verbose = this.default_options.verbose;
    if (!this.Options.keepAlive)
      this.Options.keepAlive = this.default_options.keepAlive;
    if (!this.Options.localAddress)
      this.Options.localAddress = this.default_options.localAddress;
    if (!this.Options.family)
      this.Options.family = this.default_options.family;
    if (this.Options.urls !== void 0) {
      const { urls } = this.Options;
      if (urls.base)
        this.base = urls.base;
      if (urls.wapi)
        this.wapi = urls.wapi;
      if (urls.sapi)
        this.sapi = urls.sapi;
      if (urls.fapi)
        this.fapi = urls.fapi;
      if (urls.fapiTest)
        this.fapiTest = urls.fapiTest;
      if (urls.stream)
        this.stream = urls.stream;
      if (urls.combineStream)
        this.combineStream = urls.combineStream;
      if (urls.fstream)
        this.fstream = urls.fstream;
      if (urls.fstreamSingle)
        this.fstreamSingle = urls.fstreamSingle;
      if (urls.fstreamTest)
        this.fstreamTest = urls.fstreamTest;
      if (urls.fstreamSingleTest)
        this.fstreamSingleTest = urls.fstreamSingleTest;
      if (urls.dstream)
        this.dstream = urls.dstream;
      if (urls.dstreamSingle)
        this.dstreamSingle = urls.dstreamSingle;
      if (urls.dstreamTest)
        this.dstreamTest = urls.dstreamTest;
      if (urls.dstreamSingleTest)
        this.dstreamSingleTest = urls.dstreamSingleTest;
    }
    if (this.Options.APIKEY)
      this.APIKEY = this.Options.APIKEY;
    if (this.Options.APISECRET)
      this.APISECRET = this.Options.APISECRET;
    if (this.Options.test)
      this.test = true;
    if (this.Options.headers)
      this.headers = this.Options.Headers;
    if (this.Options.domain)
      this.domain = this.Options.domain;
  }
  async setOptions(opt = {}) {
    this.assignOptions(opt);
    if (this.Options.useServerTime) {
      const res = await this.publicSpotRequest("v3/time");
      this.timeOffset = res.serverTime - (/* @__PURE__ */ new Date()).getTime();
    }
    return this;
  }
  // ---- HELPER FUNCTIONS ---- //
  extend = (...args) => Object.assign({}, ...args);
  getSpotUrl() {
    if (this.Options.test)
      return this.baseTest;
    return this.base;
  }
  getFapiUrl() {
    if (this.Options.test)
      return this.fapiTest;
    return this.fapi;
  }
  getDapiUrl() {
    if (this.Options.test)
      return this.dapiTest;
    return this.dapi;
  }
  uuid22(a) {
    return a ? (a ^ Math.random() * 16 >> a / 4).toString(16) : "1000000010004000800000".replace(/[018]/g, this.uuid22);
  }
  getUrlProxy() {
    if (this.urlProxy) {
      return this.urlProxy;
    }
    return void 0;
  }
  getHttpsProxy() {
    if (this.httpsProxy) {
      return this.httpsProxy;
    }
    if (process.env.https_proxy) {
      return process.env.https_proxy;
    }
    return void 0;
  }
  getSocksProxy() {
    if (this.socksProxy) {
      return this.socksProxy;
    }
    if (process.env.socks_proxy) {
      return process.env.socks_proxy;
    }
    return void 0;
  }
  // ------ Request Related Functions ------ //
  /**
   * Replaces socks connection uri hostname with IP address
   * @param {string} connString - socks connection string
   * @return {string} modified string with ip address
   */
  proxyReplacewithIp(connString) {
    return connString;
  }
  /**
   * Returns an array in the form of [host, port]
   * @param {string} connString - connection string
   * @return {array} array of host and port
   */
  parseProxy(connString) {
    const arr = connString.split("/");
    const host = arr[2].split(":")[0];
    const port = arr[2].split(":")[1];
    return [arr[0], host, port];
  }
  /**
   * Checks to see of the object is iterable
   * @param {object} obj - The object check
   * @return {boolean} true or false is iterable
   */
  isIterable(obj) {
    if (obj === null)
      return false;
    return typeof obj[Symbol.iterator] === "function";
  }
  addProxy(opt) {
    if (this.Options.proxy) {
      const proxyauth = this.Options.proxy.auth ? `${this.Options.proxy.auth.username}:${this.Options.proxy.auth.password}@` : "";
      opt.proxy = `http://${proxyauth}${this.Options.proxy.host}:${this.Options.proxy.port}`;
    }
    return opt;
  }
  async reqHandler(response) {
    this.info.lastRequest = (/* @__PURE__ */ new Date()).getTime();
    if (response) {
      this.info.statusCode = response.status || 0;
      if (response.request)
        this.info.lastURL = response.request.uri.href;
      if (response.headers) {
        this.info.usedWeight = response.headers["x-mbx-used-weight-1m"] || 0;
        this.info.orderCount1s = response.headers["x-mbx-order-count-1s"] || 0;
        this.info.orderCount1m = response.headers["x-mbx-order-count-1m"] || 0;
        this.info.orderCount1h = response.headers["x-mbx-order-count-1h"] || 0;
        this.info.orderCount1d = response.headers["x-mbx-order-count-1d"] || 0;
      }
    }
    if (response && response.status !== 200) {
      const error = new Error(await response.text());
      throw error;
    }
  }
  async proxyRequest(opt) {
    const urlBody = new URLSearchParams(opt.form);
    const reqOptions = {
      method: opt.method,
      headers: opt.headers
      // body: urlBody
      // body: (opt.form)
    };
    if (opt.method !== "GET") {
      reqOptions.body = urlBody;
    } else {
      if (opt.qs) {
      }
    }
    if (this.Options.verbose) {
      this.Options.log("HTTP Request:", opt.method, opt.url, reqOptions);
    }
    const httpsproxy = this.getHttpsProxy();
    const socksproxy = this.getSocksProxy();
    const urlProxy = this.getUrlProxy();
    if (httpsproxy) {
      if (this.Options.verbose)
        this.Options.log("using https proxy: " + httpsproxy);
      reqOptions.agent = new import_https_proxy_agent.HttpsProxyAgent(httpsproxy);
    } else if (socksproxy) {
      if (this.Options.verbose)
        this.Options.log("using socks proxy: " + socksproxy);
      reqOptions.agent = new import_socks_proxy_agent.SocksProxyAgent(socksproxy);
    }
    if (urlProxy) {
      opt.url = urlProxy + opt.url;
    }
    let fetchImplementation = fetch;
    if (reqOptions.agent) {
      fetchImplementation = fetch2;
    }
    const response = await fetchImplementation(opt.url, reqOptions);
    await this.reqHandler(response);
    const json = await response.json();
    if (this.Options.verbose) {
      this.Options.log("HTTP Response:", json);
    }
    return json;
  }
  reqObj(url2, data = {}, method = "GET", key) {
    return {
      url: url2,
      qs: data,
      method,
      family: this.Options.family,
      localAddress: this.Options.localAddress,
      timeout: this.Options.recvWindow,
      forever: this.Options.keepAlive,
      headers: {
        "User-Agent": this.userAgent,
        "Content-type": this.contentType,
        "X-MBX-APIKEY": key || ""
      }
    };
  }
  reqObjPOST(url2, data = {}, method = "POST", key) {
    return {
      url: url2,
      form: data,
      method,
      family: this.Options.family,
      localAddress: this.Options.localAddress,
      timeout: this.Options.recvWindow,
      forever: this.Options.keepAlive,
      qsStringifyOptions: {
        arrayFormat: "repeat"
      },
      headers: {
        "User-Agent": this.userAgent,
        "Content-type": this.contentType,
        "X-MBX-APIKEY": key || ""
      }
    };
  }
  async publicRequest(url2, data = {}, method = "GET") {
    const query = this.makeQueryString(data);
    const opt = this.reqObj(url2 + (query ? "?" + query : ""), data, method);
    const res = await this.proxyRequest(opt);
    return res;
  }
  /**
   * Used to make public requests to the futures (FAPI) API
   * @param path
   * @param data
   * @param method
   * @returns
   */
  async publicFuturesRequest(path, data = {}, method = "GET") {
    return await this.publicRequest(this.getFapiUrl() + path, data, method);
  }
  /**
   * Used to make public requests to the delivery (DAPI) API
   * @param path
   * @param data
   * @param method
   * @returns
   */
  async publicDeliveryRequest(path, data = {}, method = "GET") {
    return await this.publicRequest(this.getDapiUrl() + path, data, method);
  }
  /**
   * Used to make private requests to the futures (FAPI) API
   * @param path
   * @param data
   * @param method
   * @returns
   */
  async privateFuturesRequest(path, data = {}, method = "GET") {
    return await this.futuresRequest(this.getFapiUrl() + path, data, method, true);
  }
  /**
   * Used to make private requests to the delivery (DAPI) API
   * @param path
   * @param data
   * @param method
   * @returns
   */
  async privateDeliveryRequest(path, data = {}, method = "GET") {
    return await this.futuresRequest(this.getDapiUrl() + path, data, method, true);
  }
  /**
   * Used to make a request to the futures API, this is a generic function that can be used to make any request to the futures API
   * @param url
   * @param data
   * @param method
   * @param isPrivate
   * @returns
   */
  async futuresRequest(url2, data = {}, method = "GET", isPrivate = false) {
    let query = "";
    const headers = {
      "User-Agent": this.userAgent,
      "Content-type": "application/x-www-form-urlencoded"
    };
    if (isPrivate) {
      if (!data.recvWindow)
        data.recvWindow = this.Options.recvWindow;
      this.requireApiKey("promiseRequest");
      headers["X-MBX-APIKEY"] = this.APIKEY;
    }
    const opt = {
      headers: this.extend(headers, this.headers),
      url: url2,
      method,
      timeout: this.Options.recvWindow,
      followAllRedirects: true
    };
    query = this.makeQueryString(data);
    if (method === "GET") {
      opt.url = `${url2}?${query}`;
    }
    if (isPrivate) {
      data.timestamp = (/* @__PURE__ */ new Date()).getTime();
      if (this.timeOffset) {
        data.timestamp += this.timeOffset;
      }
      query = this.makeQueryString(data);
      data.signature = import_crypto.default.createHmac("sha256", this.APISECRET).update(query).digest("hex");
      opt.url = `${url2}?${query}&signature=${data.signature}`;
    }
    opt.qs = data;
    const response = await this.proxyRequest(opt);
    return response;
  }
  // ------ Request Related Functions ------ //
  // XXX: This one works with array (e.g. for dust.transfer)
  // XXX: I _guess_ we could use replace this function with the `qs` module
  makeQueryString(q) {
    const res = Object.keys(q).reduce((a, k) => {
      if (Array.isArray(q[k])) {
        q[k].forEach((v) => {
          a.push(k + "=" + encodeURIComponent(v));
        });
      } else if (q[k] !== void 0) {
        a.push(k + "=" + encodeURIComponent(q[k]));
      }
      return a;
    }, []).join("&");
    return res;
  }
  /**
   * Create a http request to the public API
   * @param {string} url - The http endpoint
   * @param {object} data - The data to send
   * @param {function} callback - The callback method to call
   * @param {string} method - the http method
   * @return {undefined}
   */
  async apiRequest(url2, data = {}, method = "GET") {
    this.requireApiKey("apiRequest");
    const opt = this.reqObj(url2, data, method, this.APIKEY);
    const res = await this.proxyRequest(opt);
    return res;
  }
  requireApiKey(source = "requireApiKey", fatalError = true) {
    if (!this.APIKEY) {
      if (fatalError)
        throw Error(`${source}: Invalid API Key!`);
      return false;
    }
    return true;
  }
  // Check if API secret is present
  requireApiSecret(source = "requireApiSecret", fatalError = true) {
    if (!this.APIKEY) {
      if (fatalError)
        throw Error(`${source}: Invalid API Key!`);
      return false;
    }
    if (!this.APISECRET) {
      if (fatalError)
        throw Error(`${source}: Invalid API Secret!`);
      return false;
    }
    return true;
  }
  /**
   * Create a public spot/margin request
   * @param {string} path - url path
   * @param {object} data - The data to send
   * @param {string} method - the http method
   * @param {boolean} noDataInSignature - Prevents data from being added to signature
   * @return {undefined}
   */
  async publicSpotRequest(path, data = {}, method = "GET") {
    return await this.publicRequest(this.getSpotUrl() + path, data, method);
  }
  /**
   * Create a signed spot/margin request
   * @param {string} path - url path
   * @param {object} data - The data to send
   * @param {string} method - the http method
   * @param {boolean} noDataInSignature - Prevents data from being added to signature
   * @return {undefined}
   */
  async privateSpotRequest(path, data = {}, method = "GET", noDataInSignature = false) {
    return await this.signedRequest(this.getSpotUrl() + path, data, method, noDataInSignature);
  }
  /**
   * Create a signed http request
   * @param {string} url - The http endpoint
   * @param {object} data - The data to send
   * @param {function} callback - The callback method to call
   * @param {string} method - the http method
   * @param {boolean} noDataInSignature - Prevents data from being added to signature
   * @return {undefined}
   */
  async signedRequest(url2, data = {}, method = "GET", noDataInSignature = false) {
    this.requireApiSecret("signedRequest");
    data.timestamp = (/* @__PURE__ */ new Date()).getTime();
    if (this.timeOffset)
      data.timestamp += this.timeOffset;
    if (!data.recvWindow)
      data.recvWindow = this.Options.recvWindow;
    const query = method === "POST" && noDataInSignature ? "" : this.makeQueryString(data);
    const signature = import_crypto.default.createHmac("sha256", this.Options.APISECRET).update(query).digest("hex");
    if (method === "POST") {
      const opt = this.reqObjPOST(url2, data, method, this.APIKEY);
      opt.form.signature = signature;
      const reqPost = await this.proxyRequest(opt);
      return reqPost;
    } else {
      const opt = this.reqObj(url2 + "?" + query + "&signature=" + signature, data, method, this.APIKEY);
      const reqGet = await this.proxyRequest(opt);
      return reqGet;
    }
  }
  // --- ENDPOINTS --- //
  /**
   * Create a signed spot order
   * @see https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#new-order-trade
   * @see https://developers.binance.com/docs/binance-spot-api-docs/rest-api/public-api-endpoints#test-new-order-trade
   * @see https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#new-order-list---oco-trade
   * @param {OrderType} type - LIMIT, MARKET, STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, TAKE_PROFIT_LIMIT, LIMIT_MAKER
   * @param {OrderSide} side - BUY or SELL
   * @param {string} symbol - The symbol to buy or sell
   * @param {string} quantity - The quantity to buy or sell
   * @param {string} price - The price per unit to transact each unit at
   * @param {object} params - additional order settings
   * @return {undefined}
   */
  async order(type, side, symbol, quantity, price, params = {}) {
    let endpoint = params.type === "OCO" ? "v3/orderList/oco" : "v3/order";
    if (params.test) {
      delete params.test;
      endpoint += "/test";
    }
    const request = {
      symbol,
      side,
      type
    };
    if (params.quoteOrderQty && params.quoteOrderQty > 0)
      request.quoteOrderQty = params.quoteOrderQty;
    else
      request.quantity = quantity;
    if (request.type.includes("LIMIT")) {
      request.price = price;
      if (request.type !== "LIMIT_MAKER") {
        request.timeInForce = "GTC";
      }
    }
    if (request.type == "MARKET" && typeof params.quoteOrderQty !== "undefined") {
      request.quoteOrderQty = params.quoteOrderQty;
      delete request.quantity;
    }
    if (request.type === "OCO") {
      request.price = price;
      request.stopLimitPrice = params.stopLimitPrice;
      request.stopLimitTimeInForce = "GTC";
      delete request.type;
    }
    if (!params.newClientOrderId) {
      request.newClientOrderId = this.SPOT_PREFIX + this.uuid22();
    }
    if (params.stopPrice) {
      request.stopPrice = params.stopPrice;
      if (request.type === "LIMIT")
        throw Error('stopPrice: Must set "type" to one of the following: STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, TAKE_PROFIT_LIMIT');
    }
    const response = await this.privateSpotRequest(endpoint, this.extend(request, params), "POST");
    return response;
  }
  /**
  * Creates a buy order
  * @param {string} symbol - the symbol to buy
  * @param {numeric} quantity - the quantity required
  * @param {numeric} price - the price to pay for each unit
  * @param {object} flags - additional buy order flags
  * @return {promise or undefined} - omitting the callback returns a promise
  */
  async buy(symbol, quantity, price, flags = {}) {
    return await this.order("LIMIT", "BUY", symbol, quantity, price, flags);
  }
  /**
  * Creates a sell order
  * @param {string} symbol - the symbol to sell
  * @param {numeric} quantity - the quantity required
  * @param {numeric} price - the price to pay for each unit
  * @param {object} flags - additional buy order flags
  * @param {function} callback - the callback function
  * @return {promise or undefined} - omitting the callback returns a promise
  */
  async sell(symbol, quantity, price, flags = {}) {
    return await this.order("LIMIT", "SELL", symbol, quantity, price, flags);
  }
  /**
  * Creates a market buy order
  * @see https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#new-order-trade
  * @see https://developers.binance.com/docs/binance-spot-api-docs/rest-api/public-api-endpoints#test-new-order-trade
  * @see https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#new-order-list---oco-trade
  * @param {string} symbol - the symbol to buy
  * @param {numeric} quantity - the quantity required
  * @param {object} params - additional buy order flags
  * @return {promise or undefined} - omitting the callback returns a promise
  */
  async marketBuy(symbol, quantity, params = {}) {
    return await this.order("MARKET", "BUY", symbol, quantity, 0, params);
  }
  /**
  * Creates a spot limit order
  * @see https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#new-order-trade
  * @see https://developers.binance.com/docs/binance-spot-api-docs/rest-api/public-api-endpoints#test-new-order-trade
  * @see https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#new-order-list---oco-trade
  * @param {string} side - the side of the order (BUY or SELL)
  * @param {string} symbol - the symbol to buy
  * @param {numeric} quantity - the quantity required
  * @param {numeric} price - the price to pay for each unit
  * @param {object} params - additional buy order flags
  * @return {promise or undefined} - omitting the callback returns a promise
  */
  async limitOrder(side, symbol, quantity, price, params = {}) {
    return await this.order("LIMIT", side, symbol, quantity, price, params);
  }
  /**
  * Creates a market buy order using the cost instead of the quantity (eg: 100usd instead of 0.01btc)
  * @see https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#new-order-trade
  * @see https://developers.binance.com/docs/binance-spot-api-docs/rest-api/public-api-endpoints#test-new-order-trade
  * @see https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#new-order-list---oco-trade
  * @param {string} symbol - the symbol to buy
  * @param {numeric} quantity - the quantity required
  * @param {object} params - additional buy order flags
  * @return {promise or undefined} - omitting the callback returns a promise
  */
  async marketBuyWithCost(symbol, cost, params = {}) {
    params.quoteOrderQty = cost;
    return await this.order("MARKET", "BUY", symbol, 0, 0, params);
  }
  /**
  * Creates a market sell order
  * @see https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#new-order-trade
  * @see https://developers.binance.com/docs/binance-spot-api-docs/rest-api/public-api-endpoints#test-new-order-trade
  * @see https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#new-order-list---oco-trade
  * @param {string} symbol - the symbol to sell
  * @param {numeric} quantity - the quantity required
  * @param {object} flags - additional buy order flags
  * @return {promise or undefined} - omitting the callback returns a promise
  */
  async marketSell(symbol, quantity, params = {}) {
    return await this.order("MARKET", "SELL", symbol, quantity, 0, params);
  }
  /**
  * Creates a market sell order using the cost instead of the quantity (eg: 100usd instead of 0.01btc)
  * @see https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#new-order-trade
  * @see https://developers.binance.com/docs/binance-spot-api-docs/rest-api/public-api-endpoints#test-new-order-trade
  * @see https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#new-order-list---oco-trade
  * @param {string} symbol - the symbol to sell
  * @param {numeric} quantity - the quantity required
  * @param {object} flags - additional buy order flags
  * @return {promise or undefined} - omitting the callback returns a promise
  */
  async marketSellWithCost(symbol, cost, params = {}) {
    params.quoteOrderQty = cost;
    return await this.order("MARKET", "SELL", symbol, 0, 0, params);
  }
  /**
  * Cancels an order
  * @see https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#cancel-order-trade
  * @param {string} symbol - the symbol to cancel
  * @param {string} orderid - the orderid to cancel
  * @return {promise or undefined} - omitting the callback returns a promise
  */
  async cancel(symbol, orderid, params = {}) {
    return await this.privateSpotRequest("v3/order", this.extend({ symbol, orderId: orderid }, params), "DELETE");
  }
  /**
  * Gets the status of an order
  * @see https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#query-order-user_data
  * @param {string} symbol - the symbol to check
  * @param {string} orderid - the orderid to check if !orderid then  use flags to search
  * @param {object} flags - any additional flags
  * @return {promise or undefined} - omitting the callback returns a promise
  */
  async orderStatus(symbol, orderid, flags = {}) {
    let parameters = Object.assign({ symbol }, flags);
    if (orderid) {
      parameters = Object.assign({ orderId: orderid }, parameters);
    }
    return await this.privateSpotRequest("v3/order", parameters);
  }
  /**
  * Gets open orders
  * @see https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#current-open-orders-user_data
  * @param {string} symbol - the symbol to get
  * @return {promise or undefined} - omitting the callback returns a promise
  */
  async openOrders(symbol, params = {}) {
    const parameters = symbol ? { symbol } : {};
    return await this.privateSpotRequest("v3/openOrders", this.extend(parameters, params));
  }
  /**
  * Cancels all orders of a given symbol
  * @see https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#cancel-all-open-orders-on-a-symbol-trade
  * @param {string} symbol - the symbol to cancel all orders for
  * @return {promise or undefined} - omitting the callback returns a promise
  */
  async cancelAllOrders(symbol, params = {}) {
    return await this.privateSpotRequest("v3/openOrders", this.extend({ symbol }, params), "DELETE");
  }
  // /**
  // * Cancels all orders of a given symbol
  // * @param {string} symbol - the symbol to cancel all orders for
  // * @return {promise or undefined} - omitting the callback returns a promise
  // */
  // async cancelOrders(symbol: string, params: Dict = {}) {
  //     const json = await this.privateSpotRequest('v3/openOrders', this.extend({ symbol: symbol }, params), 'DELETE');
  //     // if (json.length === 0) {
  //     //     return callback.call(this, 'No orders present for this symbol', {}, symbol);
  //     // }
  //     // if (Object.keys(json).length === 0) {
  //     //     return callback.call(this, 'No orders present for this symbol', {}, symbol);
  //     // }
  //     // for (let obj of json) {
  //     //     let quantity = obj.origQty - obj.executedQty;
  //     //     this.options.log('cancel order: ' + obj.side + ' ' + symbol + ' ' + quantity + ' @ ' + obj.price + ' #' + obj.orderId);
  //     //     signedRequest(this.getSpotUrl() + 'v3/order', { symbol: symbol, orderId: obj.orderId }, function (error, data) {
  //     //         return callback.call(this, error, data, symbol);
  //     //     }, 'DELETE');
  //     // }
  //     return json; // to do: check this logic of cancelling remaining orders manually
  // }
  /**
  * Gets all order of a given symbol
  * @see https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#all-orders-user_data
  * @param {string} symbol - the symbol
  * @param {object} options - additional options
  * @return {promise or undefined} - omitting the callback returns a promise
  */
  async allOrders(symbol, params = {}) {
    const parameters = this.extend({ symbol }, params);
    return await this.privateSpotRequest("v3/allOrders", parameters);
  }
  /**
   * Create a signed margin order
   * @see https://developers.binance.com/docs/margin_trading/trade/Margin-Account-New-Order
   * @param {string} side - BUY or SELL
   * @param {string} symbol - The symbol to buy or sell
   * @param {string} quantity - The quantity to buy or sell
   * @param {string} price - The price per unit to transact each unit at
   * @param {object} params - additional order settings
   * @return {undefined}
   */
  async marginOrder(type, side, symbol, quantity, price, params = {}) {
    let endpoint = "v1/margin/order";
    if (this.Options.test || params.test)
      endpoint += "/test";
    const request = {
      symbol,
      side,
      type,
      quantity
    };
    if (typeof params.type !== "undefined")
      request.type = params.type;
    if ("isIsolated" in params)
      request.isIsolated = params.isIsolated;
    if (request.type.includes("LIMIT")) {
      request.price = price;
      if (request.type !== "LIMIT_MAKER") {
        request.timeInForce = "GTC";
      }
    }
    if (typeof params.timeInForce !== "undefined")
      request.timeInForce = params.timeInForce;
    if (typeof params.newOrderRespType !== "undefined")
      request.newOrderRespType = params.newOrderRespType;
    if (typeof params.newClientOrderId !== "undefined") {
      request.newClientOrderId = params.newClientOrderId;
    } else {
      request.newClientOrderId = this.SPOT_PREFIX + this.uuid22();
    }
    if (typeof params.sideEffectType !== "undefined")
      request.sideEffectType = params.sideEffectType;
    if (typeof params.icebergQty !== "undefined")
      request.icebergQty = params.icebergQty;
    if (typeof params.stopPrice !== "undefined") {
      request.stopPrice = params.stopPrice;
      if (request.type === "LIMIT")
        throw Error('stopPrice: Must set "type" to one of the following: STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, TAKE_PROFIT_LIMIT');
    }
    return await this.privateSpotRequest(endpoint, this.extend(request, params), "POST");
  }
  // Futures internal functions
  /**
   * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/New-Order
   * @param type
   * @param side
   * @param symbol symbol if the market
   * @param quantity
   * @param price
   * @param params extra parameters to be sent in the request
   * @returns
   */
  async futuresOrder(type, side, symbol, quantity, price, params = {}) {
    params.symbol = symbol;
    params.side = side;
    params.type = type;
    if (quantity)
      params.quantity = quantity;
    if (!params.positionSide && this.Options.hedgeMode) {
      params.positionSide = side === "BUY" ? "LONG" : "SHORT";
    }
    if (price) {
      params.price = price;
    }
    if (!params.timeInForce && (params.type.includes("LIMIT") || params.type === "STOP" || params.type === "TAKE_PROFIT")) {
      params.timeInForce = "GTX";
    }
    if (!params.newClientOrderId) {
      params.newClientOrderId = this.CONTRACT_PREFIX + this.uuid22();
    }
    return await this.privateFuturesRequest("v1/order", params, "POST");
  }
  async deliveryOrder(type, side, symbol, quantity, price, params = {}) {
    params.symbol = symbol;
    params.side = side;
    params.quantity = quantity;
    params.type = type;
    if (this.Options.hedgeMode) {
      params.positionSide = side === "BUY" ? "LONG" : "SHORT";
    }
    if (price) {
      params.price = price;
      if (!params.type)
        params.type = "LIMIT";
    } else {
      if (!params.type)
        params.type = "MARKET";
    }
    if (!params.timeInForce && (params.type.includes("LIMIT") || params.type === "STOP" || params.type === "TAKE_PROFIT")) {
      params.timeInForce = "GTX";
    }
    if (!params.newClientOrderId) {
      params.newClientOrderId = this.CONTRACT_PREFIX + this.uuid22();
    }
    return await this.privateDeliveryRequest("v1/order", params, "POST");
  }
  // ------ WS RELATED FUNCTIONS ------ //
  noop() {
    return;
  }
  /**
   * Reworked Tuitio's heartbeat code into a shared single interval tick
   * @return {undefined}
   */
  socketHeartbeat() {
    for (const endpointId in this.subscriptions) {
      const ws = this.subscriptions[endpointId];
      if (ws.isAlive) {
        ws.isAlive = false;
        if (ws.readyState === import_ws.default.OPEN)
          ws.ping(this.noop);
      } else {
        if (this.Options.verbose)
          this.Options.log("Terminating inactive/broken WebSocket: " + ws.endpoint);
        if (ws.readyState === import_ws.default.OPEN)
          ws.terminate();
      }
    }
  }
  /**
   * Called when socket is opened, subscriptions are registered for later reference
   * @param {function} opened_callback - a callback function
   * @return {undefined}
   */
  handleSocketOpen(wsBind, opened_callback) {
    wsBind.isAlive = true;
    if (Object.keys(this.subscriptions).length === 0) {
      this.socketHeartbeatInterval = setInterval(this.socketHeartbeat, this.heartBeatInterval);
    }
    this.subscriptions[wsBind.url] = wsBind;
    if (typeof opened_callback === "function")
      opened_callback(wsBind.url);
  }
  /**
   * Called when socket is closed, subscriptions are de-registered for later reference
   * @param {Function} reconnect - reconnect callback
   * @param {string} code - code associated with the socket
   * @param {string} reason - string with the response
   * @return {undefined}
   */
  handleSocketClose(wsBind, reconnect, code, reason) {
    delete this.subscriptions[wsBind.url];
    if (this.subscriptions && Object.keys(this.subscriptions).length === 0) {
      clearInterval(this.socketHeartbeatInterval);
    }
    this.Options.log("WebSocket closed: " + wsBind.url + (code ? " (" + code + ")" : "") + (reason ? " " + reason : ""));
    if (this.Options.reconnect && wsBind.reconnect && reconnect) {
      if (wsBind.url && wsBind.url.length === 60)
        this.Options.log("Account data WebSocket reconnecting...");
      else
        this.Options.log("WebSocket reconnecting: " + wsBind.url + "...");
      try {
        reconnect();
      } catch (error) {
        this.Options.log("WebSocket reconnect error: " + error.message);
      }
    }
  }
  /**
  * Called when socket errors
  * @param {object} error - error object message
  * @return {undefined}
  */
  handleSocketError(wsBind, error) {
    this.Options.log("WebSocket error: " + wsBind.url + (error.code ? " (" + error.code + ")" : "") + (error.message ? " " + error.message : ""));
  }
  /**
   * Called on each socket heartbeat
   * @return {undefined}
   */
  handleSocketHeartbeat(wsBind) {
    wsBind.isAlive = true;
  }
  // ----- WS ENDPOINTS ----- //
  /**
  * Get Binance server time
  * @return {promise or undefined} - omitting the callback returns a promise
  */
  async time() {
    const res = await this.publicSpotRequest("v3/time", {});
    return res;
  }
  /**
   * Used to subscribe to a single websocket endpoint
   * @param {string} endpoint - endpoint to connect to
   * @param {function} callback - the function to call when information is received
   * @param {boolean} reconnect - whether to reconnect on disconnect
   * @param {object} opened_callback - the function to call when opened
   * @return {WebSocket} - websocket reference
   */
  subscribe(endpoint, callback, reconnect, opened_callback) {
    const httpsproxy = this.getHttpsProxy();
    let socksproxy = this.getSocksProxy();
    let ws = void 0;
    if (socksproxy) {
      socksproxy = this.proxyReplacewithIp(socksproxy);
      if (this.Options.verbose)
        this.Options.log("using socks proxy server " + socksproxy);
      const agent = new import_socks_proxy_agent.SocksProxyAgent({
        protocol: this.parseProxy(socksproxy)[0],
        host: this.parseProxy(socksproxy)[1],
        port: this.parseProxy(socksproxy)[2]
      });
      ws = new import_ws.default(this.stream + endpoint, { agent });
    } else if (httpsproxy) {
      const config2 = import_url.default.parse(httpsproxy);
      const agent = new import_https_proxy_agent.HttpsProxyAgent(config2);
      if (this.Options.verbose)
        this.Options.log("using proxy server " + agent);
      ws = new import_ws.default(this.stream + endpoint, { agent });
    } else {
      ws = new import_ws.default(this.stream + endpoint);
    }
    if (this.Options.verbose)
      this.Options.log("Subscribed to " + endpoint);
    ws.reconnect = this.Options.reconnect;
    ws.endpoint = endpoint;
    ws.isAlive = false;
    ws.on("open", this.handleSocketOpen.bind(this, ws, opened_callback));
    ws.on("pong", this.handleSocketHeartbeat.bind(this, ws));
    ws.on("error", this.handleSocketError.bind(this, ws));
    ws.on("close", this.handleSocketClose.bind(this, ws, reconnect));
    ws.on("message", (data) => {
      try {
        if (this.Options.verbose)
          this.Options.log("WebSocket data:", data);
        callback(import_json_bigint.default.parse(data));
      } catch (error) {
        this.Options.log("Parse error: " + error.message);
      }
    });
    return ws;
  }
  /**
   * Used to subscribe to a combined websocket endpoint
   * @param {string} streams - streams to connect to
   * @param {function} callback - the function to call when information is received
   * @param {boolean} reconnect - whether to reconnect on disconnect
   * @param {object} opened_callback - the function to call when opened
   * @return {WebSocket} - websocket reference
   */
  subscribeCombined(streams, callback, reconnect, opened_callback) {
    const httpsproxy = this.getHttpsProxy();
    let socksproxy = this.getSocksProxy();
    const queryParams = streams.join("/");
    let ws = void 0;
    if (socksproxy) {
      socksproxy = this.proxyReplacewithIp(socksproxy);
      if (this.Options.verbose)
        this.Options.log("using socks proxy server " + socksproxy);
      const agent = new import_socks_proxy_agent.SocksProxyAgent({
        protocol: this.parseProxy(socksproxy)[0],
        host: this.parseProxy(socksproxy)[1],
        port: this.parseProxy(socksproxy)[2]
      });
      ws = new import_ws.default(this.combineStream + queryParams, { agent });
    } else if (httpsproxy) {
      if (this.Options.verbose)
        this.Options.log("using proxy server " + httpsproxy);
      const config2 = import_url.default.parse(httpsproxy);
      const agent = new import_https_proxy_agent.HttpsProxyAgent(config2);
      ws = new import_ws.default(this.combineStream + queryParams, { agent });
    } else {
      ws = new import_ws.default(this.combineStream + queryParams);
    }
    ws.reconnect = this.Options.reconnect;
    ws.endpoint = (0, import_string_hash.default)(queryParams);
    ws.isAlive = false;
    if (this.Options.verbose) {
      this.Options.log("CombinedStream: Subscribed to [" + ws.endpoint + "] " + queryParams);
    }
    ws.on("open", this.handleSocketOpen.bind(this, ws, opened_callback));
    ws.on("pong", this.handleSocketHeartbeat.bind(this, ws));
    ws.on("error", this.handleSocketError.bind(this, ws));
    ws.on("close", this.handleSocketClose.bind(this, ws, reconnect));
    ws.on("message", (data) => {
      try {
        if (this.Options.verbose)
          this.Options.log("CombinedStream: WebSocket data:", data);
        callback(import_json_bigint.default.parse(data).data);
      } catch (error) {
        this.Options.log("CombinedStream: Parse error: " + error.message);
      }
    });
    return ws;
  }
  /**
   * Used to terminate a web socket
   * @param {string} endpoint - endpoint identifier associated with the web socket
   * @param {boolean} reconnect - auto reconnect after termination
   * @return {undefined}
   */
  terminate(endpoint, reconnect = false) {
    if (this.Options.verbose)
      this.Options.log("WebSocket terminating:", endpoint);
    const ws = this.subscriptions[endpoint];
    if (!ws)
      return;
    ws.removeAllListeners("message");
    ws.reconnect = reconnect;
    ws.terminate();
  }
  /**
   * Futures heartbeat code with a shared single interval tick
   * @return {undefined}
   */
  futuresSocketHeartbeat() {
    for (const endpointId in this.futuresSubscriptions) {
      const ws = this.futuresSubscriptions[endpointId];
      if (ws.isAlive) {
        ws.isAlive = false;
        if (ws.readyState === import_ws.default.OPEN)
          ws.ping(this.noop);
      } else {
        if (this.Options.verbose)
          this.Options.log(`Terminating zombie futures WebSocket: ${ws.endpoint}`);
        if (ws.readyState === import_ws.default.OPEN)
          ws.terminate();
      }
    }
  }
  /**
   * Called when a futures socket is opened, subscriptions are registered for later reference
   * @param {function} openCallback - a callback function
   * @return {undefined}
   */
  handleFuturesSocketOpen(wsBind, openCallback) {
    wsBind.isAlive = true;
    if (Object.keys(this.futuresSubscriptions).length === 0) {
      this.socketHeartbeatInterval = setInterval(this.futuresSocketHeartbeat, this.heartBeatInterval);
    }
    this.futuresSubscriptions[wsBind.url] = wsBind;
    if (typeof openCallback === "function")
      openCallback(wsBind.url);
  }
  /**
   * Called when futures websocket is closed, subscriptions are de-registered for later reference
   * @param {boolean} reconnect - true or false to reconnect the socket
   * @param {string} code - code associated with the socket
   * @param {string} reason - string with the response
   * @return {undefined}
   */
  handleFuturesSocketClose(wsBind, reconnect, code, reason) {
    delete this.futuresSubscriptions[wsBind.url];
    if (this.futuresSubscriptions && Object.keys(this.futuresSubscriptions).length === 0) {
      clearInterval(this.socketHeartbeatInterval);
    }
    this.Options.log("Futures WebSocket closed: " + wsBind.url + (code ? " (" + code + ")" : "") + (reason ? " " + reason : ""));
    if (this.Options.reconnect && wsBind.reconnect && reconnect) {
      if (wsBind.url && wsBind.url.length === 60)
        this.Options.log("Futures account data WebSocket reconnecting...");
      else
        this.Options.log("Futures WebSocket reconnecting: " + wsBind.url + "...");
      try {
        reconnect();
      } catch (error) {
        this.Options.log("Futures WebSocket reconnect error: " + error.message);
      }
    }
  }
  /**
   * Called when a futures websocket errors
   * @param {object} error - error object message
   * @return {undefined}
   */
  handleFuturesSocketError(wsBind, error) {
    this.Options.log("Futures WebSocket error: " + wsBind.url + (error.code ? " (" + error.code + ")" : "") + (error.message ? " " + error.message : ""));
  }
  /**
   * Called on each futures socket heartbeat
   * @return {undefined}
   */
  handleFuturesSocketHeartbeat(wsBind) {
    wsBind.isAlive = true;
  }
  /**
   * Used to subscribe to a single futures websocket endpoint
   * @param {string} endpoint - endpoint to connect to
   * @param {function} callback - the function to call when information is received
   * @param {object} params - Optional reconnect {boolean} (whether to reconnect on disconnect), openCallback {function}, id {string}
   * @return {WebSocket} - websocket reference
   */
  futuresSubscribeSingle(endpoint, callback, params = {}) {
    if (typeof params === "boolean")
      params = { reconnect: params };
    if (!params.reconnect)
      params.reconnect = false;
    if (!params.openCallback)
      params.openCallback = false;
    if (!params.id)
      params.id = false;
    const httpsproxy = this.getHttpsProxy();
    let socksproxy = this.getSocksProxy();
    let ws = void 0;
    if (socksproxy) {
      socksproxy = this.proxyReplacewithIp(socksproxy);
      if (this.Options.verbose)
        this.Options.log(`futuresSubscribeSingle: using socks proxy server: ${socksproxy}`);
      const agent = new import_socks_proxy_agent.SocksProxyAgent({
        protocol: this.parseProxy(socksproxy)[0],
        host: this.parseProxy(socksproxy)[1],
        port: this.parseProxy(socksproxy)[2]
      });
      ws = new import_ws.default((this.Options.test ? this.fstreamSingleTest : this.fstreamSingle) + endpoint, { agent });
    } else if (httpsproxy) {
      const config2 = import_url.default.parse(httpsproxy);
      const agent = new import_https_proxy_agent.HttpsProxyAgent(config2);
      if (this.Options.verbose)
        this.Options.log(`futuresSubscribeSingle: using proxy server: ${agent}`);
      ws = new import_ws.default((this.Options.test ? this.fstreamSingleTest : this.fstreamSingle) + endpoint, { agent });
    } else {
      ws = new import_ws.default((this.Options.test ? this.fstreamSingleTest : this.fstreamSingle) + endpoint);
    }
    if (this.Options.verbose)
      this.Options.log("futuresSubscribeSingle: Subscribed to " + endpoint);
    callback = callback.bind(this);
    ws.reconnect = this.Options.reconnect;
    ws.endpoint = endpoint;
    ws.isAlive = false;
    ws.on("open", this.handleFuturesSocketOpen.bind(this, ws, params.openCallback));
    ws.on("pong", this.handleFuturesSocketHeartbeat.bind(this, ws));
    ws.on("error", this.handleFuturesSocketError.bind(this, ws));
    ws.on("close", this.handleFuturesSocketClose.bind(this, ws, params.reconnect));
    ws.on("message", (data) => {
      try {
        if (this.Options.verbose)
          this.Options.log("futuresSubscribeSingle: Received data:", data);
        callback(import_json_bigint.default.parse(data));
      } catch (error) {
        this.Options.log("Parse error: " + error.message);
      }
    });
    return ws;
  }
  /**
   * Used to subscribe to a combined futures websocket endpoint
   * @param {string} streams - streams to connect to
   * @param {function} callback - the function to call when information is received
   * @param {object} params - Optional reconnect {boolean} (whether to reconnect on disconnect), openCallback {function}, id {string}
   * @return {WebSocket} - websocket reference
   */
  futuresSubscribe(streams, callback, params = {}) {
    if (typeof streams === "string")
      return this.futuresSubscribeSingle(streams, callback, params);
    if (typeof params === "boolean")
      params = { reconnect: params };
    if (!params.reconnect)
      params.reconnect = false;
    if (!params.openCallback)
      params.openCallback = false;
    if (!params.id)
      params.id = false;
    const httpsproxy = this.getHttpsProxy();
    let socksproxy = this.getSocksProxy();
    const queryParams = streams.join("/");
    let ws = void 0;
    if (socksproxy) {
      socksproxy = this.proxyReplacewithIp(socksproxy);
      if (this.Options.verbose)
        this.Options.log(`futuresSubscribe: using socks proxy server ${socksproxy}`);
      const agent = new import_socks_proxy_agent.SocksProxyAgent({
        protocol: this.parseProxy(socksproxy)[0],
        host: this.parseProxy(socksproxy)[1],
        port: this.parseProxy(socksproxy)[2]
      });
      ws = new import_ws.default((this.Options.test ? this.fstreamTest : this.fstream) + queryParams, { agent });
    } else if (httpsproxy) {
      if (this.Options.verbose)
        this.Options.log(`futuresSubscribe: using proxy server ${httpsproxy}`);
      const config2 = import_url.default.parse(httpsproxy);
      const agent = new import_https_proxy_agent.HttpsProxyAgent(config2);
      ws = new import_ws.default((this.Options.test ? this.fstreamTest : this.fstream) + queryParams, { agent });
    } else {
      ws = new import_ws.default((this.Options.test ? this.fstreamTest : this.fstream) + queryParams);
    }
    ws.reconnect = this.Options.reconnect;
    ws.endpoint = (0, import_string_hash.default)(queryParams);
    ws.isAlive = false;
    if (this.Options.verbose) {
      this.Options.log(`futuresSubscribe: Subscribed to [${ws.endpoint}] ${queryParams}`);
    }
    ws.on("open", this.handleFuturesSocketOpen.bind(this, ws, params.openCallback));
    ws.on("pong", this.handleFuturesSocketHeartbeat.bind(this, ws));
    ws.on("error", this.handleFuturesSocketError.bind(this, ws));
    ws.on("close", this.handleFuturesSocketClose.bind(this, ws, params.reconnect));
    ws.on("message", (data) => {
      try {
        if (this.Options.verbose)
          this.Options.log("futuresSubscribe: Received data:", data);
        callback(import_json_bigint.default.parse(data).data);
      } catch (error) {
        this.Options.log(`futuresSubscribe: Parse error: ${error.message}`);
      }
    });
    return ws;
  }
  /**
   * Used to terminate a futures websocket
   * @param {string} endpoint - endpoint identifier associated with the web socket
   * @param {boolean} reconnect - auto reconnect after termination
   * @return {undefined}
   */
  futuresTerminate(endpoint, reconnect = false) {
    if (this.Options.verbose)
      this.Options.log("Futures WebSocket terminating:", endpoint);
    const ws = this.futuresSubscriptions[endpoint];
    if (!ws)
      return;
    ws.removeAllListeners("message");
    ws.reconnect = reconnect;
    ws.terminate();
  }
  /**
   * Combines all futures OHLC data with the latest update
   * @param {string} symbol - the symbol
   * @param {string} interval - time interval
   * @return {array} - interval data for given symbol
   */
  futuresKlineConcat(symbol, interval2) {
    const output = this.futuresTicks[symbol][interval2];
    if (!this.futuresRealtime[symbol][interval2].time)
      return output;
    const time = this.futuresRealtime[symbol][interval2].time;
    const last_updated = Object.keys(this.futuresTicks[symbol][interval2]).pop();
    if (time >= last_updated) {
      output[time] = this.futuresRealtime[symbol][interval2];
      output[last_updated].isFinal = true;
      output[time].isFinal = false;
    }
    return output;
  }
  /**
   * Used for websocket futures @kline
   * @param {string} symbol - the symbol
   * @param {object} kline - object with kline info
   * @param {string} firstTime - time filter
   * @return {undefined}
   */
  futuresKlineHandler(symbol, kline, firstTime = 0) {
    const { e: eventType, E: eventTime, k: ticks } = kline;
    const { o: open, h: high, l: low, c: close, v: volume, i: interval2, x: isFinal, q: quoteVolume, V: takerBuyBaseVolume, Q: takerBuyQuoteVolume, n: trades, t: time, T: closeTime } = ticks;
    if (time <= firstTime)
      return;
    if (!isFinal) {
      this.futuresRealtime[symbol][interval2] = { time, closeTime, open, high, low, close, volume, quoteVolume, takerBuyBaseVolume, takerBuyQuoteVolume, trades, isFinal };
      return;
    }
    const first_updated = Object.keys(this.futuresTicks[symbol][interval2]).shift();
    if (first_updated)
      delete this.futuresTicks[symbol][interval2][first_updated];
    this.futuresTicks[symbol][interval2][time] = { time, closeTime, open, high, low, close, volume, quoteVolume, takerBuyBaseVolume, takerBuyQuoteVolume, trades, isFinal: false };
  }
  /**
   * Converts the futures liquidation stream data into a friendly object
   * @param {object} data - liquidation data callback data type
   * @return {object} - user friendly data type
   */
  fLiquidationConvertData(data) {
    const eventType = data.e, eventTime = data.E;
    const { s: symbol, S: side, o: orderType, f: timeInForce, q: origAmount, p: price, ap: avgPrice, X: orderStatus, l: lastFilledQty, z: totalFilledQty, T: tradeTime } = data.o;
    return { symbol, side, orderType, timeInForce, origAmount, price, avgPrice, orderStatus, lastFilledQty, totalFilledQty, eventType, tradeTime, eventTime };
  }
  /**
   * Converts the futures ticker stream data into a friendly object
   * @param {object} data - user data callback data type
   * @return {object} - user friendly data type
   */
  fTickerConvertData(data) {
    const friendlyData = (data2) => {
      const { e: eventType, E: eventTime, s: symbol, p: priceChange, P: percentChange, w: averagePrice, c: close, Q: closeQty, o: open, h: high, l: low, v: volume, q: quoteVolume, O: openTime, C: closeTime, F: firstTradeId, L: lastTradeId, n: numTrades } = data2;
      return {
        eventType,
        eventTime,
        symbol,
        priceChange,
        percentChange,
        averagePrice,
        close,
        closeQty,
        open,
        high,
        low,
        volume,
        quoteVolume,
        openTime,
        closeTime,
        firstTradeId,
        lastTradeId,
        numTrades
      };
    };
    if (Array.isArray(data)) {
      const result = [];
      for (const obj of data) {
        result.push(friendlyData(obj));
      }
      return result;
    }
    return friendlyData(data);
  }
  /**
   * Converts the futures miniTicker stream data into a friendly object
   * @param {object} data - user data callback data type
   * @return {object} - user friendly data type
   */
  fMiniTickerConvertData(data) {
    const friendlyData = (data2) => {
      const { e: eventType, E: eventTime, s: symbol, c: close, o: open, h: high, l: low, v: volume, q: quoteVolume } = data2;
      return {
        eventType,
        eventTime,
        symbol,
        close,
        open,
        high,
        low,
        volume,
        quoteVolume
      };
    };
    if (Array.isArray(data)) {
      const result = [];
      for (const obj of data) {
        result.push(friendlyData(obj));
      }
      return result;
    }
    return friendlyData(data);
  }
  /**
   * Converts the futures bookTicker stream data into a friendly object
   * @param {object} data - user data callback data type
   * @return {object} - user friendly data type
   */
  fBookTickerConvertData(data) {
    const { u: updateId, s: symbol, b: bestBid, B: bestBidQty, a: bestAsk, A: bestAskQty } = data;
    return {
      updateId,
      symbol,
      bestBid,
      bestBidQty,
      bestAsk,
      bestAskQty
    };
  }
  /**
   * Converts the futures UserData stream MARGIN_CALL data into a friendly object
   * @param {object} data - user data callback data type
   * @return {object} - user friendly data type
   */
  fUserDataMarginConvertData(data) {
    const {
      e: eventType,
      E: eventTime,
      cw: crossWalletBalance
      // only pushed with crossed position margin call
      // p: positions
    } = data;
    let { positions } = data;
    const positionConverter = (position) => {
      const {
        s: symbol,
        ps: positionSide,
        pa: positionAmount,
        mt: marginType,
        iw: isolatedWallet,
        // if isolated position
        mp: markPrice,
        up: unrealizedPnL,
        mm: maintenanceMargin
        // maintenance margin required
      } = position;
      return {
        symbol,
        positionSide,
        positionAmount,
        marginType,
        isolatedWallet,
        markPrice,
        unrealizedPnL,
        maintenanceMargin
      };
    };
    const convertedPositions = [];
    for (const position of positions) {
      convertedPositions.push(positionConverter(position));
    }
    positions = convertedPositions;
    return {
      eventType,
      eventTime,
      crossWalletBalance,
      positions
    };
  }
  /**
   * Converts the futures UserData stream ACCOUNT_CONFIG_UPDATE into a friendly object
   * @param {object} data - user config callback data type
   * @return {object} - user friendly data type
   */
  fUserConfigDataAccountUpdateConvertData(data) {
    return {
      eventType: data.e,
      eventTime: data.E,
      transactionTime: data.T,
      ac: {
        symbol: data.ac.s,
        leverage: data.ac.l
      }
    };
  }
  /**
   * Converts the futures UserData stream ACCOUNT_UPDATE data into a friendly object
   * @param {object} data - user data callback data type
   * @return {object} - user friendly data type
   */
  fUserDataAccountUpdateConvertData(data) {
    const { e: eventType, E: eventTime, T: transaction } = data;
    let { a: updateData } = data;
    const updateConverter = (updateData2) => {
      const { m: eventReasonType } = data;
      let {
        // m: eventReasonType,
        B: balances,
        P: positions
      } = updateData2;
      const positionConverter = (position) => {
        const {
          s: symbol,
          pa: positionAmount,
          ep: entryPrice,
          cr: accumulatedRealized,
          // (Pre-fee) Accumulated Realized
          up: unrealizedPnL,
          mt: marginType,
          iw: isolatedWallet,
          // if isolated position
          ps: positionSide
        } = position;
        return {
          symbol,
          positionAmount,
          entryPrice,
          accumulatedRealized,
          unrealizedPnL,
          marginType,
          isolatedWallet,
          positionSide
        };
      };
      const balanceConverter = (balance) => {
        const { a: asset, wb: walletBalance, cw: crossWalletBalance, bc: balanceChange } = balance;
        return {
          asset,
          walletBalance,
          crossWalletBalance,
          balanceChange
        };
      };
      const balanceResult = [];
      const positionResult = [];
      for (const balance of balances) {
        balanceResult.push(balanceConverter(balance));
      }
      for (const position of positions) {
        positionResult.push(positionConverter(position));
      }
      balances = balanceResult;
      positions = positionResult;
      return {
        eventReasonType,
        balances,
        positions
      };
    };
    updateData = updateConverter(updateData);
    return {
      eventType,
      eventTime,
      transaction,
      updateData
    };
  }
  /**
   * Converts the futures UserData stream ORDER_TRADE_UPDATE data into a friendly object
   * @param {object} data - user data callback data type
   * @return {object} - user friendly data type
   */
  fUserDataOrderUpdateConvertData(data) {
    const {
      e: eventType,
      E: eventTime,
      T: transaction
      // transaction time
    } = data;
    let { o: order } = data;
    const orderConverter = (order2) => {
      const {
        s: symbol,
        c: clientOrderId,
        // special client order id:
        // starts with "autoclose-": liquidation order
        // "adl_autoclose": ADL auto close order
        S: side,
        o: orderType,
        f: timeInForce,
        q: originalQuantity,
        p: originalPrice,
        ap: averagePrice,
        sp: stopPrice,
        // please ignore with TRAILING_STOP_MARKET order,
        x: executionType,
        X: orderStatus,
        i: orderId,
        l: orderLastFilledQuantity,
        z: orderFilledAccumulatedQuantity,
        L: lastFilledPrice,
        N: commissionAsset,
        // will not push if no commission
        n: commission,
        // will not push if no commission
        T: orderTradeTime,
        t: tradeId,
        b: bidsNotional,
        a: askNotional,
        m: isMakerSide,
        // is this trade maker side
        R: isReduceOnly,
        // is this reduce only
        wt: stopPriceWorkingType,
        ot: originalOrderType,
        ps: positionSide,
        cp: closeAll,
        // if close-all, pushed with conditional order
        AP: activationPrice,
        // only pushed with TRAILING_STOP_MARKET order
        cr: callbackRate,
        // only pushed with TRAILING_STOP_MARKET order
        rp: realizedProfit
      } = order2;
      return {
        symbol,
        clientOrderId,
        side,
        orderType,
        timeInForce,
        originalQuantity,
        originalPrice,
        averagePrice,
        stopPrice,
        executionType,
        orderStatus,
        orderId,
        orderLastFilledQuantity,
        orderFilledAccumulatedQuantity,
        lastFilledPrice,
        commissionAsset,
        commission,
        orderTradeTime,
        tradeId,
        bidsNotional,
        askNotional,
        isMakerSide,
        isReduceOnly,
        stopPriceWorkingType,
        originalOrderType,
        positionSide,
        closeAll,
        activationPrice,
        callbackRate,
        realizedProfit
      };
    };
    order = orderConverter(order);
    return {
      eventType,
      eventTime,
      transaction,
      order
    };
  }
  /**
   * Converts the futures markPrice stream data into a friendly object
   * @param {object} data - user data callback data type
   * @return {object} - user friendly data type
   */
  fMarkPriceConvertData(data) {
    const friendlyData = (data2) => {
      const { e: eventType, E: eventTime, s: symbol, p: markPrice, i: indexPrice, r: fundingRate, T: fundingTime } = data2;
      return {
        eventType,
        eventTime,
        symbol,
        markPrice,
        indexPrice,
        fundingRate,
        fundingTime
      };
    };
    if (Array.isArray(data)) {
      const result = [];
      for (const obj of data) {
        result.push(friendlyData(obj));
      }
      return result;
    }
    return friendlyData(data);
  }
  /**
   * Converts the futures aggTrade stream data into a friendly object
   * @param {object} data - user data callback data type
   * @return {object} - user friendly data type
   */
  fAggTradeConvertData(data) {
    const friendlyData = (data2) => {
      const { e: eventType, E: eventTime, s: symbol, a: aggTradeId, p: price, q: amount, f: firstTradeId, l: lastTradeId, T: timestamp, m: maker } = data2;
      return {
        eventType,
        eventTime,
        symbol,
        aggTradeId,
        price,
        amount,
        total: price * amount,
        firstTradeId,
        lastTradeId,
        timestamp,
        maker
      };
    };
    if (Array.isArray(data)) {
      const result = [];
      for (const obj of data) {
        result.push(friendlyData(obj));
      }
      return result;
    }
    return friendlyData(data);
  }
  /**
   * Delivery heartbeat code with a shared single interval tick
   * @return {undefined}
   */
  deliverySocketHeartbeat() {
    for (const endpointId in this.deliverySubscriptions) {
      const ws = this.deliverySubscriptions[endpointId];
      if (ws.isAlive) {
        ws.isAlive = false;
        if (ws.readyState === import_ws.default.OPEN)
          ws.ping(this.noop);
      } else {
        if (this.Options.verbose)
          this.Options.log(`Terminating zombie delivery WebSocket: ${ws.endpoint}`);
        if (ws.readyState === import_ws.default.OPEN)
          ws.terminate();
      }
    }
  }
  /**
   * Called when a delivery socket is opened, subscriptions are registered for later reference
   * @param {function} openCallback - a callback function
   * @return {undefined}
   */
  handleDeliverySocketOpen(wsBind, openCallback) {
    this.isAlive = true;
    if (Object.keys(this.deliverySubscriptions).length === 0) {
      this.socketHeartbeatInterval = setInterval(this.deliverySocketHeartbeat, 3e4);
    }
    this.deliverySubscriptions[wsBind.url] = this;
    if (typeof openCallback === "function")
      openCallback(wsBind.url);
  }
  /**
   * Called when delivery websocket is closed, subscriptions are de-registered for later reference
   * @param {boolean} reconnect - true or false to reconnect the socket
   * @param {string} code - code associated with the socket
   * @param {string} reason - string with the response
   * @return {undefined}
   */
  handleDeliverySocketClose(wsBind, reconnect, code, reason) {
    delete this.deliverySubscriptions[wsBind.url];
    if (this.deliverySubscriptions && Object.keys(this.deliverySubscriptions).length === 0) {
      clearInterval(this.socketHeartbeatInterval);
    }
    this.Options.log("Delivery WebSocket closed: " + wsBind.url + (code ? " (" + code + ")" : "") + (reason ? " " + reason : ""));
    if (this.Options.reconnect && wsBind.reconnect && reconnect) {
      if (wsBind.url && wsBind.url.length === 60)
        this.Options.log("Delivery account data WebSocket reconnecting...");
      else
        this.Options.log("Delivery WebSocket reconnecting: " + wsBind.url + "...");
      try {
        reconnect();
      } catch (error) {
        this.Options.log("Delivery WebSocket reconnect error: " + error.message);
      }
    }
  }
  /**
   * Called when a delivery websocket errors
   * @param {object} error - error object message
   * @return {undefined}
   */
  handleDeliverySocketError(wsBind, error) {
    this.Options.log("Delivery WebSocket error: " + wsBind.url + (error.code ? " (" + error.code + ")" : "") + (error.message ? " " + error.message : ""));
  }
  /**
   * Called on each delivery socket heartbeat
   * @return {undefined}
   */
  handleDeliverySocketHeartbeat() {
    this.isAlive = true;
  }
  /**
   * Used to subscribe to a single delivery websocket endpoint
   * @param {string} endpoint - endpoint to connect to
   * @param {function} callback - the function to call when information is received
   * @param {object} params - Optional reconnect {boolean} (whether to reconnect on disconnect), openCallback {function}, id {string}
   * @return {WebSocket} - websocket reference
   */
  deliverySubscribeSingle(endpoint, callback, params = {}) {
    if (typeof params === "boolean")
      params = { reconnect: params };
    if (!params.reconnect)
      params.reconnect = false;
    if (!params.openCallback)
      params.openCallback = false;
    if (!params.id)
      params.id = false;
    const httpsproxy = this.getHttpsProxy();
    let socksproxy = this.getSocksProxy();
    let ws = void 0;
    if (socksproxy) {
      socksproxy = this.proxyReplacewithIp(socksproxy);
      if (this.Options.verbose)
        this.Options.log(`deliverySubscribeSingle: using socks proxy server: ${socksproxy}`);
      const agent = new import_socks_proxy_agent.SocksProxyAgent({
        protocol: this.parseProxy(socksproxy)[0],
        host: this.parseProxy(socksproxy)[1],
        port: this.parseProxy(socksproxy)[2]
      });
      ws = new import_ws.default((this.Options.test ? this.dstreamSingleTest : this.dstreamSingle) + endpoint, { agent });
    } else if (httpsproxy) {
      const config2 = import_url.default.parse(httpsproxy);
      const agent = new import_https_proxy_agent.HttpsProxyAgent(config2);
      if (this.Options.verbose)
        this.Options.log(`deliverySubscribeSingle: using proxy server: ${agent}`);
      ws = new import_ws.default((this.Options.test ? this.dstreamSingleTest : this.dstreamSingle) + endpoint, { agent });
    } else {
      ws = new import_ws.default((this.Options.test ? this.dstreamSingleTest : this.dstreamSingle) + endpoint);
    }
    if (this.Options.verbose)
      this.Options.log("deliverySubscribeSingle: Subscribed to " + endpoint);
    ws.reconnect = this.Options.reconnect;
    ws.endpoint = endpoint;
    ws.isAlive = false;
    ws.on("open", this.handleDeliverySocketOpen.bind(this, ws, params.openCallback));
    ws.on("pong", this.handleDeliverySocketHeartbeat.bind(this, ws));
    ws.on("error", this.handleDeliverySocketError.bind(this, ws));
    ws.on("close", this.handleDeliverySocketClose.bind(this, ws, params.reconnect));
    ws.on("message", (data) => {
      try {
        if (this.Options.verbose)
          this.Options.log("deliverySubscribeSingle: Received data:", data);
        callback(import_json_bigint.default.parse(data));
      } catch (error) {
        this.Options.log("Parse error: " + error.message);
      }
    });
    return ws;
  }
  /**
   * Used to subscribe to a combined delivery websocket endpoint
   * @param {string} streams - streams to connect to
   * @param {function} callback - the function to call when information is received
   * @param {object} params - Optional reconnect {boolean} (whether to reconnect on disconnect), openCallback {function}, id {string}
   * @return {WebSocket} - websocket reference
   */
  deliverySubscribe(streams, callback, params = {}) {
    if (typeof streams === "string")
      return this.deliverySubscribeSingle(streams, callback, params);
    if (typeof params === "boolean")
      params = { reconnect: params };
    if (!params.reconnect)
      params.reconnect = false;
    if (!params.openCallback)
      params.openCallback = false;
    if (!params.id)
      params.id = false;
    const httpsproxy = this.getHttpsProxy();
    let socksproxy = this.getSocksProxy();
    const queryParams = streams.join("/");
    let ws = void 0;
    if (socksproxy) {
      socksproxy = this.proxyReplacewithIp(socksproxy);
      if (this.Options.verbose)
        this.Options.log(`deliverySubscribe: using socks proxy server ${socksproxy}`);
      const agent = new import_socks_proxy_agent.SocksProxyAgent({
        protocol: this.parseProxy(socksproxy)[0],
        host: this.parseProxy(socksproxy)[1],
        port: this.parseProxy(socksproxy)[2]
      });
      ws = new import_ws.default((this.Options.test ? this.dstreamTest : this.dstream) + queryParams, { agent });
    } else if (httpsproxy) {
      if (this.Options.verbose)
        this.Options.log(`deliverySubscribe: using proxy server ${httpsproxy}`);
      const config2 = import_url.default.parse(httpsproxy);
      const agent = new import_https_proxy_agent.HttpsProxyAgent(config2);
      ws = new import_ws.default((this.Options.test ? this.dstreamTest : this.dstream) + queryParams, { agent });
    } else {
      ws = new import_ws.default((this.Options.test ? this.dstreamTest : this.dstream) + queryParams);
    }
    ws.reconnect = this.Options.reconnect;
    ws.endpoint = (0, import_string_hash.default)(queryParams);
    ws.isAlive = false;
    if (this.Options.verbose) {
      this.Options.log(`deliverySubscribe: Subscribed to [${ws.endpoint}] ${queryParams}`);
    }
    ws.on("open", this.handleDeliverySocketOpen.bind(this, ws, params.openCallback));
    ws.on("pong", this.handleDeliverySocketHeartbeat.bind(this, ws));
    ws.on("error", this.handleDeliverySocketError.bind(this, ws));
    ws.on("close", this.handleDeliverySocketClose.bind(this, ws, params.reconnect));
    ws.on("message", (data) => {
      try {
        if (this.Options.verbose)
          this.Options.log("deliverySubscribe: Received data:", data);
        callback(import_json_bigint.default.parse(data).data);
      } catch (error) {
        this.Options.log(`deliverySubscribe: Parse error: ${error.message}`);
      }
    });
    return ws;
  }
  /**
   * Used to terminate a delivery websocket
   * @param {string} endpoint - endpoint identifier associated with the web socket
   * @param {boolean} reconnect - auto reconnect after termination
   * @return {undefined}
   */
  deliveryTerminate(endpoint, reconnect = false) {
    if (this.Options.verbose)
      this.Options.log("Delivery WebSocket terminating:", endpoint);
    const ws = this.deliverySubscriptions[endpoint];
    if (!ws)
      return;
    ws.removeAllListeners("message");
    ws.reconnect = reconnect;
    ws.terminate();
  }
  /**
   * Combines all delivery OHLC data with the latest update
   * @param {string} symbol - the symbol
   * @param {string} interval - time interval
   * @return {array} - interval data for given symbol
   */
  deliveryKlineConcat(symbol, interval2) {
    const output = this.deliveryTicks[symbol][interval2];
    if (typeof this.deliveryRealtime[symbol][interval2].time === "undefined")
      return output;
    const time = this.deliveryRealtime[symbol][interval2].time;
    const last_updated = Object.keys(this.deliveryTicks[symbol][interval2]).pop();
    if (time >= last_updated) {
      output[time] = this.deliveryRealtime[symbol][interval2];
      output[last_updated].isFinal = true;
      output[time].isFinal = false;
    }
    return output;
  }
  /**
   * Used for websocket delivery @kline
   * @param {string} symbol - the symbol
   * @param {object} kline - object with kline info
   * @param {string} firstTime - time filter
   * @return {undefined}
   */
  deliveryKlineHandler(symbol, kline, firstTime = 0) {
    const { e: eventType, E: eventTime, k: ticks } = kline;
    const { o: open, h: high, l: low, c: close, v: volume, i: interval2, x: isFinal, q: quoteVolume, V: takerBuyBaseVolume, Q: takerBuyQuoteVolume, n: trades, t: time, T: closeTime } = ticks;
    if (time <= firstTime)
      return;
    if (!isFinal) {
      this.deliveryRealtime[symbol][interval2] = { time, closeTime, open, high, low, close, volume, quoteVolume, takerBuyBaseVolume, takerBuyQuoteVolume, trades, isFinal };
      return;
    }
    const first_updated = Object.keys(this.deliveryTicks[symbol][interval2]).shift();
    if (first_updated)
      delete this.deliveryTicks[symbol][interval2][first_updated];
    this.deliveryTicks[symbol][interval2][time] = { time, closeTime, open, high, low, close, volume, quoteVolume, takerBuyBaseVolume, takerBuyQuoteVolume, trades, isFinal: false };
  }
  /**
   * Converts the delivery liquidation stream data into a friendly object
   * @param {object} data - liquidation data callback data type
   * @return {object} - user friendly data type
   */
  dLiquidationConvertData(data) {
    const eventType = data.e, eventTime = data.E;
    const { s: symbol, S: side, o: orderType, f: timeInForce, q: origAmount, p: price, ap: avgPrice, X: orderStatus, l: lastFilledQty, z: totalFilledQty, T: tradeTime } = data.o;
    return { symbol, side, orderType, timeInForce, origAmount, price, avgPrice, orderStatus, lastFilledQty, totalFilledQty, eventType, tradeTime, eventTime };
  }
  /**
   * Converts the delivery ticker stream data into a friendly object
   * @param {object} data - user data callback data type
   * @return {object} - user friendly data type
   */
  dTickerConvertData(data) {
    const friendlyData = (data2) => {
      const { e: eventType, E: eventTime, s: symbol, p: priceChange, P: percentChange, w: averagePrice, c: close, Q: closeQty, o: open, h: high, l: low, v: volume, q: quoteVolume, O: openTime, C: closeTime, F: firstTradeId, L: lastTradeId, n: numTrades } = data2;
      return {
        eventType,
        eventTime,
        symbol,
        priceChange,
        percentChange,
        averagePrice,
        close,
        closeQty,
        open,
        high,
        low,
        volume,
        quoteVolume,
        openTime,
        closeTime,
        firstTradeId,
        lastTradeId,
        numTrades
      };
    };
    if (Array.isArray(data)) {
      const result = [];
      for (const obj of data) {
        result.push(friendlyData(obj));
      }
      return result;
    }
    return friendlyData(data);
  }
  /**
   * Converts the delivery miniTicker stream data into a friendly object
   * @param {object} data - user data callback data type
   * @return {object} - user friendly data type
   */
  dMiniTickerConvertData(data) {
    const friendlyData = (data2) => {
      const { e: eventType, E: eventTime, s: symbol, c: close, o: open, h: high, l: low, v: volume, q: quoteVolume } = data2;
      return {
        eventType,
        eventTime,
        symbol,
        close,
        open,
        high,
        low,
        volume,
        quoteVolume
      };
    };
    if (Array.isArray(data)) {
      const result = [];
      for (const obj of data) {
        result.push(friendlyData(obj));
      }
      return result;
    }
    return friendlyData(data);
  }
  /**
   * Converts the delivery bookTicker stream data into a friendly object
   * @param {object} data - user data callback data type
   * @return {object} - user friendly data type
   */
  dBookTickerConvertData(data) {
    const { u: updateId, s: symbol, b: bestBid, B: bestBidQty, a: bestAsk, A: bestAskQty } = data;
    return {
      updateId,
      symbol,
      bestBid,
      bestBidQty,
      bestAsk,
      bestAskQty
    };
  }
  /**
   * Converts the delivery markPrice stream data into a friendly object
   * @param {object} data - user data callback data type
   * @return {object} - user friendly data type
   */
  dMarkPriceConvertData(data) {
    const friendlyData = (data2) => {
      const { e: eventType, E: eventTime, s: symbol, p: markPrice, r: fundingRate, T: fundingTime } = data2;
      return {
        eventType,
        eventTime,
        symbol,
        markPrice,
        fundingRate,
        fundingTime
      };
    };
    if (Array.isArray(data)) {
      const result = [];
      for (const obj of data) {
        result.push(friendlyData(obj));
      }
      return result;
    }
    return friendlyData(data);
  }
  /**
   * Converts the delivery aggTrade stream data into a friendly object
   * @param {object} data - user data callback data type
   * @return {object} - user friendly data type
   */
  dAggTradeConvertData(data) {
    const friendlyData = (data2) => {
      const { e: eventType, E: eventTime, s: symbol, a: aggTradeId, p: price, q: amount, f: firstTradeId, l: lastTradeId, T: timestamp, m: maker } = data2;
      return {
        eventType,
        eventTime,
        symbol,
        aggTradeId,
        price,
        amount,
        total: price * amount,
        firstTradeId,
        lastTradeId,
        timestamp,
        maker
      };
    };
    if (Array.isArray(data)) {
      const result = [];
      for (const obj of data) {
        result.push(friendlyData(obj));
      }
      return result;
    }
    return friendlyData(data);
  }
  /**
  * Converts the delivery UserData stream ORDER_TRADE_UPDATE data into a friendly object
  * @param {object} data - user data callback data type
  * @return {object} - user friendly data type
  */
  dUserDataOrderUpdateConvertData(data) {
    const {
      e: eventType,
      E: eventTime,
      T: transaction
      // transaction time
    } = data;
    let { o: order } = data;
    const orderConverter = (order2) => {
      const {
        s: symbol,
        c: clientOrderId,
        // special client order id:
        // starts with "autoclose-": liquidation order
        // "adl_autoclose": ADL auto close order
        S: side,
        o: orderType,
        f: timeInForce,
        q: originalQuantity,
        p: originalPrice,
        ap: averagePrice,
        sp: stopPrice,
        // please ignore with TRAILING_STOP_MARKET order,
        x: executionType,
        X: orderStatus,
        i: orderId,
        l: orderLastFilledQuantity,
        z: orderFilledAccumulatedQuantity,
        L: lastFilledPrice,
        ma: marginAsset,
        N: commissionAsset,
        // will not push if no commission
        n: commission,
        // will not push if no commission
        T: orderTradeTime,
        t: tradeId,
        rp: realizedProfit,
        b: bidsNotional,
        a: askNotional,
        m: isMakerSide,
        // is this trade maker side
        R: isReduceOnly,
        // is this reduce only
        wt: stopPriceWorkingType,
        ot: originalOrderType,
        ps: positionSide,
        cp: closeAll,
        // if close-all, pushed with conditional order
        AP: activationPrice,
        // only pushed with TRAILING_STOP_MARKET order
        cr: callbackRate,
        // only pushed with TRAILING_STOP_MARKET order
        pP: priceProtect
        // If conditional order trigger is protected
      } = order2;
      return {
        symbol,
        clientOrderId,
        side,
        orderType,
        timeInForce,
        originalQuantity,
        originalPrice,
        averagePrice,
        stopPrice,
        executionType,
        orderStatus,
        orderId,
        orderLastFilledQuantity,
        orderFilledAccumulatedQuantity,
        lastFilledPrice,
        marginAsset,
        commissionAsset,
        commission,
        orderTradeTime,
        tradeId,
        bidsNotional,
        askNotional,
        isMakerSide,
        isReduceOnly,
        stopPriceWorkingType,
        originalOrderType,
        positionSide,
        closeAll,
        activationPrice,
        callbackRate,
        realizedProfit,
        priceProtect
      };
    };
    order = orderConverter(order);
    return {
      eventType,
      eventTime,
      transaction,
      order
    };
  }
  /**
   * Used as part of the user data websockets callback
   * @param {object} data - user data callback data type
   * @return {undefined}
   */
  userDataHandler(data) {
    const type = data.e;
    this.Options.all_updates_callback(data);
    if (type === "outboundAccountInfo") {
    } else if (type === "executionReport") {
      if (this.Options.execution_callback)
        this.Options.execution_callback(data);
    } else if (type === "listStatus") {
      if (this.Options.list_status_callback)
        this.Options.list_status_callback(data);
    } else if (type === "outboundAccountPosition" || type === "balanceUpdate") {
      this.Options.balance_callback(data);
    } else {
      this.Options.log("Unexpected userData: " + type);
    }
  }
  /**
   * Used as part of the user data websockets callback
   * @param {object} data - user data callback data type
   * @return {undefined}
   */
  userMarginDataHandler(data) {
    const type = data.e;
    if (this.Options.margin_all_updates_callback)
      this.Options.all_updates_callback(data);
    if (type === "outboundAccountInfo") {
    } else if (type === "executionReport") {
      if (this.Options.margin_execution_callback)
        this.Options.margin_execution_callback(data);
    } else if (type === "listStatus") {
      if (this.Options.margin_list_status_callback)
        this.Options.margin_list_status_callback(data);
    } else if (type === "outboundAccountPosition" || type === "balanceUpdate") {
      this.Options.margin_balance_callback(data);
    }
  }
  /**
   * Used as part of the user data websockets callback
   * @param {object} data - user data callback data type
   * @return {undefined}
   */
  userFutureDataHandler(data) {
    const type = data.e;
    if (this.Options.futures_all_updates_callback)
      this.Options.futures_all_updates_callback(data);
    if (type === "MARGIN_CALL") {
      this.Options.future_margin_call_callback(this.fUserDataMarginConvertData(data));
    } else if (type === "ACCOUNT_UPDATE") {
      if (this.Options.future_account_update_callback) {
        this.Options.future_account_update_callback(this.fUserDataAccountUpdateConvertData(data));
      }
    } else if (type === "ORDER_TRADE_UPDATE" || type === "TRADE_LITE") {
      if (this.Options.future_order_update_callback) {
        this.Options.future_order_update_callback(this.fUserDataOrderUpdateConvertData(data));
      }
    } else if (type === "ACCOUNT_CONFIG_UPDATE") {
      if (this.Options.future_account_config_update_callback) {
        this.Options.future_account_config_update_callback(this.fUserConfigDataAccountUpdateConvertData(data));
      }
    }
  }
  /**
  * Used as part of the user data websockets callback
  * @param {object} data - user data callback data type
  * @return {undefined}
  */
  userDeliveryDataHandler(data) {
    const type = data.e;
    if (type === "MARGIN_CALL") {
      this.Options.delivery_margin_call_callback(this.fUserDataMarginConvertData(data));
    } else if (type === "ACCOUNT_UPDATE") {
      if (this.Options.delivery_account_update_callback) {
        this.Options.delivery_account_update_callback(this.fUserDataAccountUpdateConvertData(data));
      }
    } else if (type === "ORDER_TRADE_UPDATE") {
      if (this.Options.delivery_order_update_callback) {
        this.Options.delivery_order_update_callback(this.dUserDataOrderUpdateConvertData(data));
      }
    } else {
      this.Options.log("Unexpected userDeliveryData: " + type);
    }
  }
  /**
  * Universal Transfer requires API permissions enabled
  * @param {string} type - ENUM , example MAIN_UMFUTURE for SPOT to USDT futures, see https://binance-docs.github.io/apidocs/spot/en/#user-universal-transfer
  * @param {string} asset - the asset - example :USDT    *
  * @param {number} amount - the callback function
  * @return {promise}
  */
  async universalTransfer(type, asset, amount) {
    const parameters = Object.assign({
      asset,
      amount,
      type
    });
    return await this.privateSpotRequest("v1/asset/transfer", parameters, "POST");
  }
  /**
  * Transfer between main account and futures/delivery accounts
  * @param {string} asset - the asset
  * @param {number} amount - the asset
  * @param {object} options - additional options
  * @return {undefined}
  */
  async transferBetweenMainAndFutures(asset, amount, type) {
    const parameters = Object.assign({
      asset,
      amount,
      type
    });
    return await this.privateSpotRequest("v1/futures/transfer", parameters, "POST");
  }
  /**
   * Converts the previous day stream into friendly object
   * @param {object} data - user data callback data type
   * @return {object} - user friendly data type
   */
  prevDayConvertData(data) {
    const convertData = (data2) => {
      const { e: eventType, E: eventTime, s: symbol, p: priceChange, P: percentChange, w: averagePrice, x: prevClose, c: close, Q: closeQty, b: bestBid, B: bestBidQty, a: bestAsk, A: bestAskQty, o: open, h: high, l: low, v: volume, q: quoteVolume, O: openTime, C: closeTime, F: firstTradeId, L: lastTradeId, n: numTrades } = data2;
      return {
        eventType,
        eventTime,
        symbol,
        priceChange,
        percentChange,
        averagePrice,
        prevClose,
        close,
        closeQty,
        bestBid,
        bestBidQty,
        bestAsk,
        bestAskQty,
        open,
        high,
        low,
        volume,
        quoteVolume,
        openTime,
        closeTime,
        firstTradeId,
        lastTradeId,
        numTrades
      };
    };
    if (Array.isArray(data)) {
      const result = [];
      for (const obj of data) {
        const converted = convertData(obj);
        result.push(converted);
      }
      return result;
    } else {
      return convertData(data);
    }
  }
  /**
   * Parses the previous day stream and calls the user callback with friendly object
   * @param {object} data - user data callback data type
   * @param {function} callback - user data callback data type
   * @return {undefined}
   */
  prevDayStreamHandler(data, callback) {
    const converted = this.prevDayConvertData(data);
    callback(null, converted);
  }
  /**
   * Gets the price of a given symbol or symbols
   * @param {array} data - array of symbols
   * @return {array} - symbols with their current prices
   */
  priceData(data) {
    const prices = {};
    if (Array.isArray(data)) {
      for (const obj of data) {
        prices[obj.symbol] = obj.price;
      }
    } else {
      prices[data.symbol] = parseFloat(data.price);
    }
    return prices;
  }
  /**
   * Used by bookTickers to format the bids and asks given given symbols
   * @param {array} data - array of symbols
   * @return {object} - symbols with their bids and asks data
   */
  bookPriceData(data) {
    if (!Array.isArray(data)) {
      data = [data];
    }
    const prices = {};
    for (const obj of data) {
      prices[obj.symbol] = obj;
    }
    return prices;
  }
  /**
   * Used by balance to get the balance data
   * @param {array} data - account info object
   * @return {object} - balances hel with available, onorder amounts
   */
  balanceData(data) {
    const balances = {};
    if (typeof data === "undefined")
      return {};
    if (typeof data.balances === "undefined") {
      this.Options.log("balanceData error", data);
      return {};
    }
    for (const obj of data.balances) {
      balances[obj.asset] = { available: obj.free, onOrder: obj.locked };
    }
    return balances;
  }
  /**
   * Used by web sockets depth and populates OHLC and info
   * @param {string} symbol - symbol to get candlestick info
   * @param {string} interval - time interval, 1m, 3m, 5m ....
   * @param {array} ticks - tick array
   * @return {undefined}
   */
  klineData(symbol, interval2, ticks) {
    let last_time = 0;
    if (this.isIterable(ticks)) {
      for (const tick of ticks) {
        const [time, open, high, low, close, volume, closeTime, assetVolume, trades, buyBaseVolume, buyAssetVolume, ignored] = tick;
        this.ohlc[symbol][interval2][time] = { open, high, low, close, volume };
        last_time = time;
      }
      this.info[symbol][interval2].timestamp = last_time;
    }
  }
  /**
   * Combines all OHLC data with latest update
   * @param {string} symbol - the symbol
   * @param {string} interval - time interval, 1m, 3m, 5m ....
   * @return {array} - interval data for given symbol
   */
  klineConcat(symbol, interval2) {
    const output = this.ohlc[symbol][interval2];
    if (typeof this.ohlcLatest[symbol][interval2].time === "undefined")
      return output;
    const time = this.ohlcLatest[symbol][interval2].time;
    const last_updated = Object.keys(this.ohlc[symbol][interval2]).pop();
    if (time >= last_updated) {
      output[time] = this.ohlcLatest[symbol][interval2];
      delete output[time].time;
      output[time].isFinal = false;
    }
    return output;
  }
  /**
   * Used for websocket @kline
   * @param {string} symbol - the symbol
   * @param {object} kline - object with kline info
   * @param {string} firstTime - time filter
   * @return {undefined}
   */
  klineHandler(symbol, kline, firstTime = 0) {
    const { e: eventType, E: eventTime, k: ticks } = kline;
    const { o: open, h: high, l: low, c: close, v: volume, i: interval2, x: isFinal, q: quoteVolume, t: time } = ticks;
    if (time <= firstTime)
      return;
    if (!isFinal) {
      if (typeof this.ohlcLatest[symbol][interval2].time !== "undefined") {
        if (this.ohlcLatest[symbol][interval2].time > time)
          return;
      }
      this.ohlcLatest[symbol][interval2] = { open, high, low, close, volume, time };
      return;
    }
    const first_updated = Object.keys(this.ohlc[symbol][interval2]).shift();
    if (first_updated)
      delete this.ohlc[symbol][interval2][first_updated];
    this.ohlc[symbol][interval2][time] = { open, high, low, close, volume };
  }
  /**
   * Used by futures websockets chart cache
   * @param {string} symbol - symbol to get candlestick info
   * @param {string} interval - time interval, 1m, 3m, 5m ....
   * @param {array} ticks - tick array
   * @return {undefined}
   */
  futuresKlineData(symbol, interval2, ticks) {
    let last_time = 0;
    if (this.isIterable(ticks)) {
      for (const tick of ticks) {
        const [time, open, high, low, close, volume, closeTime, quoteVolume, trades, takerBuyBaseVolume, takerBuyQuoteVolume, ignored] = tick;
        this.futuresTicks[symbol][interval2][time] = { time, closeTime, open, high, low, close, volume, quoteVolume, takerBuyBaseVolume, takerBuyQuoteVolume, trades };
        last_time = time;
      }
      this.futuresMeta[symbol][interval2].timestamp = last_time;
    }
  }
  /**
   * Used by delivery websockets chart cache
   * @param {string} symbol - symbol to get candlestick info
   * @param {string} interval - time interval, 1m, 3m, 5m ....
   * @param {array} ticks - tick array
   * @return {undefined}
   */
  deliveryKlineData(symbol, interval2, ticks) {
    let last_time = 0;
    if (this.isIterable(ticks)) {
      for (const tick of ticks) {
        const [time, open, high, low, close, volume, closeTime, quoteVolume, trades, takerBuyBaseVolume, takerBuyQuoteVolume, ignored] = tick;
        this.deliveryTicks[symbol][interval2][time] = { time, closeTime, open, high, low, close, volume, quoteVolume, takerBuyBaseVolume, takerBuyQuoteVolume, trades };
        last_time = time;
      }
      this.deliveryMeta[symbol][interval2].timestamp = last_time;
    }
  }
  /**
   * Used for /depth endpoint
   * @param {object} data - containing the bids and asks
   * @return {undefined}
   */
  depthData(data) {
    if (!data)
      return { bids: [], asks: [] };
    const bids = {}, asks = {};
    let obj;
    if (typeof data.bids !== "undefined") {
      for (obj of data.bids) {
        bids[obj[0]] = parseFloat(obj[1]);
      }
    }
    if (typeof data.asks !== "undefined") {
      for (obj of data.asks) {
        asks[obj[0]] = parseFloat(obj[1]);
      }
    }
    return { lastUpdateId: data.lastUpdateId, bids, asks };
  }
  parseOrderBook(data, symbol) {
    const { lastUpdateId, bids, asks } = data;
    if (!bids || !asks) {
      return data;
    }
    const orderBook = {
      symbol,
      lastUpdateId,
      bids: bids.map((b) => (0, import_lodash.default)(["price", "quantity"], b)),
      asks: asks.map((a) => (0, import_lodash.default)(["price", "quantity"], a))
    };
    return orderBook;
  }
  /**
   * Used for /depth endpoint
   * @param {object} depth - information
   * @return {undefined}
   */
  depthHandler(depth) {
    const symbol = depth.s;
    let obj;
    const context = this.depthCacheContext[symbol];
    const updateDepthCache = () => {
      this.depthCache[symbol].eventTime = depth.E;
      for (obj of depth.b) {
        if (obj[1] == 0) {
          delete this.depthCache[symbol].bids[obj[0]];
        } else {
          this.depthCache[symbol].bids[obj[0]] = parseFloat(obj[1]);
        }
      }
      for (obj of depth.a) {
        if (obj[1] == 0) {
          delete this.depthCache[symbol].asks[obj[0]];
        } else {
          this.depthCache[symbol].asks[obj[0]] = parseFloat(obj[1]);
        }
      }
      context.skipCount = 0;
      context.lastEventUpdateId = depth.u;
      context.lastEventUpdateTime = depth.E;
    };
    if (context.lastEventUpdateId) {
      const expectedUpdateId = context.lastEventUpdateId + 1;
      if (depth.U <= expectedUpdateId) {
        updateDepthCache();
      } else {
        let msg = "depthHandler: [" + symbol + "] The depth cache is out of sync.";
        msg += ' Symptom: Unexpected Update ID. Expected "' + expectedUpdateId + '", got "' + depth.U + '"';
        if (this.Options.verbose)
          this.Options.log(msg);
        throw new Error(msg);
      }
    } else if (depth.U > context.snapshotUpdateId + 1) {
      let msg = "depthHandler: [" + symbol + "] The depth cache is out of sync.";
      msg += " Symptom: Gap between snapshot and first stream data.";
      if (this.Options.verbose)
        this.Options.log(msg);
      throw new Error(msg);
    } else if (depth.u < context.snapshotUpdateId + 1) {
    } else {
      updateDepthCache();
    }
  }
  /**
   * Gets depth cache for given symbol
   * @param {string} symbol - the symbol to fetch
   * @return {object} - the depth cache object
   */
  getDepthCache(symbol) {
    if (typeof this.depthCache[symbol] === "undefined")
      return { bids: {}, asks: {} };
    return this.depthCache[symbol];
  }
  /**
   * Calculate Buy/Sell volume from DepthCache
   * @param {string} symbol - the symbol to fetch
   * @return {object} - the depth volume cache object
   */
  depthVolume(symbol) {
    const cache = this.getDepthCache(symbol);
    let quantity, price;
    let bidbase = 0, askbase = 0, bidqty = 0, askqty = 0;
    for (price in cache.bids) {
      quantity = cache.bids[price];
      bidbase += parseFloat((quantity * parseFloat(price)).toFixed(8));
      bidqty += quantity;
    }
    for (price in cache.asks) {
      quantity = cache.asks[price];
      askbase += parseFloat((quantity * parseFloat(price)).toFixed(8));
      askqty += quantity;
    }
    return { bids: bidbase, asks: askbase, bidQty: bidqty, askQty: askqty };
  }
  /**
   * Checks whether or not an array contains any duplicate elements
   * @param {array} array - the array to check
   * @return {boolean} - true or false
   */
  isArrayUnique(array) {
    return new Set(array).size === array.length;
  }
  // --- PUBLIC FUNCTIONS --- //
  /**
      * Count decimal places
      * @param {float} float - get the price precision point
      * @return {int} - number of place
      */
  getPrecision(float) {
    if (!float || Number.isInteger(float))
      return 0;
    return float.toString().split(".")[1].length || 0;
  }
  /**
  * rounds number with given step
  * @param {float} qty - quantity to round
  * @param {float} stepSize - stepSize as specified by exchangeInfo
  * @return {float} - number
  */
  roundStep(qty, stepSize) {
    if (Number.isInteger(qty))
      return qty;
    const qtyString = parseFloat(qty).toFixed(16);
    const desiredDecimals = Math.max(stepSize.indexOf("1") - 1, 0);
    const decimalIndex = qtyString.indexOf(".");
    return parseFloat(qtyString.slice(0, decimalIndex + desiredDecimals + 1));
  }
  /**
  * rounds price to required precision
  * @param {float} price - price to round
  * @param {float} tickSize - tickSize as specified by exchangeInfo
  * @return {float} - number
  */
  roundTicks(price, tickSize) {
    const formatter = new Intl.NumberFormat("en-US", { style: "decimal", minimumFractionDigits: 0, maximumFractionDigits: 8 });
    const precision = formatter.format(tickSize).split(".")[1].length || 0;
    if (typeof price === "string")
      price = parseFloat(price);
    return price.toFixed(precision);
  }
  /**
  * Gets percentage of given numbers
  * @param {float} min - the smaller number
  * @param {float} max - the bigger number
  * @param {int} width - percentage width
  * @return {float} - percentage
  */
  percent(min, max, width = 100) {
    return min * 0.01 / (max * 0.01) * width;
  }
  /**
  * Gets the sum of an array of numbers
  * @param {array} array - the number to add
  * @return {float} - sum
  */
  sum(array) {
    return array.reduce((a, b) => a + b, 0);
  }
  /**
  * Reverses the keys of an object
  * @param {object} object - the object
  * @return {object} - the object
  */
  reverse(object) {
    const range = Object.keys(object).reverse(), output = {};
    for (const price of range) {
      output[price] = object[price];
    }
    return output;
  }
  /**
  * Converts an object to an array
  * @param {object} obj - the object
  * @return {array} - the array
  */
  array(obj) {
    return Object.keys(obj).map(function(key) {
      return [Number(key), obj[key]];
    });
  }
  /**
  * Sorts bids
  * @param {string} symbol - the object
  * @param {int} max - the max number of bids
  * @param {string} baseValue - the object
  * @return {object} - the object
  */
  sortBids(symbol, max = Infinity, baseValue) {
    const object = {};
    let count = 0, cache;
    if (typeof symbol === "object")
      cache = symbol;
    else
      cache = this.getDepthCache(symbol).bids;
    const sorted = Object.keys(cache).sort((a, b) => parseFloat(b) - parseFloat(a));
    let cumulative = 0;
    for (const price of sorted) {
      if (!baseValue)
        object[price] = cache[price];
      else if (baseValue === "cumulative") {
        cumulative += cache[price];
        object[price] = cumulative;
      } else
        object[price] = parseFloat((cache[price] * parseFloat(price)).toFixed(8));
      if (++count >= max)
        break;
    }
    return object;
  }
  /**
  * Sorts asks
  * @param {string} symbol - the object
  * @param {int} max - the max number of bids
  * @param {string} baseValue - the object
  * @return {object} - the object
  */
  sortAsks(symbol, max = Infinity, baseValue) {
    let count = 0, cache;
    const object = {};
    if (typeof symbol === "object")
      cache = symbol;
    else
      cache = this.getDepthCache(symbol).asks;
    const sorted = Object.keys(cache).sort((a, b) => parseFloat(a) - parseFloat(b));
    let cumulative = 0;
    for (const price of sorted) {
      if (!baseValue)
        object[price] = cache[price];
      else if (baseValue === "cumulative") {
        cumulative += cache[price];
        object[price] = cumulative;
      } else
        object[price] = parseFloat((cache[price] * parseFloat(price)).toFixed(8));
      if (++count >= max)
        break;
    }
    return object;
  }
  /**
  * Returns the first property of an object
  * @param {object} object - the object to get the first member
  * @return {string} - the object key
  */
  first(object) {
    return Object.keys(object).shift();
  }
  /**
  * Returns the last property of an object
  * @param {object} object - the object to get the first member
  * @return {string} - the object key
  */
  last(object) {
    return Object.keys(object).pop();
  }
  /**
  * Returns an array of properties starting at start
  * @param {object} object - the object to get the properties form
  * @param {int} start - the starting index
  * @return {array} - the array of entires
  */
  slice(object, start = 0) {
    return Object.keys(object).slice(start);
  }
  /**
  * Gets the minimum key form object
  * @param {object} object - the object to get the properties form
  * @return {string} - the minimum key
  */
  min(object) {
    return Math.min.apply(Math, Object.keys(object));
  }
  /**
  * Gets the maximum key form object
  * @param {object} object - the object to get the properties form
  * @return {string} - the minimum key
  */
  max(object) {
    return Math.max.apply(Math, Object.keys(object));
  }
  /**
  * Sets an option given a key and value
  * @param {string} key - the key to set
  * @param {object} value - the value of the key
  * @return {undefined}
  */
  setOption(key, value) {
    this.Options[key] = value;
  }
  /**
  * Gets an option given a key
  * @param {string} key - the key to set
  * @return {undefined}
  */
  getOption(key) {
    return this.Options[key];
  }
  /**
  * Returns the entire info object
  * @return {object} - the info object
  */
  getInfo() {
    return this.info;
  }
  /**
  * Returns the used weight from the last request
  * @return {object} - 1m weight used
  */
  usedWeight() {
    return this.info.usedWeight;
  }
  /**
  * Returns the status code from the last http response
  * @return {object} - status code
  */
  statusCode() {
    return this.info.statusCode;
  }
  /**
  * Returns the ping time from the last futures request
  * @return {object} - latency/ping (2ms)
  */
  futuresLatency() {
    return this.info.futuresLatency;
  }
  /**
  * Returns the complete URL from the last request
  * @return {object} - http address including query string
  */
  lastURL() {
    return this.info.lastURL;
  }
  /**
  * Returns the order count from the last request
  * @return {object} - orders allowed per 1m
  */
  orderCount() {
    return this.info.orderCount1m;
  }
  /**
  * Returns the entire options object
  * @return {object} - the options object
  */
  getOptions() {
    return this.Options;
  }
  // /**
  // * Gets an option given a key
  // * @param {object} opt - the object with the class configuration
  //
  // * @return {undefined}
  // */
  // options() {this.setOptions()}
  // /**
  // * Creates a buy order
  // * @param {string} symbol - the symbol to buy
  // * @param {numeric} quantity - the quantity required
  // * @param {numeric} price - the price to pay for each unit
  // * @param {object} flags - additional buy order flags
  //
  // * @return {promise or undefined} - omitting the callback returns a promise
  // */
  // buy(symbol, quantity, price, flags: Dict = {}, callback = false) {
  //     if (!callback) {
  //         return new Promise((resolve, reject) => {
  //             callback = (error, response) => {
  //                 if (error) {
  //                     reject(error);
  //                 } else {
  //                     resolve(response);
  //                 }
  //             }
  //             order('BUY', symbol, quantity, price, flags, callback);
  //         })
  //     } else {
  //         order('BUY', symbol, quantity, price, flags, callback);
  //     }
  // }
  // /**
  // * Creates a sell order
  // * @param {string} symbol - the symbol to sell
  // * @param {numeric} quantity - the quantity required
  // * @param {numeric} price - the price to sell each unit for
  // * @param {object} flags - additional order flags
  //
  // * @return {promise or undefined} - omitting the callback returns a promise
  // */
  // sell(symbol, quantity, price, flags: Dict = {}, callback = false) {
  //     if (!callback) {
  //         return new Promise((resolve, reject) => {
  //             callback = (error, response) => {
  //                 if (error) {
  //                     reject(error);
  //                 } else {
  //                     resolve(response);
  //                 }
  //             }
  //             order('SELL', symbol, quantity, price, flags, callback);
  //         })
  //     } else {
  //         order('SELL', symbol, quantity, price, flags, callback);
  //     }
  // }
  // /**
  // * Creates a market sell order
  // * @param {string} symbol - the symbol to sell
  // * @param {numeric} quantity - the quantity required
  // * @param {object} flags - additional sell order flags
  //
  // * @return {promise or undefined} - omitting the callback returns a promise
  // */
  // marketSell(symbol, quantity, flags = { type: 'MARKET' }, callback = false) {
  //     if (typeof flags === 'function') { // Accept callback as third parameter
  //         callback = flags;
  //         flags = { type: 'MARKET' };
  //     }
  //     if (typeof flags.type === 'undefined') flags.type = 'MARKET';
  //     if (!callback) {
  //         return new Promise((resolve, reject) => {
  //             callback = (error, response) => {
  //                 if (error) {
  //                     reject(error);
  //                 } else {
  //                     resolve(response);
  //                 }
  //             }
  //             order('SELL', symbol, quantity, 0, flags, callback);
  //         })
  //     } else {
  //         order('SELL', symbol, quantity, 0, flags, callback);
  //     }
  // }
  /**
  * Gets the depth information for a given symbol
  * @see https://developers.binance.com/docs/binance-spot-api-docs/rest-api/market-data-endpoints#order-book
  * @param {string} symbol - the symbol
  * @param {int} limit - limit the number of returned orders
  * @return {promise or undefined} - omitting the callback returns a promise
  */
  async depth(symbol, limit = 100) {
    const data = await this.publicSpotRequest("v3/depth", { symbol, limit });
    return this.parseOrderBook(data, symbol);
  }
  /**
  * Gets the average prices of a given symbol
  * @see https://developers.binance.com/docs/binance-spot-api-docs/rest-api/market-data-endpoints#current-average-price
  * @param {string} symbol - the symbol
  * @return {promise or undefined} - omitting the callback returns a promise
  */
  async avgPrice(symbol, params = {}) {
    params.symbol = symbol;
    return await this.publicSpotRequest("v3/avgPrice", params);
  }
  /**
  * Gets the prices of a given symbol(s)
  * @param {string} symbol - the symbol
  * @see https://developers.binance.com/docs/binance-spot-api-docs/rest-api/market-data-endpoints#symbol-price-ticker
  * @return {promise or undefined} - omitting the callback returns a promise
  */
  async prices(symbol, params = {}) {
    if (symbol)
      params.symbol = symbol;
    const data = await this.publicSpotRequest("v3/ticker/price", params);
    return this.priceData(data);
  }
  /**
  * Gets the book tickers of given symbol(s)
  * @see https://developers.binance.com/docs/binance-spot-api-docs/testnet/rest-api/market-data-endpoints#symbol-order-book-ticker
  * @param {string} symbol - the symbol
  * @return {promise or undefined} - omitting the callback returns a promise
  */
  async bookTickers(symbol, params = {}) {
    if (symbol)
      params.symbol = symbol;
    const data = await this.publicSpotRequest("v3/ticker/bookTicker", params);
    return this.bookPriceData(data);
  }
  /**
  * Gets the prevday percentage change
  * @see https://developers.binance.com/docs/binance-spot-api-docs/rest-api/market-data-endpoints#24hr-ticker-price-change-statistics
  * @param {string} symbol - the symbol or symbols
  * @return {promise or undefined} - omitting the callback returns a promise
  */
  async prevDay(symbol, params = {}) {
    if (symbol)
      params.symbol = symbol;
    return await this.publicSpotRequest("v3/ticker/24hr", params);
  }
  /**
  * Gets the prevday percentage change
  * @see https://developers.binance.com/docs/binance-spot-api-docs/rest-api/market-data-endpoints#24hr-ticker-price-change-statistics
  * @param {string} symbol - the symbol or symbols
  * @return {promise or undefined} - omitting the callback returns a promise
  */
  async ticker24h(symbol, params = {}) {
    if (symbol)
      params.symbol = symbol;
    return await this.publicSpotRequest("v3/ticker/24hr", params);
  }
  /**
  * Gets the prevday percentage change
  * @see https://developers.binance.com/docs/binance-spot-api-docs/rest-api/market-data-endpoints#24hr-ticker-price-change-statistics
  * @param {string} symbol - the symbol or symbols
  * @return {promise or undefined} - omitting the callback returns a promise
  */
  async dailyStats(symbol, params = {}) {
    if (symbol)
      params.symbol = symbol;
    return await this.publicSpotRequest("v3/ticker/24hr", params);
  }
  /**
  * Gets the the exchange info
  * @see https://developers.binance.com/docs/binance-spot-api-docs/rest-api/general-endpoints#exchange-information
  * @return {promise or undefined} - omitting the callback returns a promise
  */
  async exchangeInfo() {
    return await this.publicSpotRequest("v3/exchangeInfo", {});
  }
  /**
  * Gets the dust log for user
  * @return {promise or undefined} - omitting the callback returns a promise
  */
  async dustLog() {
    return await this.privateSpotRequest("v1/asset/dribblet", {});
  }
  async dustTransfer(assets) {
    return await this.privateSpotRequest("v1/asset/dust", { asset: assets }, "POST");
  }
  async assetDividendRecord(params = {}) {
    return await this.privateSpotRequest("v1/asset/assetDividend", params);
  }
  /**
  * Gets the the system status
  * @see https://developers.binance.com/docs/wallet/others/system-status
  * @return {promise or undefined} - omitting the callback returns a promise
  */
  async systemStatus(params = {}) {
    return await this.publicRequest(this.sapi + "v1/system/status", params);
  }
  /**
  * Withdraws asset to given wallet id
  * @see https://developers.binance.com/docs/wallet/capital/withdraw
  * @param {string} asset - the asset symbol
  * @param {string} address - the wallet to transfer it to
  * @param {number} amount - the amount to transfer
  * @param {string} addressTag - and addtional address tag
  * @param {string} name - the name to save the address as. Set falsy to prevent Binance saving to address book
  * @return {promise or undefined} - omitting the callback returns a promise
  */
  async withdraw(asset, address, amount, addressTag, name, params = {}) {
    params.asset = asset;
    params.address = address;
    params.amount = amount;
    if (name)
      params.name = name;
    if (addressTag)
      params.addressTag = addressTag;
    return await this.privateSpotRequest("v1/capital/withdraw/apply", params, "POST");
  }
  /**
  * Get the Withdraws history for a given asset
  * @see https://developers.binance.com/docs/wallet/capital/withdraw-history
  * @param {object} params - supports limit and fromId parameters
  * @return {promise or undefined} - omitting the callback returns a promise
  */
  async withdrawHistory(params = {}) {
    if (typeof params === "string")
      params = { asset: params };
    return await this.privateSpotRequest("v1/capital/withdraw/history", params);
  }
  /**
  * Get the deposit history
  * @see https://developers.binance.com/docs/wallet/capital/deposite-history#http-request
  * @param {object} params - additional params
  * @return {promise or undefined} - omitting the callback returns a promise
  */
  async depositHistory(asset, params = {}) {
    if (asset)
      params = { asset };
    return await this.privateSpotRequest("v1/capital/deposit/hisrec", params);
  }
  /**
  * Get the deposit address for given asset
  * @see https://developers.binance.com/docs/wallet/capital/deposite-address
  * @param {string} coin - the asset
  * @return {promise or undefined} - omitting the callback returns a promise
  */
  async depositAddress(asset, params = {}) {
    return await this.privateSpotRequest("v1/capital/deposit/address", this.extend({ coin: asset }, params));
  }
  /**
  * Get the deposit address list for given asset
  * @see https://developers.binance.com/docs/wallet/capital/fetch-deposit-address-list-with-network
  * @param {string} coin - the asset
  * @return {promise or undefined} - omitting the callback returns a promise
  */
  async depositAddressList(asset, params = {}) {
    return await this.privateSpotRequest("v1/capital/deposit/address/list", this.extend({ coin: asset }, params));
  }
  /**
  * Get the account status
  * @see https://developers.binance.com/docs/binance-spot-api-docs/rest-api/account-endpoints#account-information-user_data
  * @return {promise or undefined} - omitting the callback returns a promise
  */
  async accountStatus(params = {}) {
    return await this.privateSpotRequest("v3/account", params);
  }
  /**
  * @return {promise or undefined} - omitting the callback returns a promise
  */
  async apiPermission(params = {}) {
    return await this.privateSpotRequest("v1/account/apiRestrictions", params);
  }
  /**
  * Get the trade fee
  * @see https://developers.binance.com/docs/wallet/asset/trade-fee
  * @param {string} symbol (optional)
  * @return {promise or undefined} - omitting the callback returns a promise
  */
  async tradeFee(symbol) {
    const params = symbol ? { symbol } : {};
    return await this.privateSpotRequest("v1/asset/tradeFee", params);
  }
  /**
  * Fetch asset detail (minWithdrawAmount, depositStatus, withdrawFee, withdrawStatus, depositTip)
  * @see https://developers.binance.com/docs/wallet/asset
  * @return {promise or undefined} - omitting the callback returns a promise
  */
  async assetDetail(params = {}) {
    return await this.privateSpotRequest("asset/assetDetail", params);
  }
  /**
  * Get the account
  * @see https://developers.binance.com/docs/binance-spot-api-docs/testnet/rest-api/account-endpoints#account-information-user_data
  * @return {promise or undefined} - omitting the callback returns a promise
  */
  async account(params = {}) {
    return await this.privateSpotRequest("v3/account", params);
  }
  /**
  * Get the balance data
  * @see https://developers.binance.com/docs/binance-spot-api-docs/testnet/rest-api/account-endpoints#account-information-user_data
  * @return {promise or undefined} - omitting the callback returns a promise
  */
  async balance(params = {}) {
    const data = await this.privateSpotRequest("v3/account", params);
    return this.balanceData(data);
  }
  /**
  * Get private trades for a given symbol
  * @see https://developers.binance.com/docs/binance-spot-api-docs/testnet/rest-api/account-endpoints#account-trade-list-user_data
  * @param {string} symbol - the symbol
  * @param {object} options - additional options
  * @return {promise or undefined} - omitting the callback returns a promise
  */
  async trades(symbol, params = {}) {
    const parameters = this.extend({ symbol }, params);
    return await this.privateSpotRequest("v3/myTrades", parameters);
  }
  /**
  * Get private trades for a given symbol
  * @see https://developers.binance.com/docs/binance-spot-api-docs/testnet/rest-api/account-endpoints#account-trade-list-user_data
  * @param {string} symbol - the symbol
  * @param {object} options - additional options
  * @return {promise or undefined} - omitting the callback returns a promise
  */
  async myTrades(symbol, params = {}) {
    const parameters = this.extend({ symbol }, params);
    return await this.privateSpotRequest("v3/myTrades", parameters);
  }
  /**
  * Tell api to use the server time to offset time indexes
  * @see https://developers.binance.com/docs/binance-spot-api-docs/rest-api/general-endpoints#check-server-time
  * @return {promise or undefined} - omitting the callback returns a promise
  */
  async useServerTime() {
    const response = await this.publicSpotRequest("v3/time", {});
    this.timeOffset = response.serverTime - (/* @__PURE__ */ new Date()).getTime();
    return response;
  }
  // /**
  // * Get Binance server time
  // * @return {promise or undefined} - omitting the callback returns a promise
  // */
  // time() {
  //     publicRequest(this.getSpotUrl() + 'v3/time', {}, callback);
  // }
  /**
  * Ping binance
  * @see https://developers.binance.com/docs/binance-spot-api-docs/rest-api/general-endpoints#test-connectivity
  * @return {promise or undefined} - omitting the callback returns a promise
  */
  async ping() {
    return await this.publicSpotRequest("v3/ping", {});
  }
  /**
  * Get agg trades for given symbol
  * @see https://developers.binance.com/docs/binance-spot-api-docs/rest-api/market-data-endpoints#compressedaggregate-trades-list
  * @param {string} symbol - the symbol
  * @param {object} options - additional optoins
  * @return {promise or undefined} - omitting the callback returns a promise
  */
  async aggTrades(symbol, params = {}) {
    const parameters = Object.assign({ symbol }, params);
    return await this.publicSpotRequest("v3/aggTrades", parameters);
  }
  /**
  * Get the recent trades
  * @see https://developers.binance.com/docs/binance-spot-api-docs/rest-api/market-data-endpoints#old-trade-lookup
  * @param {string} symbol - the symbol
  * @param {int} limit - limit the number of items returned
  * @return {promise or undefined} - omitting the callback returns a promise
  */
  async recentTrades(symbol, limit = 500, params = {}) {
    return await this.publicSpotRequest("v3/trades", this.extend({ symbol, limit }, params));
  }
  /**
  * Get the historical trade info
  * @see https://developers.binance.com/docs/binance-spot-api-docs/rest-api/market-data-endpoints#old-trade-lookup
  * @param {string} symbol - the symbol
  * @param {int} limit - limit the number of items returned
  * @param {int} fromId - from this id
  * @return {promise or undefined} - omitting the callback returns a promise
  */
  async historicalTrades(symbol, limit = 500, fromId, params = {}) {
    params.symbol = symbol;
    params.limit = limit;
    if (fromId)
      params.fromId = fromId;
    return await this.publicSpotRequest("v3/historicalTrades", params);
  }
  /**
  * Convert chart data to highstock array [timestamp,open,high,low,close]
  * @param {object} chart - the chart
  * @param {boolean} include_volume - to include the volume or not
  * @return {array} - an array
  */
  highstock(chart, include_volume = false) {
    const array = [];
    for (const timestamp in chart) {
      const obj = chart[timestamp];
      const line = [
        Number(timestamp),
        parseFloat(obj.open),
        parseFloat(obj.high),
        parseFloat(obj.low),
        parseFloat(obj.close)
      ];
      if (include_volume)
        line.push(parseFloat(obj.volume));
      array.push(line);
    }
    return array;
  }
  /**
  * Populates OHLC information
  * @param {object} chart - the chart
  * @return {object} - object with candle information
  */
  populateOHLC(chart) {
    const open = [], high = [], low = [], close = [], volume = [];
    for (const timestamp in chart) {
      const obj = chart[timestamp];
      open.push(parseFloat(obj.open));
      high.push(parseFloat(obj.high));
      low.push(parseFloat(obj.low));
      close.push(parseFloat(obj.close));
      volume.push(parseFloat(obj.volume));
    }
    return { open, high, low, close, volume };
  }
  /**
  * Gets the candles information for a given symbol
  * @see https://developers.binance.com/docs/binance-spot-api-docs/rest-api/market-data-endpoints#klinecandlestick-data
  * intervals: 1m,3m,5m,15m,30m,1h,2h,4h,6h,8h,12h,1d,3d,1w,1M
  * @param {string} symbol - the symbol
  * @param {function} interval - the callback function
  * @param {object} options - additional options
  * @return {promise or undefined} - omitting the callback returns a promise
  */
  async candlesticks(symbol, interval2 = "5m", params = {}) {
    if (!params.limit)
      params.limit = 500;
    params = Object.assign({ symbol, interval: interval2 }, params);
    return await this.publicSpotRequest("v3/klines", params);
  }
  /**
  * Gets the candles information for a given symbol
  * @see https://developers.binance.com/docs/binance-spot-api-docs/rest-api/market-data-endpoints#klinecandlestick-data
  * intervals: 1m,3m,5m,15m,30m,1h,2h,4h,6h,8h,12h,1d,3d,1w,1M
  * @param {string} symbol - the symbol
  * @param {function} interval - the callback function
  * @param {object} options - additional options
  * @return {promise or undefined} - omitting the callback returns a promise
  */
  async candles(symbol, interval2 = "5m", params = {}) {
    return await this.candlesticks(symbol, interval2, params);
  }
  // /**
  // * Queries the public api
  // * @param {string} url - the public api endpoint
  // * @param {object} data - the data to send
  // * @param {string} method - the http method
  // * @return {promise or undefined} - omitting the callback returns a promise
  // */
  // publicRequest(url: string, data, method: HttpMethod = 'Get') {
  //     if (!callback) {
  //         return new Promise((resolve, reject) => {
  //             callback = (error, response) => {
  //                 if (error) {
  //                     reject(error);
  //                 } else {
  //                     resolve(response);
  //                 }
  //             }
  //             this.publicRequest(url, data, callback, method);
  //         })
  //     } else {
  //         publicRequest(url, data, callback, method);
  //     }
  // }
  // /**
  //  * Queries the futures API by default
  //  * @param {string} url - the signed api endpoint
  //  * @param {object} data - the data to send
  //  * @param {object} flags - type of request, authentication method and endpoint url
  //  */
  // promiseRequest(url, data = {}, flags = {}) {
  //     return await this.promiseRequest(url, data, flags);
  // }
  // /**
  // * Queries the signed api
  // * @param {string} url - the signed api endpoint
  // * @param {object} data - the data to send
  //
  // * @param {string} method - the http method
  // * @param {boolean} noDataInSignature - Prevents data from being added to signature
  // * @return {promise or undefined} - omitting the callback returns a promise
  // */
  // signedRequest(url, data, callback, method: HttpMethod = 'GET', noDataInSignature = false) {
  //     if (!callback) {
  //         return new Promise((resolve, reject) => {
  //             callback = (error, response) => {
  //                 if (error) {
  //                     reject(error);
  //                 } else {
  //                     resolve(response);
  //                 }
  //             }
  //             signedRequest(url, data, callback, method, noDataInSignature);
  //         })
  //     } else {
  //         signedRequest(url, data, callback, method, noDataInSignature);
  //     }
  // }
  /**
  * Gets the market asset of given symbol
  * @param {string} symbol - the public api endpoint
  * @return {undefined}
  */
  getMarket(symbol) {
    if (symbol.endsWith("BTC"))
      return "BTC";
    else if (symbol.endsWith("ETH"))
      return "ETH";
    else if (symbol.endsWith("BNB"))
      return "BNB";
    else if (symbol.endsWith("XRP"))
      return "XRP";
    else if (symbol.endsWith("PAX"))
      return "PAX";
    else if (symbol.endsWith("USDT"))
      return "USDT";
    else if (symbol.endsWith("USDC"))
      return "USDC";
    else if (symbol.endsWith("USDS"))
      return "USDS";
    else if (symbol.endsWith("TUSD"))
      return "TUSD";
  }
  /**
  * Get the account binance lending information
  * @return {promise or undefined} - omitting the callback returns a promise
  */
  async lending(params = {}) {
    return await this.privateSpotRequest("v1/lending/union/account", params);
  }
  //** Futures methods */
  async futuresPing(params = {}) {
    return await this.publicFuturesRequest("v1/ping", params);
  }
  async futuresTime(params = {}) {
    return await this.publicFuturesRequest("v1/time", params).then((r2) => r2.serverTime);
  }
  /**
   * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Exchange-Information
   * @returns
   */
  async futuresExchangeInfo(params = {}) {
    return await this.publicFuturesRequest("v1/exchangeInfo", params);
  }
  /**
   * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Symbol-Price-Ticker-v2
   *
   */
  async futuresPrices(symbol, params = {}) {
    if (symbol)
      params.symbol = symbol;
    const data = await this.publicFuturesRequest("v2/ticker/price", params);
    return this.priceData(data);
  }
  /**
  * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/24hr-Ticker-Price-Change-Statistics
  */
  async futuresDaily(symbol, params = {}) {
    if (symbol)
      params.symbol = symbol;
    return await this.publicFuturesRequest("v1/ticker/24hr", params);
  }
  /**
   * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Open-Interest
   */
  async futuresOpenInterest(symbol, params = {}) {
    params.symbol = symbol;
    return await this.publicFuturesRequest("v1/openInterest", params);
  }
  /**
   * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Kline-Candlestick-Data
  */
  async futuresCandles(symbol, interval2 = "30m", params = {}) {
    params.symbol = symbol;
    params.interval = interval2;
    return await this.publicFuturesRequest("v1/klines", params);
  }
  /**
   * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Kline-Candlestick-Data
  */
  async futuresCandlesticks(symbol, interval2 = "30m", params = {}) {
    params.symbol = symbol;
    params.interval = interval2;
    return await this.publicFuturesRequest("v1/klines", params);
  }
  /**
   * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Mark-Price
   */
  async futuresMarkPrice(symbol, params = {}) {
    if (symbol)
      params.symbol = symbol;
    return await this.publicFuturesRequest("v1/premiumIndex", params);
  }
  /**
   * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Recent-Trades-List
   * @param symbol symbol if the market
   * @param params extra parameters to be sent in the request
   * @returns
   */
  async futuresTrades(symbol, params = {}) {
    params.symbol = symbol;
    return await this.publicFuturesRequest("v1/trades", params);
  }
  /**
   * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Old-Trades-Lookup
   * @param symbol symbol if the market
   * @param param
   * @returns
   */
  async futuresHistoricalTrades(symbol, params = {}) {
    params.symbol = symbol;
    return await this.publicFuturesRequest("v1/historicalTrades", params);
  }
  /**
   * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Compressed-Aggregate-Trades-List
  */
  async futuresAggTrades(symbol, params = {}) {
    params.symbol = symbol;
    return await this.publicFuturesRequest("v1/aggTrades", params);
  }
  /**
   * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Users-Force-Orders
   * @param params extra parameters to be sent in the request
   * @returns
   */
  async futuresForceOrders(params = {}) {
    return await this.privateFuturesRequest("v1/forceOrders", params);
  }
  /**
   * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Position-ADL-Quantile-Estimation
   * @param params extra parameters to be sent in the request
   * @returns
   */
  async futuresDeleverageQuantile(params = {}) {
    return await this.privateFuturesRequest("v1/adlQuantile", params);
  }
  /**
   * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Account-Trade-List
   * @param params extra parameters to be sent in the request
   * @returns
   */
  async futuresUserTrades(symbol, params = {}) {
    params.symbol = symbol;
    return await this.privateFuturesRequest("v1/userTrades", params);
  }
  async futuresGetDataStream(params = {}) {
    return await this.privateFuturesRequest("v1/listenKey", params, "POST");
  }
  async futuresKeepDataStream(params = {}) {
    return await this.privateFuturesRequest("v1/listenKey", params, "PUT");
  }
  async futuresCloseDataStream(params = {}) {
    return await this.privateFuturesRequest("v1/listenKey", params, "DELETE");
  }
  /**
  * Get the account position risk (v3)
  * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Position-Information-V3
  * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Position-Information-V2
  * @return {promise or undefined} - omitting the callback returns a promise
  */
  async futuresPositionRisk(params = {}, useV2 = false) {
    const endpoint = useV2 ? "v2/positionRisk" : "v3/positionRisk";
    return await this.privateFuturesRequest(endpoint, params);
  }
  /**
  * Get the account position risk (v2)
  * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Position-Information-V3
  * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Position-Information-V2
  * @return {promise or undefined} - omitting the callback returns a promise
  */
  async futuresPositionRiskV2(params = {}) {
    return this.futuresPositionRisk(params, true);
  }
  /**
   * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Get-Funding-Rate-Info
   * @param symbol symbol if the market
   * @param params extra parameters to be sent in the request
   * @returns
   */
  async futuresFundingRate(symbol, params = {}) {
    params.symbol = symbol;
    return await this.publicFuturesRequest("v1/fundingRate", params);
  }
  /**
   * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/account/rest-api/Notional-and-Leverage-Brackets#http-request
   * @param symbol symbol if the market
   * @param params extra parameters to be sent in the request
   * @returns
   */
  async futuresLeverageBracket(symbol, params = {}) {
    if (symbol)
      params.symbol = symbol;
    return await this.privateFuturesRequest("v1/leverageBracket", params);
  }
  /**
   * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/account/rest-api/Futures-Trading-Quantitative-Rules-Indicators#http-request
   * @param symbol symbol if the market
   * @param params extra parameters to be sent in the request
   * @returns
   */
  async futuresTradingStatus(symbol, params = {}) {
    if (symbol)
      params.symbol = symbol;
    return await this.privateFuturesRequest("v1/apiTradingStatus", params);
  }
  /**
   * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/account/rest-api/User-Commission-Rate#http-request
   * @param symbol symbol if the market
   * @param params extra parameters to be sent in the request
   * @returns
   */
  async futuresCommissionRate(symbol, params = {}) {
    if (symbol)
      params.symbol = symbol;
    return await this.privateFuturesRequest("v1/commissionRate", params);
  }
  // leverage 1 to 125
  /**
   * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Change-Initial-Leverage
   */
  async futuresLeverage(symbol, leverage, params = {}) {
    params.symbol = symbol;
    params.leverage = leverage;
    return await this.privateFuturesRequest("v1/leverage", params);
  }
  // ISOLATED, CROSSED
  /**
   * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Change-Margin-Type
   * @param symbol symbol if the market
   * @param marginType
   * @param params extra parameters to be sent in the request
   * @returns
   */
  async futuresMarginType(symbol, marginType, params = {}) {
    params.symbol = symbol;
    params.marginType = marginType;
    return await this.privateFuturesRequest("v1/marginType", params);
  }
  // type: 1: Add postion margin，2: Reduce postion margin
  async futuresPositionMargin(symbol, amount, type = 1, params = {}) {
    params.symbol = symbol;
    params.amount = amount;
    params.type = type;
    return await this.privateFuturesRequest("v1/positionMargin", params);
  }
  async futuresPositionMarginHistory(symbol, params = {}) {
    params.symbol = symbol;
    return await this.privateFuturesRequest("v1/positionMargin/history", params);
  }
  /**
   * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/account/rest-api/Get-Income-History
   */
  async futuresIncome(params = {}) {
    return await this.privateFuturesRequest("v1/income", params);
  }
  /**
   * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/account/rest-api/Futures-Account-Balance-V2
  */
  async futuresBalance(params = {}) {
    return await this.privateFuturesRequest("v2/balance", params);
  }
  /**
   * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/account/rest-api/Account-Information-V3
   * @param params extra parameters to be sent in the request
   * @returns
   */
  async futuresAccount(params = {}) {
    return await this.privateFuturesRequest("v3/account", params);
  }
  /**
   * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Order-Book
   * @param symbol symbol if the market
   * @param params extra parameters to be sent in the request
   * @returns
   */
  async futuresDepth(symbol, params = {}) {
    params.symbol = symbol;
    const res = await this.publicFuturesRequest("v1/depth", params);
    return this.parseOrderBook(res, symbol);
  }
  /**
   * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Symbol-Order-Book-Ticker
   */
  async futuresQuote(symbol, params = {}) {
    if (symbol)
      params.symbol = symbol;
    const data = await this.publicFuturesRequest("v1/ticker/bookTicker", params);
    return this.bookPriceData(data);
  }
  /**
   * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Symbol-Order-Book-Ticker
   */
  async futuresBookTicker(symbol, params = {}) {
    return await this.futuresQuote(symbol, params);
  }
  /**
   * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/New-Order
   * @param symbol symbol if the market
   * @param quantity
   * @param price
   * @param params extra parameters to be sent in the request
   * @returns
   */
  async futuresBuy(symbol, quantity, price, params = {}) {
    return await this.futuresOrder("LIMIT", "BUY", symbol, quantity, price, params);
  }
  /**
   * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/New-Order
   * @param symbol symbol if the market
   * @param quantity
   * @param price
   * @param params extra parameters to be sent in the request
   * @returns
   */
  async futuresSell(symbol, quantity, price, params = {}) {
    return await this.futuresOrder("LIMIT", "SELL", symbol, quantity, price, params);
  }
  /**
   * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/New-Order
   * @param symbol symbol if the market
   * @param quantity
   * @param price
   * @param params extra parameters to be sent in the request
   * @returns
   */
  async futuresMarketBuy(symbol, quantity, params = {}) {
    return await this.futuresOrder("MARKET", "BUY", symbol, quantity, void 0, params);
  }
  /**
   * @description futures limit order
   * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/New-Order
   * @param side
   * @param symbol
   * @param quantity
   * @param price
   * @param params extra parameters to be sent in the request
   * @returns
   */
  async futuresLimitOrder(side, symbol, quantity, price, params = {}) {
    return await this.futuresOrder("LIMIT", side, symbol, quantity, price, params);
  }
  /**
   * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/New-Order
   * @param symbol symbol if the market
   * @param quantity
   * @param price
   * @param params extra parameters to be sent in the request
   * @returns
   */
  async futuresMarketSell(symbol, quantity, params = {}) {
    return await this.futuresOrder("MARKET", "SELL", symbol, quantity, void 0, params);
  }
  /**
   * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Place-Multiple-Orders
   */
  async futuresMultipleOrders(orders = []) {
    for (let i2 = 0; i2 < orders.length; i2++) {
      if (!orders[i2].newClientOrderId) {
        orders[i2].newClientOrderId = this.CONTRACT_PREFIX + this.uuid22();
      }
    }
    const params = { batchOrders: JSON.stringify(orders) };
    return await this.privateFuturesRequest("v1/batchOrders", params, "POST");
  }
  /**
   * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Cancel-Multiple-Orders
   */
  async futuresCancelMultipleOrders(symbol, params = {}) {
    return await this.privateFuturesRequest("v1/batchOrders", this.extend({ "symbol": symbol }, params), "DELETE");
  }
  // futuresOrder, // side symbol quantity [price] [params]
  /**
   * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Query-Order
   * @param symbol symbol if the market
   * @param params extra parameters to be sent in the request
   * @returns
   */
  async futuresOrderStatus(symbol, params = {}) {
    params.symbol = symbol;
    return await this.privateFuturesRequest("v1/order", params);
  }
  /**
   * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Cancel-Order
   * @param symbol symbol if the market
   * @param orderId
   * @param params extra parameters to be sent in the request
   * @returns
   */
  async futuresCancel(symbol, orderId, params = {}) {
    params.symbol = symbol;
    if (orderId)
      params.orderId = orderId;
    return await this.privateFuturesRequest("v1/order", params, "DELETE");
  }
  /**
   * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Cancel-All-Open-Orders
   * @param symbol symbol if the market
   * @param params extra parameters to be sent in the request
   * @returns
   */
  async futuresCancelAll(symbol, params = {}) {
    params.symbol = symbol;
    return await this.privateFuturesRequest("v1/allOpenOrders", params, "DELETE");
  }
  /**
   *
   * @param symbol symbol if the market
   * @param countdownTime
   * @param params extra parameters to be sent in the request
   * @returns
   */
  async futuresCountdownCancelAll(symbol, countdownTime = 0, params = {}) {
    params.symbol = symbol;
    params.countdownTime = countdownTime;
    return await this.privateFuturesRequest("v1/countdownCancelAll", params, "POST");
  }
  /**
   * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Current-All-Open-Orders
   * @param symbol symbol if the market
   * @param params extra parameters to be sent in the request
   * @returns
   */
  async futuresOpenOrders(symbol, params = {}) {
    if (symbol)
      params.symbol = symbol;
    return await this.privateFuturesRequest("v1/openOrders", params);
  }
  /**
   * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/All-Orders
   * @param symbol symbol if the market
   * @param params extra parameters to be sent in the request
   * @returns
   */
  async futuresAllOrders(symbol, params = {}) {
    if (symbol)
      params.symbol = symbol;
    return await this.privateFuturesRequest("v1/allOrders", params);
  }
  /**
   *
   * @param params extra parameters to be sent in the request
   * @returns
   */
  async futuresPositionSideDual(params = {}) {
    return await this.privateFuturesRequest("v1/positionSide/dual", params);
  }
  /**
   *
   * @param dualSidePosition
   * @param params extra parameters to be sent in the request
   * @returns
   */
  async futuresChangePositionSideDual(dualSidePosition, params = {}) {
    params.dualSidePosition = dualSidePosition;
    return await this.privateFuturesRequest("v1/positionSide/dual", params, "POST");
  }
  /**
   *
   * @param symbol symbol if the market
   * @param params extra parameters to be sent in the request
   * @returns
   */
  async futuresTransferAsset(asset, amount, type, params = {}) {
    params = Object.assign({ asset, amount, type });
    return await this.privateSpotRequest("v1/futures/transfer", params, "POST");
  }
  /**
   * @see https://developers.binance.com/docs/derivatives/futures-data/market-data
   * @param symbol
   * @param params
   * @returns
   */
  async futuresHistDataLink(symbol, params = {}) {
    if (symbol)
      params.symbol = symbol;
    return await this.privateSpotRequest("v1/futuresHistDataId", params);
  }
  /**
   * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/account/rest-api/Get-Futures-Trade-Download-Link-by-Id
   * @param downloadId
   * @returns
   */
  async futuresTradeDownloadLink(downloadId) {
    return await this.privateFuturesRequest("v1/trade/asyn/id", { downloadId });
  }
  // futures websockets support: ticker bookTicker miniTicker aggTrade markPrice
  /* TODO: https://binance-docs.github.io/apidocs/futures/en/#change-log
      Cancel multiple orders DELETE /fapi/v1/batchOrders
      New Future Account Transfer POST https://api.binance.com/sapi/v1/futures/transfer
      Get Postion Margin Change History (TRADE)
  
      wss://fstream.binance.com/ws/<listenKey>
      Diff. Book Depth Streams (250ms, 100ms, or realtime): <symbol>@depth OR <symbol>@depth@100ms OR <symbol>@depth@0ms
      Partial Book Depth Streams (5, 10, 20): <symbol>@depth<levels> OR <symbol>@depth<levels>@100ms
      All Market Liquidation Order Streams: !forceOrder@arr
      Liquidation Order Streams for specific symbol: <symbol>@forceOrder
      Chart data (250ms): <symbol>@kline_<interval>
      SUBSCRIBE, UNSUBSCRIBE, LIST_SUBSCRIPTIONS, SET_PROPERTY, GET_PROPERTY
      Live Subscribing/Unsubscribing to streams: requires sending futures subscription id when connecting
      futuresSubscriptions { "method": "LIST_SUBSCRIPTIONS", "id": 1 }
      futuresUnsubscribe { "method": "UNSUBSCRIBE", "params": [ "btcusdt@depth" ], "id": 1 }
      futures depthCache
      */
  /*
  const futuresOrder = (side, symbol, quantity, price = 0, flags: Dict = {}, callback = false) => {
      let opt = {
          symbol: symbol,
          side: side,
          type: 'LIMIT',
          quantity: quantity
      };
      if (typeof flags.type !== 'undefined') opt.type = flags.type;
      if (opt.type.includes('LIMIT')) {
          opt.price = price;
          opt.timeInForce = 'GTC';
      }
      if (typeof flags.timeInForce !== 'undefined') opt.timeInForce = flags.timeInForce;
      signedRequest(`${fapi}v1/order`, opt, function (error, response) {
          if (!response) {
              if (callback) return callback(error, response);
              else return this.options.log('futuresOrder error:', error);
          }
          if (callback) return callback(error, response);
          else return this.options.log(`futuresOrder ${side} (${symbol},${quantity},${price})`, response);
      }, 'POST');
  };*/
  //** Delivery methods */
  async deliveryPing(params = {}) {
    return await this.publicDeliveryRequest("v1/ping", params);
  }
  async deliveryTime(params = {}) {
    return await this.publicDeliveryRequest("v1/time", params);
  }
  async deliveryExchangeInfo(params = {}) {
    return await this.publicDeliveryRequest("v1/exchangeInfo", params);
  }
  async deliveryPrices(params = {}) {
    const data = await this.publicDeliveryRequest("v1/ticker/price", params);
    return data.reduce((out, i2) => (out[i2.symbol] = i2.price, out), {});
  }
  async deliveryDaily(symbol, params = {}) {
    if (symbol)
      params.symbol = symbol;
    const data = await this.publicDeliveryRequest("v1/ticker/24hr", params);
    return symbol ? data : data.reduce((out, i2) => (out[i2.symbol] = i2, out), {});
  }
  async deliveryOpenInterest(symbol, params = {}) {
    params.symbol = symbol;
    const res = await this.publicDeliveryRequest("v1/openInterest", params);
    return res;
  }
  async deliveryCandles(symbol, interval2 = "30m", params = {}) {
    params.symbol = symbol;
    params.interval = interval2;
    return await this.publicDeliveryRequest("v1/klines", params);
  }
  async deliveryContinuousKlines(pair, contractType = "CURRENT_QUARTER", interval2 = "30m", params = {}) {
    params.pair = pair;
    params.interval = interval2;
    params.contractType = contractType;
    return await this.publicDeliveryRequest("v1/continuousKlines", params);
  }
  async deliveryIndexKlines(pair, interval2 = "30m", params = {}) {
    params.pair = pair;
    params.interval = interval2;
    return await this.publicDeliveryRequest("v1/indexPriceKlines", params);
  }
  async deliveryMarkPriceKlines(symbol, interval2 = "30m", params = {}) {
    params.symbol = symbol;
    params.interval = interval2;
    return await this.publicDeliveryRequest("v1/markPriceKlines", params);
  }
  async deliveryMarkPrice(symbol, params = {}) {
    if (symbol)
      params.symbol = symbol;
    return await this.publicDeliveryRequest("v1/premiumIndex", params);
  }
  async deliveryTrades(symbol, params = {}) {
    params.symbol = symbol;
    return await this.publicDeliveryRequest("v1/trades", params);
  }
  async deliveryHistoricalTrades(symbol, params = {}) {
    params.symbol = symbol;
    return await this.publicDeliveryRequest("v1/historicalTrades", params);
  }
  async deliveryAggTrades(symbol, params = {}) {
    params.symbol = symbol;
    return await this.publicDeliveryRequest("v1/aggTrades", params);
  }
  async deliveryUserTrades(symbol, params = {}) {
    params.symbol = symbol;
    return await this.privateDeliveryRequest("v1/userTrades", params);
  }
  async deliveryCommissionRate(symbol, params = {}) {
    if (symbol)
      params.symbol = symbol;
    return await this.privateDeliveryRequest("v1/commissionRate", params);
  }
  async deliveryGetDataStream(params = {}) {
    return await this.privateDeliveryRequest("v1/listenKey", params, "POST");
  }
  async deliveryKeepDataStream(params = {}) {
    return await this.privateDeliveryRequest("v1/listenKey", params, "PUT");
  }
  async deliveryCloseDataStream(params = {}) {
    return await this.privateDeliveryRequest("v1/listenKey", params, "DELETE");
  }
  async deliveryLiquidationOrders(symbol, params = {}) {
    if (symbol)
      params.symbol = symbol;
    return await this.publicDeliveryRequest("v1/allForceOrders", params);
  }
  async deliveryPositionRisk(params = {}) {
    return await this.privateDeliveryRequest("v1/positionRisk", params);
  }
  async deliveryLeverageBracket(symbol, params = {}) {
    if (symbol)
      params.symbol = symbol;
    return await this.privateDeliveryRequest("v1/leverageBracket", params);
  }
  async deliveryLeverageBracketSymbols(symbol, params = {}) {
    if (symbol)
      params.symbol = symbol;
    return await this.privateDeliveryRequest("v2/leverageBracket", params);
  }
  // leverage 1 to 125
  async deliveryLeverage(symbol, leverage, params = {}) {
    params.symbol = symbol;
    params.leverage = leverage;
    return await this.privateDeliveryRequest("v1/leverage", params, "POST");
  }
  // ISOLATED, CROSSED
  async deliveryMarginType(symbol, marginType, params = {}) {
    params.symbol = symbol;
    params.marginType = marginType;
    return await this.privateDeliveryRequest("v1/marginType", params, "POST");
  }
  // type: 1: Add postion margin，2: Reduce postion margin
  async deliveryPositionMargin(symbol, amount, type = 1, params = {}) {
    params.symbol = symbol;
    params.amount = amount;
    params.type = type;
    return await this.privateDeliveryRequest("v1/positionMargin", params, "POST");
  }
  async deliveryPositionMarginHistory(symbol, params = {}) {
    params.symbol = symbol;
    return await this.privateDeliveryRequest("v1/positionMargin/history", params);
  }
  async deliveryIncome(params = {}) {
    return await this.privateDeliveryRequest("v1/income", params);
  }
  async deliveryBalance(params = {}) {
    return await this.privateDeliveryRequest("v1/balance", params);
  }
  async deliveryAccount(params = {}) {
    return await this.privateDeliveryRequest("v1/account", params);
  }
  async deliveryDepth(symbol, params = {}) {
    params.symbol = symbol;
    const res = await this.publicDeliveryRequest("v1/depth", params);
    return this.parseOrderBook(res, symbol);
  }
  async deliveryQuote(symbol, params = {}) {
    if (symbol)
      params.symbol = symbol;
    const data = await this.publicDeliveryRequest("v1/ticker/bookTicker", params);
    return symbol ? data : data.reduce((out, i2) => (out[i2.symbol] = i2, out), {});
  }
  async deliveryBuy(symbol, quantity, price, params = {}) {
    return await this.deliveryOrder("LIMIT", "BUY", symbol, quantity, price, params);
  }
  async deliverySell(symbol, quantity, price, params = {}) {
    return await this.deliveryOrder("LIMIT", "SELL", symbol, quantity, price, params);
  }
  async deliveryMarketBuy(symbol, quantity, params = {}) {
    return await this.deliveryOrder("MARKET", "BUY", symbol, quantity, void 0, params);
  }
  async deliveryMarketSell(symbol, quantity, params = {}) {
    return await this.deliveryOrder("MARKET", "SELL", symbol, quantity, void 0, params);
  }
  // deliveryOrder, // side symbol quantity [price] [params]
  async deliveryOrderStatus(symbol, params = {}) {
    params.symbol = symbol;
    return await this.privateDeliveryRequest("v1/order", params);
  }
  async deliveryCancel(symbol, params = {}) {
    params.symbol = symbol;
    return await this.privateDeliveryRequest("v1/order", params, "DELETE");
  }
  async deliveryCancelAll(symbol, params = {}) {
    params.symbol = symbol;
    return await this.privateDeliveryRequest("v1/allOpenOrders", params, "DELETE");
  }
  async deliveryCountdownCancelAll(symbol, countdownTime = 0, params = {}) {
    params.symbol = symbol;
    params.countdownTime = countdownTime;
    return await this.privateDeliveryRequest("v1/countdownCancelAll", params, "POST");
  }
  async deliveryOpenOrders(symbol, params = {}) {
    if (symbol)
      params.symbol = symbol;
    return await this.privateDeliveryRequest("v1/openOrders", params);
  }
  async deliveryAllOrders(symbol, params = {}) {
    if (symbol)
      params.symbol = symbol;
    return await this.privateDeliveryRequest("v1/allOrders", params);
  }
  async deliveryPositionSideDual(params = {}) {
    return await this.privateDeliveryRequest("v1/positionSide/dual", params);
  }
  async deliveryChangePositionSideDual(dualSidePosition, params = {}) {
    params.dualSidePosition = dualSidePosition;
    return await this.privateDeliveryRequest("v1/positionSide/dual", params, "POST");
  }
  //** Margin methods */
  /**
   * Creates an order
   * @see https://developers.binance.com/docs/margin_trading/trade/Margin-Account-New-Order
   * @param {string} side - BUY or SELL
   * @param {string} symbol - the symbol to buy
   * @param {numeric} quantity - the quantity required
   * @param {numeric} price - the price to pay for each unit
   * @param {object} params - additional buy order flags
   * @param {string} isIsolated - the isolate margin option
   * @return {undefined}
   */
  async mgOrder(type, side, symbol, quantity, price, params = {}, isIsolated = "FALSE") {
    return await this.marginOrder(type, side, symbol, quantity, price, { ...params, isIsolated });
  }
  /**
   * Creates a buy order
   * @see https://developers.binance.com/docs/margin_trading/trade/Margin-Account-New-Order
   * @param {string} symbol - the symbol to buy
   * @param {numeric} quantity - the quantity required
   * @param {numeric} price - the price to pay for each unit
   * @param {object} params - additional buy order flags
   * @param {string} isIsolated - the isolate margin option
   * @return {undefined}
   */
  async mgBuy(symbol, quantity, price, params = {}, isIsolated = "FALSE") {
    return await this.marginOrder("LIMIT", "BUY", symbol, quantity, price, { ...params, isIsolated });
  }
  /**
   * Creates a sell order
   * @see https://developers.binance.com/docs/margin_trading/trade/Margin-Account-New-Order
   * @param {string} symbol - the symbol to sell
   * @param {numeric} quantity - the quantity required
   * @param {numeric} price - the price to sell each unit for
   * @param {object} flags - additional order flags
   * @param {string} isIsolated - the isolate margin option
   * @return {undefined}
   */
  async mgSell(symbol, quantity, price, flags = {}, isIsolated = "FALSE") {
    return await this.marginOrder("LIMIT", "SELL", symbol, quantity, price, { ...flags, isIsolated });
  }
  /**
   * Creates a market buy order
   * @see https://developers.binance.com/docs/margin_trading/trade/Margin-Account-New-Order
   * @param {string} symbol - the symbol to buy
   * @param {numeric} quantity - the quantity required
   * @param {object} flags - additional buy order flags
   * @param {string} isIsolated - the isolate margin option
   * @return {undefined}
   */
  async mgMarketBuy(symbol, quantity, params = {}, isIsolated = "FALSE") {
    return await this.marginOrder("MARKET", "BUY", symbol, quantity, 0, { ...params, isIsolated });
  }
  /**
   * Creates a market sell order
   * @see https://developers.binance.com/docs/margin_trading/trade/Margin-Account-New-Order
   * @param {string} symbol - the symbol to sell
   * @param {numeric} quantity - the quantity required
   * @param {object} flags - additional sell order flags
   * @param {string} isIsolated - the isolate margin option
   * @return {undefined}
   */
  async mgMarketSell(symbol, quantity, params = {}, isIsolated = "FALSE") {
    return await this.marginOrder("MARKET", "SELL", symbol, quantity, 0, { ...params, isIsolated });
  }
  /**
   * Cancels an order
   * @param {string} symbol - the symbol to cancel
   * @param {string} orderid - the orderid to cancel
   * @return {undefined}
   */
  async mgCancel(symbol, orderid, isIsolated = "FALSE") {
    return await this.privateSpotRequest("v1/margin/order", { symbol, orderId: orderid, isIsolated }, "DELETE");
  }
  /**
  * Gets all order of a given symbol
  * @param {string} symbol - the symbol
  * @param {object} options - additional options
  * @return {promise or undefined} - omitting the callback returns a promise
  */
  async mgAllOrders(symbol, params = {}) {
    const parameters = Object.assign({ symbol }, params);
    return await this.privateSpotRequest("v1/margin/allOrders", parameters);
  }
  /**
   * Gets the status of an order
   * @param {string} symbol - the symbol to check
   * @param {string} orderid - the orderid to check
   * @param {object} flags - any additional flags
   * @return {undefined}
   */
  async mgOrderStatus(symbol, orderid, flags = {}) {
    const parameters = Object.assign({ symbol, orderId: orderid }, flags);
    return await this.privateSpotRequest("v1/margin/order", parameters);
  }
  /**
   * Gets open orders
   * @param {string} symbol - the symbol to get
   * @return {undefined}
   */
  async mgOpenOrders(symbol, params = {}) {
    if (symbol)
      params.symbol = symbol;
    return await this.privateSpotRequest("v1/margin/openOrders", params);
  }
  /**
   * Cancels all order of a given symbol
   * @param {string} symbol - the symbol to cancel all orders for
   * @return {undefined}
   */
  async mgCancelOrders(symbol, params = {}) {
    return await this.privateSpotRequest("v1/margin/openOrders", this.extend({ symbol }, params), "DELETE");
  }
  /**
   * Transfer from main account to margin account
   * @param {string} asset - the asset
   * @param {number} amount - the asset
   * @param {object} options - additional options
   * @return {undefined}
   */
  async mgTransferMainToMargin(asset, amount, params = {}) {
    params = this.extend({ asset, amount, type: 1 }, params);
    return await this.privateSpotRequest("v1/margin/transfer", params, "POST");
  }
  /**
   * Transfer from margin account to main account
   * @param {string} asset - the asset
   * @param {number} amount - the asset
   * @return {undefined}
   */
  async mgTransferMarginToMain(asset, amount, params = {}) {
    const parameters = Object.assign({ asset, amount, type: 2 });
    return await this.privateSpotRequest("v1/margin/transfer", this.extend(parameters, params), "POST");
  }
  // /**
  // * Universal Transfer requires API permissions enabled
  // * @param {string} type - ENUM , example MAIN_UMFUTURE for SPOT to USDT futures, see https://binance-docs.github.io/apidocs/spot/en/#user-universal-transfer
  // * @param {string} asset - the asset - example :USDT
  // * @param {number} amount - the callback function
  // (optionnal)
  // * @return {promise}
  // */
  // universalTransfer: (type, asset, amount, callback) =>
  //     universalTransfer(type, asset, amount, callback),
  /**
  * Get trades for a given symbol - margin account
  * @param {string} symbol - the symbol
  * @param {object} options - additional options
  * @return {promise or undefined} - omitting the callback returns a promise
  */
  async mgTrades(symbol, params = {}) {
    const parameters = Object.assign({ symbol }, params);
    return await this.privateSpotRequest("v1/margin/myTrades", parameters);
  }
  /**
  * Transfer from main account to delivery account
  * @param {string} asset - the asset
  * @param {number} amount - the asset
  * @param {object} options - additional options
  * @return {undefined}
  */
  async transferMainToFutures(asset, amount) {
    return await this.transferBetweenMainAndFutures(asset, amount, 1);
  }
  /**
  * Transfer from delivery account to main account
  * @param {string} asset - the asset
  * @param {number} amount - the asset
  (optionnal)
  * @return {undefined}
  */
  async transferFuturesToMain(asset, amount) {
    return await this.transferBetweenMainAndFutures(asset, amount, 2);
  }
  /**
   * Transfer from main account to delivery account
   * @param {string} asset - the asset
   * @param {number} amount - the asset
   (optionnal)
   * @param {object} options - additional options
   * @return {undefined}
   */
  async transferMainToDelivery(asset, amount) {
    return await this.transferBetweenMainAndFutures(asset, amount, 3);
  }
  /**
  * Transfer from delivery account to main account
  * @param {string} asset - the asset
  * @param {number} amount - the asset
  * @return {undefined}
  */
  async transferDeliveryToMain(asset, amount) {
    return await this.transferBetweenMainAndFutures(asset, amount, 4);
  }
  /**
   * Get maximum transfer-out amount of an asset
   * @param {string} asset - the asset
   * @return {undefined}
   */
  async maxTransferable(asset) {
    return await this.privateSpotRequest("v1/margin/maxTransferable", { asset });
  }
  /**
   * Margin account borrow/loan
   * @param {string} asset - the asset
   * @param {number} amount - the asset
   * @param {string} isIsolated - the isolated option
   * @param {string} symbol - symbol for isolated margin
   * @return {undefined}
   */
  async mgBorrow(asset, amount, isIsolated = "FALSE", symbol, params = {}) {
    const parameters = Object.assign({ asset, amount });
    if (isIsolated === "TRUE" && !symbol)
      throw new Error('If "isIsolated" = "TRUE", "symbol" must be sent');
    const isolatedObj = isIsolated === "TRUE" ? {
      isIsolated,
      symbol
    } : {};
    return await this.privateSpotRequest("v1/margin/loan", this.extend({ ...parameters, ...isolatedObj }, params), "POST");
  }
  /**
   * Margin account borrow/loan
   * @param {string} asset - the asset
   * @param {object} options - additional options
   * @return {undefined}
   */
  async mgQueryLoan(asset, options) {
    const parameters = Object.assign({ asset }, options);
    return await this.privateSpotRequest("v1/margin/loan", { ...parameters }, "GET");
  }
  /**
   * Margin account repay
   * @param {string} asset - the asset
   * @param {object} params - additional options
   * @return {undefined}
   */
  async mgQueryRepay(asset, params = {}) {
    const parameters = Object.assign({ asset }, params);
    return await this.privateSpotRequest("v1/margin/repay", { ...parameters }, "GET");
  }
  /**
   * Margin account repay
   * @param {string} asset - the asset
   * @param {number} amount - the asset
   * @param {string} isIsolated - the isolated option
   * @param {string} symbol - symbol for isolated margin
   * @return {undefined}
   */
  async mgRepay(asset, amount, isIsolated = "FALSE", symbol, params = {}) {
    const parameters = Object.assign({ asset, amount });
    if (isIsolated === "TRUE" && !symbol)
      throw new Error('If "isIsolated" = "TRUE", "symbol" must be sent');
    const isolatedObj = isIsolated === "TRUE" ? {
      isIsolated,
      symbol
    } : {};
    return await this.privateSpotRequest("v1/margin/repay", this.extend({ ...parameters, ...isolatedObj }, params), "POST");
  }
  /**
   * Margin account details
   * @param {boolean} isIsolated - the callback function
   * @return {undefined}
   */
  async mgAccount(isIsolated = false, params = {}) {
    let endpoint = "v1/margin";
    endpoint += isIsolated ? "/isolated" : "/account";
    return await this.privateSpotRequest(endpoint, params);
  }
  /**
   * Get maximum borrow amount of an asset
   * @param {string} asset - the asset
   * @return {undefined}
   */
  async maxBorrowable(asset, params = {}) {
    params.asset = asset;
    return await this.privateSpotRequest("v1/margin/maxBorrowable", params);
  }
  // // Futures WebSocket Functions:
  // /**
  //  * Subscribe to a single futures websocket
  //  * @param {string} url - the futures websocket endpoint
  //  * @param {function} callback - optional execution callback
  //  * @param {object} params - Optional reconnect {boolean} (whether to reconnect on disconnect), openCallback {function}, id {string}
  //  * @return {WebSocket} the websocket reference
  //  */
  // async this.futuresSubscribeSingle(url, callback: Callback, params: Dict = {}) {
  //     return this.futuresSubscribeSingle(url, callback, params);
  // }
  // /**
  //  * Subscribe to a combined futures websocket
  //  * @param {string} streams - the list of websocket endpoints to connect to
  //  * @param {function} callback - optional execution callback
  //  * @param {object} params - Optional reconnect {boolean} (whether to reconnect on disconnect), openCallback {function}, id {string}
  //  * @return {WebSocket} the websocket reference
  //  */
  // futuresSubscribe(streams, callback: Callback, params: Dict = {}) {
  //     return futuresSubscribe(streams, callback, params);
  // }
  /**
   * Returns the known futures websockets subscriptions
   * @return {array} array of futures websocket subscriptions
   */
  getFuturesSubscriptions() {
    return this.futuresSubscriptions;
  }
  // /**
  //  * Terminates a futures websocket
  //  * @param {string} endpoint - the string associated with the endpoint
  //  * @return {undefined}
  //  */
  // // futuresTerminate(endpoint) {
  // //     if (this.options.verbose) this.options.log('Futures WebSocket terminating:', endpoint);
  // //     return futuresTerminate(endpoint);
  // // }
  /**
   * Futures WebSocket aggregated trades
   * @param {array/string} symbols - an array or string of symbols to query
   * @param {function} callback - callback function
   * @return {string} the websocket endpoint
   */
  futuresAggTradeStream(symbols, callback) {
    const reconnect = () => {
      if (this.Options.reconnect)
        this.futuresAggTradeStream(symbols, callback);
    };
    let subscription;
    const cleanCallback = (data) => callback(this.fAggTradeConvertData(data));
    if (Array.isArray(symbols)) {
      if (!this.isArrayUnique(symbols))
        throw Error('futuresAggTradeStream: "symbols" cannot contain duplicate elements.');
      const streams = symbols.map((symbol) => symbol.toLowerCase() + "@aggTrade");
      subscription = this.futuresSubscribe(streams, cleanCallback, { reconnect });
    } else {
      const symbol = symbols;
      subscription = this.futuresSubscribeSingle(symbol.toLowerCase() + "@aggTrade", cleanCallback, { reconnect });
    }
    return subscription.endpoint;
  }
  /**
   * Futures WebSocket mark price
   * @param {symbol} symbol name or false. can also be a callback
   * @param {function} callback - callback function
   * @param {string} speed - 1 second updates. leave blank for default 3 seconds
   * @return {string} the websocket endpoint
   */
  futuresMarkPriceStream(symbol, callback = console.log, speed = "@1s") {
    const reconnect = () => {
      if (this.Options.reconnect)
        this.futuresMarkPriceStream(symbol, callback, speed);
    };
    const endpoint = symbol ? `${symbol.toLowerCase()}@markPrice` : "!markPrice@arr";
    const subscription = this.futuresSubscribeSingle(endpoint + speed, (data) => callback(this.fMarkPriceConvertData(data)), { reconnect });
    return subscription.endpoint;
  }
  /**
   * Futures WebSocket liquidations stream
   * @param {symbol} symbol name or false. can also be a callback
   * @param {function} callback - callback function
   * @return {string} the websocket endpoint
   */
  futuresLiquidationStream(symbol, callback = console.log) {
    const reconnect = () => {
      if (this.Options.reconnect)
        this.futuresLiquidationStream(symbol, callback);
    };
    const endpoint = symbol ? `${symbol.toLowerCase()}@forceOrder` : "!forceOrder@arr";
    const subscription = this.futuresSubscribeSingle(endpoint, (data) => callback(this.fLiquidationConvertData(data)), { reconnect });
    return subscription.endpoint;
  }
  /**
   * Futures WebSocket prevDay ticker
   * @param {symbol} symbol name or false. can also be a callback
   * @param {function} callback - callback function
   * @return {string} the websocket endpoint
   */
  futuresTickerStream(symbol, callback = console.log) {
    const reconnect = () => {
      if (this.Options.reconnect)
        this.futuresTickerStream(symbol, callback);
    };
    const endpoint = symbol ? `${symbol.toLowerCase()}@ticker` : "!ticker@arr";
    const subscription = this.futuresSubscribeSingle(endpoint, (data) => callback(this.fTickerConvertData(data)), { reconnect });
    return subscription.endpoint;
  }
  /**
   * Futures WebSocket miniTicker
   * @param {symbol} symbol name or false. can also be a callback
   * @param {function} callback - callback function
   * @return {string} the websocket endpoint
   */
  futuresMiniTickerStream(symbol, callback = console.log) {
    const reconnect = () => {
      if (this.Options.reconnect)
        this.futuresMiniTickerStream(symbol, callback);
    };
    const endpoint = symbol ? `${symbol.toLowerCase()}@miniTicker` : "!miniTicker@arr";
    const subscription = this.futuresSubscribeSingle(endpoint, (data) => callback(this.fMiniTickerConvertData(data)), { reconnect });
    return subscription.endpoint;
  }
  /**
   * Futures WebSocket bookTicker
   * @param {symbol} symbol name or false. can also be a callback
   * @param {function} callback - callback function
   * @return {string} the websocket endpoint
   */
  futuresBookTickerStream(symbol, callback = console.log) {
    const reconnect = () => {
      if (this.Options.reconnect)
        this.futuresBookTickerStream(symbol, callback);
    };
    const endpoint = symbol ? `${symbol.toLowerCase()}@bookTicker` : "!bookTicker";
    const subscription = this.futuresSubscribeSingle(endpoint, (data) => callback(this.fBookTickerConvertData(data)), { reconnect });
    return subscription.endpoint;
  }
  /**
   * Websocket futures klines
   * @param {array/string} symbols - an array or string of symbols to query
   * @param {string} interval - the time interval
   * @param {function} callback - callback function
   * @param {int} limit - maximum results, no more than 1000
   * @return {string} the websocket endpoint
   */
  futuresChart(symbols, interval2, callback, limit = 500) {
    const reconnect = () => {
      if (this.Options.reconnect)
        this.futuresChart(symbols, interval2, callback, limit);
    };
    const futuresChartInit = (symbol) => {
      if (typeof this.futuresMeta[symbol] === "undefined")
        this.futuresMeta[symbol] = {};
      if (typeof this.futuresMeta[symbol][interval2] === "undefined")
        this.futuresMeta[symbol][interval2] = {};
      if (typeof this.futuresTicks[symbol] === "undefined")
        this.futuresTicks[symbol] = {};
      if (typeof this.futuresTicks[symbol][interval2] === "undefined")
        this.futuresTicks[symbol][interval2] = {};
      if (typeof this.futuresRealtime[symbol] === "undefined")
        this.futuresRealtime[symbol] = {};
      if (typeof this.futuresRealtime[symbol][interval2] === "undefined")
        this.futuresRealtime[symbol][interval2] = {};
      if (typeof this.futuresKlineQueue[symbol] === "undefined")
        this.futuresKlineQueue[symbol] = {};
      if (typeof this.futuresKlineQueue[symbol][interval2] === "undefined")
        this.futuresKlineQueue[symbol][interval2] = [];
      this.futuresMeta[symbol][interval2].timestamp = 0;
    };
    const handleFuturesKlineStream = (kline) => {
      const symbol = kline.s, interval3 = kline.k.i;
      if (!this.futuresMeta[symbol][interval3].timestamp) {
        if (typeof this.futuresKlineQueue[symbol][interval3] !== "undefined" && kline !== null) {
          this.futuresKlineQueue[symbol][interval3].push(kline);
        }
      } else {
        this.futuresKlineHandler(symbol, kline);
        if (callback)
          callback(symbol, interval3, this.futuresKlineConcat(symbol, interval3));
      }
    };
    const getFuturesKlineSnapshot = async (symbol, limit2 = 500) => {
      const data = await this.publicFuturesRequest("v1/klines", { symbol, interval: interval2, limit: limit2 });
      this.futuresKlineData(symbol, interval2, data);
      if (typeof this.futuresKlineQueue[symbol][interval2] !== "undefined") {
        for (const kline of this.futuresKlineQueue[symbol][interval2])
          this.futuresKlineHandler(symbol, kline, this.futuresMeta[symbol][interval2].timestamp);
        delete this.futuresKlineQueue[symbol][interval2];
      }
      if (callback)
        callback(symbol, interval2, this.futuresKlineConcat(symbol, interval2));
    };
    let subscription;
    if (Array.isArray(symbols)) {
      if (!this.isArrayUnique(symbols))
        throw Error('futuresChart: "symbols" array cannot contain duplicate elements.');
      symbols.forEach(futuresChartInit);
      const streams = symbols.map((symbol) => `${symbol.toLowerCase()}@kline_${interval2}`);
      subscription = this.futuresSubscribe(streams, handleFuturesKlineStream, reconnect);
      symbols.forEach((element) => getFuturesKlineSnapshot(element, limit));
    } else {
      const symbol = symbols;
      futuresChartInit(symbol);
      subscription = this.futuresSubscribeSingle(symbol.toLowerCase() + "@kline_" + interval2, handleFuturesKlineStream, { reconnect });
      getFuturesKlineSnapshot(symbol, limit);
    }
    return subscription.endpoint;
  }
  /**
   * Websocket futures candlesticks
   * @param {array/string} symbols - an array or string of symbols to query
   * @param {string} interval - the time interval
   * @param {function} callback - callback function
   * @return {string} the websocket endpoint
   */
  futuresCandlesticksStream(symbols, interval2, callback) {
    const reconnect = () => {
      if (this.Options.reconnect)
        this.futuresCandlesticksStream(symbols, interval2, callback);
    };
    let subscription;
    if (Array.isArray(symbols)) {
      if (!this.isArrayUnique(symbols))
        throw Error('futuresCandlesticks: "symbols" array cannot contain duplicate elements.');
      const streams = symbols.map((symbol) => symbol.toLowerCase() + "@kline_" + interval2);
      subscription = this.futuresSubscribe(streams, callback, { reconnect });
    } else {
      const symbol = symbols.toLowerCase();
      subscription = this.futuresSubscribeSingle(symbol + "@kline_" + interval2, callback, { reconnect });
    }
    return subscription.endpoint;
  }
  // Delivery WebSocket Functions:
  /**
   * Subscribe to a single delivery websocket
   * @param {string} url - the delivery websocket endpoint
   * @param {function} callback - optional execution callback
   * @param {object} params - Optional reconnect {boolean} (whether to reconnect on disconnect), openCallback {function}, id {string}
   * @return {WebSocket} the websocket reference
   */
  // deliverySubscribeSingle(url, callback: Callback, params: Dict = {}) {
  //     return deliverySubscribeSingle(url, callback, params);
  // }
  // /**
  //  * Subscribe to a combined delivery websocket
  //  * @param {string} streams - the list of websocket endpoints to connect to
  //  * @param {function} callback - optional execution callback
  //  * @param {object} params - Optional reconnect {boolean} (whether to reconnect on disconnect), openCallback {function}, id {string}
  //  * @return {WebSocket} the websocket reference
  //  */
  // deliverySubscribe(streams, callback: Callback, params: Dict = {}) {
  //     return deliverySubscribe(streams, callback, params);
  // }
  /**
   * Returns the known delivery websockets subscriptions
   * @return {array} array of delivery websocket subscriptions
   */
  getDeliverySubscriptions() {
    return this.deliverySubscriptions;
  }
  // /**
  //  * Terminates a delivery websocket
  //  * @param {string} endpoint - the string associated with the endpoint
  //  * @return {undefined}
  //  */
  // deliveryTerminate(endpoint) {
  //     if (this.options.verbose) this.options.log('Delivery WebSocket terminating:', endpoint);
  //     return deliveryTerminate(endpoint);
  // }
  /**
   * Delivery WebSocket aggregated trades
   * @param {array/string} symbols - an array or string of symbols to query
   * @param {function} callback - callback function
   * @return {string} the websocket endpoint
   */
  deliveryAggTradeStream(symbols, callback) {
    const reconnect = () => {
      if (this.Options.reconnect)
        this.deliveryAggTradeStream(symbols, callback);
    };
    let subscription;
    const cleanCallback = (data) => callback(this.dAggTradeConvertData(data));
    if (Array.isArray(symbols)) {
      if (!this.isArrayUnique(symbols))
        throw Error('deliveryAggTradeStream: "symbols" cannot contain duplicate elements.');
      const streams = symbols.map((symbol) => symbol.toLowerCase() + "@aggTrade");
      subscription = this.deliverySubscribe(streams, cleanCallback, { reconnect });
    } else {
      const symbol = symbols;
      subscription = this.deliverySubscribeSingle(symbol.toLowerCase() + "@aggTrade", cleanCallback, { reconnect });
    }
    return subscription.endpoint;
  }
  /**
   * Delivery WebSocket mark price
   * @param {symbol} symbol name or false. can also be a callback
   * @param {function} callback - callback function
   * @param {string} speed - 1 second updates. leave blank for default 3 seconds
   * @return {string} the websocket endpoint
   */
  deliveryMarkPriceStream(symbol, callback = console.log, speed = "@1s") {
    const reconnect = () => {
      if (this.Options.reconnect)
        this.deliveryMarkPriceStream(symbol, callback);
    };
    const endpoint = symbol ? `${symbol.toLowerCase()}@markPrice` : "!markPrice@arr";
    const subscription = this.deliverySubscribeSingle(endpoint + speed, (data) => callback(this.dMarkPriceConvertData(data)), { reconnect });
    return subscription.endpoint;
  }
  /**
   * Delivery WebSocket liquidations stream
   * @param {symbol} symbol name or false. can also be a callback
   * @param {function} callback - callback function
   * @return {string} the websocket endpoint
   */
  deliveryLiquidationStream(symbol, callback = console.log) {
    const reconnect = () => {
      if (this.Options.reconnect)
        this.deliveryLiquidationStream(symbol, callback);
    };
    const endpoint = symbol ? `${symbol.toLowerCase()}@forceOrder` : "!forceOrder@arr";
    const subscription = this.deliverySubscribeSingle(endpoint, (data) => callback(this.dLiquidationConvertData(data)), { reconnect });
    return subscription.endpoint;
  }
  /**
   * Delivery WebSocket prevDay ticker
   * @param {symbol} symbol name or false. can also be a callback
   * @param {function} callback - callback function
   * @return {string} the websocket endpoint
   */
  deliveryTickerStream(symbol, callback = console.log) {
    const reconnect = () => {
      if (this.Options.reconnect)
        this.deliveryTickerStream(symbol, callback);
    };
    const endpoint = symbol ? `${symbol.toLowerCase()}@ticker` : "!ticker@arr";
    const subscription = this.deliverySubscribeSingle(endpoint, (data) => callback(this.dTickerConvertData(data)), { reconnect });
    return subscription.endpoint;
  }
  /**
   * Delivery WebSocket miniTicker
   * @param {symbol} symbol name or false. can also be a callback
   * @param {function} callback - callback function
   * @return {string} the websocket endpoint
   */
  deliveryMiniTickerStream(symbol, callback = console.log) {
    const reconnect = () => {
      if (this.Options.reconnect)
        this.deliveryMiniTickerStream(symbol, callback);
    };
    const endpoint = symbol ? `${symbol.toLowerCase()}@miniTicker` : "!miniTicker@arr";
    const subscription = this.deliverySubscribeSingle(endpoint, (data) => callback(this.dMiniTickerConvertData(data)), { reconnect });
    return subscription.endpoint;
  }
  /**
   * Delivery WebSocket bookTicker
   * @param {symbol} symbol name or false. can also be a callback
   * @param {function} callback - callback function
   * @return {string} the websocket endpoint
   */
  deliveryBookTickerStream(symbol, callback = console.log) {
    const reconnect = () => {
      if (this.Options.reconnect)
        this.deliveryBookTickerStream(symbol, callback);
    };
    const endpoint = symbol ? `${symbol.toLowerCase()}@bookTicker` : "!bookTicker";
    const subscription = this.deliverySubscribeSingle(endpoint, (data) => callback(this.dBookTickerConvertData(data)), { reconnect });
    return subscription.endpoint;
  }
  /**
   * Websocket delivery klines
   * @param {array/string} symbols - an array or string of symbols to query
   * @param {string} interval - the time interval
   * @param {function} callback - callback function
   * @param {int} limit - maximum results, no more than 1000
   * @return {string} the websocket endpoint
   */
  deliveryChart(symbols, interval2, callback, limit = 500) {
    const reconnect = () => {
      if (this.Options.reconnect)
        this.deliveryChart(symbols, interval2, callback, limit);
    };
    const deliveryChartInit = (symbol) => {
      if (typeof this.deliveryMeta[symbol] === "undefined")
        this.deliveryMeta[symbol] = {};
      if (typeof this.deliveryMeta[symbol][interval2] === "undefined")
        this.deliveryMeta[symbol][interval2] = {};
      if (typeof this.deliveryTicks[symbol] === "undefined")
        this.deliveryTicks[symbol] = {};
      if (typeof this.deliveryTicks[symbol][interval2] === "undefined")
        this.deliveryTicks[symbol][interval2] = {};
      if (typeof this.deliveryRealtime[symbol] === "undefined")
        this.deliveryRealtime[symbol] = {};
      if (typeof this.deliveryRealtime[symbol][interval2] === "undefined")
        this.deliveryRealtime[symbol][interval2] = {};
      if (typeof this.deliveryKlineQueue[symbol] === "undefined")
        this.deliveryKlineQueue[symbol] = {};
      if (typeof this.deliveryKlineQueue[symbol][interval2] === "undefined")
        this.deliveryKlineQueue[symbol][interval2] = [];
      this.deliveryMeta[symbol][interval2].timestamp = 0;
    };
    const handleDeliveryKlineStream = (kline) => {
      const symbol = kline.s, interval3 = kline.k.i;
      if (!this.deliveryMeta[symbol][interval3].timestamp) {
        if (typeof this.deliveryKlineQueue[symbol][interval3] !== "undefined" && kline !== null) {
          this.deliveryKlineQueue[symbol][interval3].push(kline);
        }
      } else {
        this.deliveryKlineHandler(symbol, kline);
        if (callback)
          callback(symbol, interval3, this.deliveryKlineConcat(symbol, interval3));
      }
    };
    const getDeliveryKlineSnapshot = async (symbol, limit2 = 500) => {
      const data = await this.publicDeliveryRequest("v1/klines", { symbol, interval: interval2, limit: limit2 });
      this.deliveryKlineData(symbol, interval2, data);
      if (typeof this.deliveryKlineQueue[symbol][interval2] !== "undefined") {
        for (const kline of this.deliveryKlineQueue[symbol][interval2])
          this.deliveryKlineHandler(symbol, kline, this.deliveryMeta[symbol][interval2].timestamp);
        delete this.deliveryKlineQueue[symbol][interval2];
      }
      if (callback)
        callback(symbol, interval2, this.deliveryKlineConcat(symbol, interval2));
    };
    let subscription;
    if (Array.isArray(symbols)) {
      if (!this.isArrayUnique(symbols))
        throw Error('deliveryChart: "symbols" array cannot contain duplicate elements.');
      symbols.forEach(deliveryChartInit);
      const streams = symbols.map((symbol) => `${symbol.toLowerCase()}@kline_${interval2}`);
      subscription = this.deliverySubscribe(streams, handleDeliveryKlineStream, reconnect);
      symbols.forEach((element) => getDeliveryKlineSnapshot(element, limit));
    } else {
      const symbol = symbols;
      deliveryChartInit(symbol);
      subscription = this.deliverySubscribeSingle(symbol.toLowerCase() + "@kline_" + interval2, handleDeliveryKlineStream, reconnect);
      getDeliveryKlineSnapshot(symbol, limit);
    }
    return subscription.endpoint;
  }
  /**
   * Websocket delivery candlesticks
   * @param {array/string} symbols - an array or string of symbols to query
   * @param {string} interval - the time interval
   * @param {function} callback - callback function
   * @return {string} the websocket endpoint
   */
  deliveryCandlesticks(symbols, interval2, callback) {
    const reconnect = () => {
      if (this.Options.reconnect)
        this.deliveryCandlesticks(symbols, interval2, callback);
    };
    let subscription;
    if (Array.isArray(symbols)) {
      if (!this.isArrayUnique(symbols))
        throw Error('deliveryCandlesticks: "symbols" array cannot contain duplicate elements.');
      const streams = symbols.map((symbol) => symbol.toLowerCase() + "@kline_" + interval2);
      subscription = this.deliverySubscribe(streams, callback, { reconnect });
    } else {
      const symbol = symbols.toLowerCase();
      subscription = this.deliverySubscribeSingle(symbol + "@kline_" + interval2, callback, { reconnect });
    }
    return subscription.endpoint;
  }
  /**
   * Userdata websockets function
   * @param {function} all_updates_callback
   * @param {function} execution_callback - optional execution callback
   * @param {function} subscribed_callback - subscription callback
   * @param {function} list_status_callback - status callback
   * @return {undefined}
   */
  userData(all_updates_callback, balance_callback, execution_callback, subscribed_callback, list_status_callback) {
    const reconnect = () => {
      if (this.Options.reconnect)
        this.userData(all_updates_callback, balance_callback, execution_callback, subscribed_callback);
    };
    this.apiRequest(this.getSpotUrl() + "v3/userDataStream", {}, "POST").then((response) => {
      this.Options.listenKey = response.listenKey;
      const keepAlive = this.spotListenKeyKeepAlive;
      const self2 = this;
      setTimeout(async function userDataKeepAlive() {
        try {
          await self2.apiRequest(self2.getSpotUrl() + "v3/userDataStream?listenKey=" + self2.Options.listenKey, {}, "PUT");
          setTimeout(userDataKeepAlive, keepAlive);
        } catch (error) {
          setTimeout(userDataKeepAlive, 6e4);
        }
      }, keepAlive);
      this.Options.all_updates_callback = all_updates_callback;
      this.Options.balance_callback = balance_callback;
      this.Options.execution_callback = execution_callback ? execution_callback : balance_callback;
      this.Options.list_status_callback = list_status_callback;
      const subscription = this.subscribe(this.Options.listenKey, this.userDataHandler, reconnect);
      if (subscribed_callback)
        subscribed_callback(subscription.endpoint);
    });
  }
  /**
   * Margin Userdata websockets function
   * @param {function} all_updates_callback
   * @param {function} execution_callback - optional execution callback
   * @param {function} subscribed_callback - subscription callback
   * @param {function} list_status_callback - status callback
   * @return {undefined}
   */
  userMarginData(all_updates_callback, balance_callback, execution_callback, subscribed_callback, list_status_callback) {
    const reconnect = () => {
      if (this.Options.reconnect)
        this.userMarginData(balance_callback, execution_callback, subscribed_callback);
    };
    this.apiRequest(this.sapi + "v1/userDataStream", {}, "POST").then((response) => {
      this.Options.listenMarginKey = response.listenKey;
      const url2 = this.sapi + "v1/userDataStream?listenKey=" + this.Options.listenMarginKey;
      const apiRequest = this.apiRequest;
      const keepAlive = this.spotListenKeyKeepAlive;
      setTimeout(async function userDataKeepAlive() {
        try {
          await apiRequest(url2, {}, "PUT");
          setTimeout(userDataKeepAlive, keepAlive);
        } catch (error) {
          setTimeout(userDataKeepAlive, 6e4);
        }
      }, keepAlive);
      this.Options.margin_all_updates_callback = all_updates_callback;
      this.Options.margin_balance_callback = balance_callback;
      this.Options.margin_execution_callback = execution_callback;
      this.Options.margin_list_status_callback = list_status_callback;
      const subscription = this.subscribe(this.Options.listenMarginKey, this.userMarginDataHandler, reconnect);
      if (subscribed_callback)
        subscribed_callback(subscription.endpoint);
    });
  }
  /**
   * Future Userdata websockets function
   * @param {function} all_updates_callback
   * @param {function} margin_call_callback
   * @param {function} account_update_callback
   * @param {function} order_update_callback
   * @param {Function} subscribed_callback - subscription callback
   */
  userFutureData(all_updates_callback, margin_call_callback, account_update_callback, order_update_callback, subscribed_callback, account_config_update_callback) {
    const url2 = this.Options.test ? this.fapiTest : this.fapi;
    const reconnect = () => {
      if (this.Options.reconnect)
        this.userFutureData(all_updates_callback, margin_call_callback, account_update_callback, order_update_callback, subscribed_callback);
    };
    this.apiRequest(url2 + "v1/listenKey", {}, "POST").then((response) => {
      this.Options.listenFutureKey = response.listenKey;
      const self2 = this;
      const keepAlive = this.futuresListenKeyKeepAlive;
      setTimeout(async function userDataKeepAlive() {
        try {
          await self2.apiRequest(url2 + "v1/listenKey?listenKey=" + self2.Options.listenFutureKey, {}, "PUT");
          setTimeout(userDataKeepAlive, keepAlive);
        } catch (error) {
          setTimeout(userDataKeepAlive, 6e4);
        }
      }, keepAlive);
      this.Options.futures_all_updates_callback = all_updates_callback;
      this.Options.future_margin_call_callback = margin_call_callback;
      this.Options.future_account_update_callback = account_update_callback;
      this.Options.future_account_config_update_callback = account_config_update_callback;
      this.Options.future_order_update_callback = order_update_callback;
      const subscription = this.futuresSubscribe(this.Options.listenFutureKey, this.userFutureDataHandler, { reconnect });
      if (subscribed_callback)
        subscribed_callback(subscription.endpoint);
    });
  }
  /**
  * Delivery Userdata websockets function
  * @param {function} margin_call_callback
  * @param {function} account_update_callback
  * @param {function} order_update_callback
  * @param {Function} subscribed_callback - subscription callback
  */
  userDeliveryData(margin_call_callback, account_update_callback, order_update_callback, subscribed_callback) {
    const url2 = this.Options.test ? this.dapiTest : this.dapi;
    const reconnect = async () => {
      if (this.Options.reconnect)
        await this.userDeliveryData(margin_call_callback, account_update_callback, order_update_callback, subscribed_callback);
    };
    this.apiRequest(url2 + "v1/listenKey", {}, "POST").then((response) => {
      this.Options.listenDeliveryKey = response.listenKey;
      const getDeliveryKey = () => this.Options.listenDeliveryKey;
      const self2 = this;
      const keepAlive = this.futuresListenKeyKeepAlive;
      setTimeout(async function userDataKeepAlive() {
        try {
          await self2.apiRequest(url2 + "v1/listenKey?listenKey=" + getDeliveryKey(), {}, "PUT");
          setTimeout(userDataKeepAlive, keepAlive);
        } catch (error) {
          setTimeout(userDataKeepAlive, 6e4);
        }
      }, keepAlive);
      this.Options.delivery_margin_call_callback = margin_call_callback;
      this.Options.delivery_account_update_callback = account_update_callback;
      this.Options.delivery_order_update_callback = order_update_callback;
      const subscription = this.deliverySubscribe(this.Options.listenDeliveryKey, this.userDeliveryDataHandler, { reconnect });
      if (subscribed_callback)
        subscribed_callback(subscription.endpoint);
    });
  }
  // /**
  //  * Subscribe to a generic websocket
  //  * @param {string} url - the websocket endpoint
  //  * @param {function} callback - optional execution callback
  //  * @param {boolean} reconnect - subscription callback
  //  * @return {WebSocket} the websocket reference
  //  */
  // // subscribe(url, callback, reconnect = false) {
  // //     return subscribe(url, callback, reconnect);
  // // }
  // /**
  //  * Subscribe to a generic combined websocket
  //  * @param {string} url - the websocket endpoint
  //  * @param {function} callback - optional execution callback
  //  * @param {boolean} reconnect - subscription callback
  //  * @return {WebSocket} the websocket reference
  //  */
  // // subscribeCombined(url, callback, reconnect = false) {
  // //     return subscribeCombined(url, callback, reconnect);
  // // }
  // /**
  //  * Returns the known websockets subscriptions
  //  * @return {array} array of web socket subscriptions
  //  */
  getSubscriptions() {
    return this.subscriptions;
  }
  // /**
  //  * Terminates a web socket
  //  * @param {string} endpoint - the string associated with the endpoint
  //  * @return {undefined}
  //  */
  // terminate(endpoint) {
  //     if (this.options.verbose) this.options.log('WebSocket terminating:', endpoint);
  //     return this.terminate(endpoint);
  // }
  /**
   * Websocket depth chart
   * @param {array/string} symbols - an array or string of symbols to query
   * @param {function} callback - callback function
   * @return {string} the websocket endpoint
   */
  depthStream(symbols, callback) {
    const reconnect = () => {
      if (this.Options.reconnect)
        this.depthStream(symbols, callback);
    };
    let subscription;
    if (Array.isArray(symbols)) {
      if (!this.isArrayUnique(symbols))
        throw Error('depth: "symbols" cannot contain duplicate elements.');
      const streams = symbols.map(function(symbol) {
        return symbol.toLowerCase() + "@depth@100ms";
      });
      subscription = this.subscribeCombined(streams, callback, reconnect);
    } else {
      const symbol = symbols;
      subscription = this.subscribe(symbol.toLowerCase() + "@depth@100ms", callback, reconnect);
    }
    return subscription.endpoint;
  }
  /**
   * Websocket depth cache
   * @param {array/string} symbols - an array or string of symbols to query
   * @param {function} callback - callback function
   * @param {int} limit - the number of entries
   * @return {string} the websocket endpoint
   */
  depthCacheStream(symbols, callback, limit = 500) {
    const reconnect = () => {
      if (this.Options.reconnect)
        this.depthCacheStream(symbols, callback, limit);
    };
    const symbolDepthInit = (symbol) => {
      if (typeof this.depthCacheContext[symbol] === "undefined")
        this.depthCacheContext[symbol] = {};
      const context = this.depthCacheContext[symbol];
      context.snapshotUpdateId = null;
      context.lastEventUpdateId = null;
      context.messageQueue = [];
      this.depthCache[symbol] = { bids: {}, asks: {} };
    };
    const assignEndpointIdToContext = (symbol, endpointId) => {
      if (this.depthCacheContext[symbol]) {
        const context = this.depthCacheContext[symbol];
        context.endpointId = endpointId;
      }
    };
    const handleDepthStreamData = (depth) => {
      const symbol = depth.s;
      const context = this.depthCacheContext[symbol];
      if (context.messageQueue && !context.snapshotUpdateId) {
        context.messageQueue.push(depth);
      } else {
        try {
          this.depthHandler(depth);
        } catch (err) {
          return this.terminate(context.endpointId, true);
        }
        if (callback)
          callback(symbol, this.depthCache[symbol], context);
      }
    };
    const getSymbolDepthSnapshot = async (symbol, cb) => {
      const json = await this.publicSpotRequest("v3/depth", { symbol, limit });
      json.symbol = symbol;
      cb(null, json);
    };
    const updateSymbolDepthCache = (json) => {
      const symbol = json.symbol;
      this.depthCache[symbol] = this.depthData(json);
      const context = this.depthCacheContext[symbol];
      context.snapshotUpdateId = json.lastUpdateId;
      context.messageQueue = context.messageQueue.filter((depth) => depth.u > context.snapshotUpdateId);
      for (const depth of context.messageQueue) {
        try {
          this.depthHandler(depth);
        } catch (err) {
        }
      }
      delete context.messageQueue;
      if (callback)
        callback(symbol, this.depthCache[symbol]);
    };
    let subscription;
    if (Array.isArray(symbols)) {
      if (!this.isArrayUnique(symbols))
        throw Error('depthCache: "symbols" cannot contain duplicate elements.');
      symbols.forEach(symbolDepthInit);
      const streams = symbols.map(function(symbol) {
        return symbol.toLowerCase() + `@depth@100ms`;
      });
      subscription = this.subscribeCombined(streams, handleDepthStreamData, reconnect, function() {
        import_async.default.mapLimit(symbols, 50, getSymbolDepthSnapshot, (err, results) => {
          if (err)
            throw err;
          results.forEach(updateSymbolDepthCache);
        });
      });
      symbols.forEach((s2) => assignEndpointIdToContext(s2, subscription.endpoint));
    } else {
      const symbol = symbols;
      symbolDepthInit(symbol);
      subscription = this.subscribe(symbol.toLowerCase() + `@depth@100ms`, handleDepthStreamData, reconnect, function() {
        import_async.default.mapLimit([symbol], 1, getSymbolDepthSnapshot, (err, results) => {
          if (err)
            throw err;
          results.forEach(updateSymbolDepthCache);
        });
      });
      assignEndpointIdToContext(symbol, subscription.endpoint);
    }
    return subscription.endpoint;
  }
  /**
   * Clear Websocket depth cache
   * @param {String|Array} symbols   - a single symbol, or an array of symbols, to clear the cache of
   * @returns {void}
   */
  clearDepthCache(symbols) {
    const symbolsArr = Array.isArray(symbols) ? symbols : [symbols];
    symbolsArr.forEach((thisSymbol) => {
      delete this.depthCache[thisSymbol];
    });
  }
  /**
   * Websocket staggered depth cache
   * @param {array/string} symbols - an array of symbols to query
   * @param {function} callback - callback function
   * @param {int} limit - the number of entries
   * @param {int} stagger - ms between each depth cache
   * @return {Promise} the websocket endpoint
   */
  depthCacheStaggered(symbols, callback, limit = 100, stagger = 200) {
    if (!Array.isArray(symbols))
      symbols = [symbols];
    let chain = null;
    symbols.forEach((symbol) => {
      const promise = () => new Promise((resolve) => {
        this.depthCacheStream(symbol, callback, limit);
        setTimeout(resolve, stagger);
      });
      chain = chain ? chain.then(promise) : promise();
    });
    return chain;
  }
  /**
   * Websocket aggregated trades
   * @param {array/string} symbols - an array or string of symbols to query
   * @param {function} callback - callback function
   * @return {string} the websocket endpoint
   */
  aggTradesStream(symbols, callback) {
    const reconnect = () => {
      if (this.Options.reconnect)
        this.aggTradesStream(symbols, callback);
    };
    let subscription;
    if (Array.isArray(symbols)) {
      if (!this.isArrayUnique(symbols))
        throw Error('trades: "symbols" cannot contain duplicate elements.');
      const streams = symbols.map(function(symbol) {
        return symbol.toLowerCase() + "@aggTrade";
      });
      subscription = this.subscribeCombined(streams, callback, reconnect);
    } else {
      const symbol = symbols;
      subscription = this.subscribe(symbol.toLowerCase() + "@aggTrade", callback, reconnect);
    }
    return subscription.endpoint;
  }
  /**
  * Websocket raw trades
  * @param {array/string} symbols - an array or string of symbols to query
  * @param {function} callback - callback function
  * @return {string} the websocket endpoint
  */
  tradesStream(symbols, callback) {
    const reconnect = () => {
      if (this.Options.reconnect)
        this.tradesStream(symbols, callback);
    };
    let subscription;
    if (Array.isArray(symbols)) {
      if (!this.isArrayUnique(symbols))
        throw Error('trades: "symbols" cannot contain duplicate elements.');
      const streams = symbols.map(function(symbol) {
        return symbol.toLowerCase() + "@trade";
      });
      subscription = this.subscribeCombined(streams, callback, reconnect);
    } else {
      const symbol = symbols;
      subscription = this.subscribe(symbol.toLowerCase() + "@trade", callback, reconnect);
    }
    return subscription.endpoint;
  }
  /**
   * Websocket klines
   * @param {array/string} symbols - an array or string of symbols to query
   * @param {string} interval - the time interval
   * @param {function} callback - callback function
   * @param {int} limit - maximum results, no more than 1000
   * @return {string} the websocket endpoint
   */
  chart(symbols, interval2, callback, limit = 500) {
    const reconnect = () => {
      if (this.Options.reconnect)
        this.chart(symbols, interval2, callback, limit);
    };
    const symbolChartInit = (symbol) => {
      if (typeof this.info[symbol] === "undefined")
        this.info[symbol] = {};
      if (typeof this.info[symbol][interval2] === "undefined")
        this.info[symbol][interval2] = {};
      if (typeof this.ohlc[symbol] === "undefined")
        this.ohlc[symbol] = {};
      if (typeof this.ohlc[symbol][interval2] === "undefined")
        this.ohlc[symbol][interval2] = {};
      if (typeof this.ohlcLatest[symbol] === "undefined")
        this.ohlcLatest[symbol] = {};
      if (typeof this.ohlcLatest[symbol][interval2] === "undefined")
        this.ohlcLatest[symbol][interval2] = {};
      if (typeof this.klineQueue[symbol] === "undefined")
        this.klineQueue[symbol] = {};
      if (typeof this.klineQueue[symbol][interval2] === "undefined")
        this.klineQueue[symbol][interval2] = [];
      this.info[symbol][interval2].timestamp = 0;
    };
    const handleKlineStreamData = (kline) => {
      const symbol = kline.s, interval3 = kline.k.i;
      if (!this.info[symbol][interval3].timestamp) {
        if (typeof this.klineQueue[symbol][interval3] !== "undefined" && kline !== null) {
          this.klineQueue[symbol][interval3].push(kline);
        }
      } else {
        this.klineHandler(symbol, kline);
        if (callback)
          callback(symbol, interval3, this.klineConcat(symbol, interval3));
      }
    };
    const getSymbolKlineSnapshot = async (symbol, limit2 = 500) => {
      const data = await this.publicSpotRequest("v3/klines", { symbol, interval: interval2, limit: limit2 });
      this.klineData(symbol, interval2, data);
      if (typeof this.klineQueue[symbol][interval2] !== "undefined") {
        for (const kline of this.klineQueue[symbol][interval2])
          this.klineHandler(symbol, kline, this.info[symbol][interval2].timestamp);
        delete this.klineQueue[symbol][interval2];
      }
      if (callback)
        callback(symbol, interval2, this.klineConcat(symbol, interval2));
    };
    let subscription;
    if (Array.isArray(symbols)) {
      if (!this.isArrayUnique(symbols))
        throw Error('chart: "symbols" cannot contain duplicate elements.');
      symbols.forEach(symbolChartInit);
      const streams = symbols.map(function(symbol) {
        return symbol.toLowerCase() + "@kline_" + interval2;
      });
      subscription = this.subscribeCombined(streams, handleKlineStreamData, reconnect);
      symbols.forEach((element) => getSymbolKlineSnapshot(element, limit));
    } else {
      const symbol = symbols;
      symbolChartInit(symbol);
      subscription = this.subscribe(symbol.toLowerCase() + "@kline_" + interval2, handleKlineStreamData, reconnect);
      getSymbolKlineSnapshot(symbol, limit);
    }
    return subscription.endpoint;
  }
  /**
   * Websocket candle sticks
   * @param {array/string} symbols - an array or string of symbols to query
   * @param {string} interval - the time interval
   * @param {function} callback - callback function
   * @return {string} the websocket endpoint
   */
  candlesticksStream(symbols, interval2, callback) {
    const reconnect = () => {
      if (this.Options.reconnect)
        this.candlesticksStream(symbols, interval2, callback);
    };
    let subscription;
    if (Array.isArray(symbols)) {
      if (!this.isArrayUnique(symbols))
        throw Error('candlesticks: "symbols" cannot contain duplicate elements.');
      const streams = symbols.map(function(symbol) {
        return symbol.toLowerCase() + "@kline_" + interval2;
      });
      subscription = this.subscribeCombined(streams, callback, reconnect);
    } else {
      const symbol = symbols.toLowerCase();
      subscription = this.subscribe(symbol + "@kline_" + interval2, callback, reconnect);
    }
    return subscription.endpoint;
  }
  /**
   * Websocket mini ticker
   * @param {function} callback - callback function
   * @return {string} the websocket endpoint
   */
  miniTicker(callback) {
    const reconnect = () => {
      if (this.Options.reconnect)
        this.miniTicker(callback);
    };
    const subscription = this.subscribe("!miniTicker@arr", function(data) {
      const markets = {};
      for (const obj of data) {
        markets[obj.s] = {
          close: obj.c,
          open: obj.o,
          high: obj.h,
          low: obj.l,
          volume: obj.v,
          quoteVolume: obj.q,
          eventTime: obj.E
        };
      }
      callback(markets);
    }, reconnect);
    return subscription.endpoint;
  }
  /**
   * Spot WebSocket bookTicker (bid/ask quotes including price & amount)
   * @param {symbol} symbol name or false. can also be a callback
   * @param {function} callback - callback function
   * @return {string} the websocket endpoint
   */
  bookTickersStream(symbol, callback = console.log) {
    const reconnect = () => {
      if (this.Options.reconnect)
        this.bookTickersStream(symbol, callback);
    };
    const endpoint = symbol ? `${symbol.toLowerCase()}@bookTicker` : "!bookTicker";
    const subscription = this.subscribe(endpoint, (data) => callback(this.fBookTickerConvertData(data)), reconnect);
    return subscription.endpoint;
  }
  /**
   * Websocket prevday percentage
   * @param {array/string} symbols - an array or string of symbols to query
   * @param {function} callback - callback function
   * @param {boolean} singleCallback - avoid call one callback for each symbol in data array
   * @return {string} the websocket endpoint
   */
  prevDayStream(symbols, callback, singleCallback) {
    const reconnect = () => {
      if (this.Options.reconnect)
        this.prevDayStream(symbols, callback, singleCallback);
    };
    let subscription;
    const prevDayStreamHandler = this.prevDayStreamHandler.bind(this);
    if (Array.isArray(symbols)) {
      if (!this.isArrayUnique(symbols))
        throw Error('prevDay: "symbols" cannot contain duplicate elements.');
      const streams = symbols.map(function(symbol) {
        return symbol.toLowerCase() + "@ticker";
      });
      subscription = this.subscribeCombined(streams, function(data) {
        prevDayStreamHandler(data, callback);
      }, reconnect);
    } else if (symbols) {
      const symbol = symbols;
      subscription = this.subscribe(symbol.toLowerCase() + "@ticker", function(data) {
        prevDayStreamHandler(data, callback);
      }, reconnect);
    } else {
      subscription = this.subscribe("!ticker@arr", function(data) {
        if (singleCallback) {
          prevDayStreamHandler(data, callback);
        } else {
          for (const line of data) {
            prevDayStreamHandler(line, callback);
          }
        }
      }, reconnect);
    }
    return subscription.endpoint;
  }
};

// src/services/binance-api.service.ts
dotenv.config();
var BinanceApiService = class _BinanceApiService {
  static {
    this.binance = new Binance().options({
      APIKEY: process.env.APIKEY,
      APISECRET: process.env.APISECRET,
      family: 4,
      test: true
    });
  }
  /**
   * Get account balance for all assets
   * @returns Promise containing account balances
   */
  static async getBalance() {
    return await _BinanceApiService.binance.balance();
  }
  /**
   * Place a buy order for an asset
   * @param asset The trading pair symbol (e.g. 'BTCUSDT')
   * @param quantity The amount to buy
   * @param price Optional limit price, if not provided a market order will be placed
   * @returns Promise containing the order details
   */
  static buy(asset, quantity, price) {
    if (price) {
      return _BinanceApiService.binance.buy(asset, quantity, price);
    }
    return _BinanceApiService.binance.marketBuy(asset, quantity);
  }
  /**
   * Place a sell order for an asset
   * @param asset The trading pair symbol (e.g. 'BTCUSDT')
   * @param quantity The amount to sell
   * @param price Optional limit price, if not provided a market order will be placed
   * @returns Promise containing the order details
   */
  static sell(asset, quantity, price) {
    if (price) {
      return _BinanceApiService.binance.sell(asset, quantity, price);
    }
    return _BinanceApiService.binance.marketSell(asset, quantity);
  }
  /**
   * Get current market price for an asset
   * @param asset The trading pair symbol (e.g. 'BTCUSDT')
   * @returns Promise containing the current price as a string
   */
  static async getMarketPrice(asset) {
    return (await _BinanceApiService.binance.prices())[asset];
  }
};

// src/services/trade.service.ts
var TradeService = class {
  /**
   * Places a buy order and optionally sets a take profit order
   * @param asset - The trading pair symbol
   * @param quantity - The amount to buy
   * @param tpPrice - The take profit price
   * @param withTp - Whether to place a take profit order
   * @returns Promise<Order> - The executed buy order
   * @throws Error if the order is not filled
   */
  async buyAndSetTakeProfit(asset, quantity, tpPrice, withTp = false) {
    const order = await BinanceApiService.buy(asset, quantity);
    if (withTp && order.status === "FILLED") {
      await BinanceApiService.sell(asset, quantity, tpPrice);
    } else {
      throw new Error("Order not filled");
    }
    return order;
  }
  /**
   * Places a buy order with take profit based on configured parameters
   * Uses BASE_CURRENCY balance and TARGET_ROI for calculations
   * @throws Error if the trade execution fails
   */
  static async handleBuy() {
    const balance = (await BinanceApiService.getBalance()).balances.find(
      (balance2) => balance2.asset === BASE_CURRENCY
    ) * BALANCE_IN_POSTIOTION;
    const marketPrice = await BinanceApiService.getMarketPrice(PAIR);
    const quantity = balance / marketPrice;
    const tpPrice = marketPrice * TARGET_ROI;
    LogService.log(
      `Setting up trade for : ${PAIR} amount: ${quantity} BuyPrice ${marketPrice} SellPrice ${tpPrice} roi:${tpPrice / marketPrice} @${(/* @__PURE__ */ new Date()).toISOString()}`
    );
    try {
      const order = await buyAndSetTakeProfit(PAIR, quantity, tpPrice);
      LogService.log(`Order placed: ${JSON.stringify(order)}`);
      LogService.log(`Take profit set at: ${tpPrice}`);
    } catch (error) {
      LogService.log(`Error executing trade: ${error.message}`);
    }
  }
  /**
   * Places a sell order based on configured parameters
   * Uses ASSET balance for quantity calculation
   * @throws Error if the trade execution fails
   */
  static async handleSell() {
    const quantity = (await BinanceApiService.getBalance()).balances.find(
      (balance) => balance.asset === ASSET
    ) * BALANCE_IN_POSTIOTION;
    const marketPrice = await BinanceApiService.getMarketPrice(PAIR);
    LogService.log(
      `Setting up trade for : ${PAIR} amount: ${quantity} SellPrice ${marketPrice} @${(/* @__PURE__ */ new Date()).toISOString()}`
    );
    try {
      const order = await BinanceApiService.sell(PAIR, quantity);
      LogService.log(`Order placed: ${JSON.stringify(order)}`);
    } catch (error) {
      LogService.log(`Error executing trade: ${error.message}`);
    }
  }
};
function buyAndSetTakeProfit(PAIR2, quantity, tpPrice) {
  throw new Error("Function not implemented.");
}

// src/app.ts
var interval = new TickInterval(Interval[TIME_FRAME]);
var marketService = new MarketService(PAIR, interval, 100);
var strategyManager = new StrategyManager(new SuperTrendStrategy());
async function runTradingBot() {
  const candlestick = await marketService.fetchCandlestickData();
  const superTrends = (0, import_supertrend.supertrend)({
    initialArray: candlestick,
    multiplier: 3,
    period: 10
  });
  const decision = strategyManager.executeStrategy(candlestick, superTrends);
  if (decision.length) {
    LogService.log(
      `Latest Candle:${JSON.stringify(candlestick[candlestick.length - 1])}`
    );
    LogService.log(`Trade Decision: ${decision}`);
    if (decision === Operation.BUY) {
      TradeService.handleBuy();
    } else if (decision === Operation.SELL) {
      TradeService.handleSell();
    }
  }
}
runTradingBot();
setInterval(runTradingBot, interval.getTickIntervalInMs());
/*! Bundled license information:

web-streams-polyfill/dist/ponyfill.es2018.js:
  (**
   * @license
   * web-streams-polyfill v3.3.3
   * Copyright 2024 Mattias Buelens, Diwank Singh Tomer and other contributors.
   * This code is released under the MIT license.
   * SPDX-License-Identifier: MIT
   *)

fetch-blob/index.js:
  (*! fetch-blob. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> *)

formdata-polyfill/esm.min.js:
  (*! formdata-polyfill. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> *)

node-domexception/index.js:
  (*! node-domexception. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> *)
*/
